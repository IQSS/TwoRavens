/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!************************!*\
  !*** ./src/app_ddi.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//////////\n// Globals\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an \n// argument (for ex., gui.html?dfId=17), but hostname isn't. \n// Edit it to suit your installation. \n// (NOTE that if the file id isn't supplied, the app will default to the \n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and \n// the tab-delimited data file; the parameters are ddiurl and dataurl. \n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls \n// for both the data and metadata, if the file id is supplied; or the \n// local files if nothing is supplied. \n// -- L.A.\n\nvar varColor = '#f0f8ff'; //d3.rgb(\"aliceblue\");\nvar selVarColor = '#fa8072'; //d3.rgb(\"salmon\");\nvar dvColor = '#28a4c9';\nvar nomColor = '#ff6600';\n\n// transformation toolbar options\nvar transformList = [\"log(d)\", \"exp(d)\", \"d^2\", \"sqrt(d)\", \"interact(d,e)\"];\n\n// Radius of circle\nvar allR = 40;\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = [\"true\"];\nvar priv = false;\n\nvar zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: \"\",\n    zvars: [],\n    zdv: [],\n    zdataurl: \"\",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: \"\",\n    zdatacite: \"\"\n};\n\nvar modelCount = 0;\nvar summaryHold = false;\n\nvar valueKey = [];\nvar allNodes = [];\nvar nodes = [];\nvar links = [];\nvar mods = {};\n\nvar svg, width, height, div, obj, rappURL;\nvar arc3, arc4;\n\nvar dataurl;\nmodule.exports = function main(fileid, hostname, ddiurl, dataurl) {\n    dataurl = dataurl;\n    var production = false;\n\n    if (production && fileid == \"\") {\n        alert(\"Error: No fileid has been provided.\");\n        throw new Error(\"Error: No fileid has been provided.\");\n    }\n\n    var dataverseurl = \"\";\n    if (hostname) {\n        dataverseurl = \"https://\" + hostname;\n    } else if (production) {\n        dataverseurl = \"%PRODUCTION_DATAVERSE_URL%\";\n    } else {\n        dataverseurl = \"http://localhost:8080\";\n    }\n\n    if (fileid && !dataurl) {\n        // file id supplied; we are going to assume that we are dealing with\n        // a dataverse and cook a standard dataverse data access url,\n        // with the fileid supplied and the hostname we have\n        // either supplied or configured:\n        dataurl = dataverseurl + \"/api/access/datafile/\" + fileid;\n        dataurl = dataurl + \"?key=\" + apikey;\n        // (it is also possible to supply dataurl to the script directly, \n        // as an argument -- L.A.)\n    }\n\n    // base URL for the R apps:\n    if (!production) {\n        rappURL = \"http://0.0.0.0:8000/custom/\";\n    } else {\n        rappURL = \"https://beta.dataverse.org/custom/\";\n    }\n\n    svg = d3.select(\"#main.left div.carousel-inner\").attr('id', 'innercarousel').append('div').attr('class', 'item active').attr('id', 'm0').append('svg').attr('id', 'whitespace');\n\n    var logArray = [];\n\n    var tempWidth = d3.select(\"#main.left\").style(\"width\");\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // Hard coding for header and footer and bottom margin.\n\n    var estimated = false;\n    var estimateLadda = Ladda.create(document.getElementById(\"btnEstimate\"));\n    var selectLadda = Ladda.create(document.getElementById(\"btnSelect\"));\n    var rightClickLast = false;\n\n    // this is the initial color scale that is used to establish the initial colors of the nodes.  allNodes.push() below establishes a field for the master node array allNodes called \"nodeCol\" and assigns a color from this scale to that field.  everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\n    var colors = d3.scale.category20();\n\n    var colorTime = false;\n    var timeColor = '#2d6ca2';\n\n    var colorCS = false;\n    var csColor = '#419641';\n\n    var depVar = false;\n\n    var subsetdiv = false;\n    var setxdiv = false;\n\n    var taggedColor = '#f5f5f5'; //d3.rgb(\"whitesmoke\");\n    var grayColor = '#c0c0c0';\n\n    var lefttab = \"tab1\"; //global for current tab in left panel\n    var righttab = \"btnModels\"; // global for current tab in right panel\n\n    //Width and height for histgrams\n    var barwidth = 1.3 * allR;\n    var barheight = 0.5 * allR;\n    var barPadding = 0.35;\n    var barnumber = 7;\n\n    var arc0 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(0).endAngle(3.2);\n\n    var arc1 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(0).endAngle(1);\n\n    var arc2 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(1.1).endAngle(2.2);\n\n    arc3 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(2.3).endAngle(3.3);\n\n    arc4 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(4.3).endAngle(5.3);\n\n    // From .csv\n    var dataset2 = [];\n    var lablArray = [];\n    var hold = [];\n    var allResults = [];\n    var subsetNodes = [];\n    var transformVar = \"\";\n    var selInteract = false;\n    var callHistory = []; // unique to the space. saves transform and subset calls.\n    var citetoggle = false;\n\n    var spaces = [];\n    var trans = []; //var list for each space contain variables in original data plus trans in that space\n\n    // collapsable user log\n    $('#collapseLog').on('shown.bs.collapse', function () {\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n    });\n\n    $('#collapseLog').on('hidden.bs.collapse', function () {\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    });\n\n    // text for the about box\n    // note that .textContent is the new way to write text to a div\n    $('#about div.panel-body').text('TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed.  In the Norse, their names were \"Thought\" and \"Memory\".  In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'); //This is the first public release of a new, interactive Web application to explore data, view descriptive statistics, and estimate statistical models.\";\n\n    // read DDI metadata with d3:\n    var metadataurl = \"\";\n    if (ddiurl) {\n        metadataurl = ddiurl;\n    } else if (fileid) {\n        // file id supplied; we're going to cook a standard dataverse\n        // metadata url, with the file id provided and the hostname\n        // supplied or configured:\n        metadataurl = dataverseurl + \"/api/meta/datafile/\" + fileid;\n    } else {\n        // neither a full ddi url, nor file id supplied\n        // use one of the sample data files distributed with the app in the 'data' directory\n        metadataurl = \"data/PUMS5small-ddi.xml\"; // This is California PUMS subset\n    }\n\n    // Reading pre-processed metadata:\n    // Pre-processed data:\n    var pURL = \"\";\n    if (dataurl) {\n        pURL = dataurl + \"&format=prep\";\n    } else {\n        // use one of the sample data files distributed with the app in the 'data' directory\n        pURL = \"data/preprocessPUMS5small.json\"; // California PUMS subset\n    }\n\n    var preprocess = {};\n\n    // this is the function and callback routine that loads all external data: metadata (DVN's ddi), preprocessed (for plotting distributions), and zeligmodels (produced by Zelig) and initiates the data download to the server\n    var url, p, v, _callback;\n    readPreprocess(url = pURL, p = preprocess, v = null, _callback = function callback() {\n        d3.xml(metadataurl, \"application/xml\", function (xml) {\n            var vars = xml.documentElement.getElementsByTagName(\"var\");\n            var temp = xml.documentElement.getElementsByTagName(\"fileName\");\n            zparams.zdata = temp[0].childNodes[0].nodeValue;\n\n            // clean the citation so that the POST is valid json\n            function cleanstring(s) {\n                s = s.replace(/\\&/g, \"and\");\n                s = s.replace(/\\;/g, \",\");\n                s = s.replace(/\\%/g, \"-\");\n                return s;\n            }\n\n            var cite = xml.documentElement.getElementsByTagName(\"biblCit\");\n            zparams.zdatacite = cite[0].childNodes[0].nodeValue;\n            zparams.zdatacite = cleanstring(zparams.zdatacite);\n\n            // dataset name trimmed to 12 chars\n            var dataname = zparams.zdata.replace(/\\.(.*)/, \"\"); // regular expression to drop any file extension\n            // Put dataset name, from meta-data, into top panel\n            d3.select(\"#dataName\").html(dataname);\n\n            $('#cite div.panel-body').text(zparams.zdatacite);\n\n            // Put dataset name, from meta-data, into page title\n            d3.select(\"title\").html(\"TwoRavens \" + dataname);\n\n            // temporary values for hold that correspond to histogram bins\n            hold = [.6, .2, .9, .8, .1, .3, .4];\n            var myvalues = [0, 0, 0, 0, 0];\n            for (var i = 0; i < vars.length; i++) {\n                valueKey[i] = vars[i].attributes.name.nodeValue;\n\n                if (vars[i].getElementsByTagName(\"labl\").length === 0) {\n                    lablArray[i] = \"no label\";\n                } else {\n                    lablArray[i] = vars[i].getElementsByTagName(\"labl\")[0].childNodes[0].nodeValue;\n                }\n\n                var datasetcount = d3.layout.histogram().bins(barnumber).frequency(false)(myvalues);\n\n                // this creates an object to be pushed to allNodes. this contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable, such as setx values (if the user has selected them) and pebble coordinates\n                var obj1 = {\n                    id: i,\n                    reflexive: false,\n                    \"name\": valueKey[i],\n                    \"labl\": lablArray[i],\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: hold,\n                    \"nodeCol\": colors(i),\n                    \"baseCol\": colors(i),\n                    \"strokeColor\": selVarColor,\n                    \"strokeWidth\": \"1\",\n                    \"subsetplot\": false,\n                    \"subsetrange\": [\"\", \"\"],\n                    \"setxplot\": false,\n                    \"setxvals\": [\"\", \"\"],\n                    \"grayout\": false\n                };\n                jQuery.extend(true, obj1, preprocess[valueKey[i]]);\n                allNodes.push(obj1);\n            };\n\n            // Reading the zelig models and populating the model list in the right panel.\n            d3.json(\"data/zelig5models.json\", function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                console.log(\"zelig models json: \", jsondata);\n                for (var key in jsondata.zelig5models) {\n                    if (jsondata.zelig5models.hasOwnProperty(key)) {\n                        mods[jsondata.zelig5models[key].name[0]] = jsondata.zelig5models[key].description[0];\n                    }\n                }\n\n                d3.json(\"data/zelig5choicemodels.json\", function (error, json) {\n                    if (error) return console.warn(error);\n                    var jsondata = json;\n                    console.log(\"zelig choice models json: \", jsondata);\n                    for (var key in jsondata.zelig5choicemodels) {\n                        if (jsondata.zelig5choicemodels.hasOwnProperty(key)) {\n                            mods[jsondata.zelig5choicemodels[key].name[0]] = jsondata.zelig5choicemodels[key].description[0];\n                        }\n                    }\n\n                    scaffolding(_callback = layout);\n                    dataDownload();\n                });\n            });\n        });\n    });\n};\n\n// scaffolding is called after all external data are guaranteed to have been read to completion. this populates the left panel with variable names, the right panel with model names, the transformation tool, an the associated mouseovers. its callback is layout(), which initializes the modeling space\nfunction scaffolding(callback) {\n    // establishing the transformation element\n    d3.select(\"#transformations\").append(\"input\").attr(\"id\", \"tInput\").attr(\"class\", \"form-control\").attr(\"type\", \"text\").attr(\"value\", \"Variable transformation\");\n\n    // variable dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transSel\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data([\"a\", \"b\"]) //set to variables in model space as they're added\n    .enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    // function dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transList\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data(transformList).enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    $('#tInput').click(function () {\n        var t = document.getElementById('transSel').style.display;\n        if (t !== \"none\") {\n            // if variable list is displayed when input is clicked...\n            $('#transSel').fadeOut(100);\n            return false;\n        }\n        var t1 = document.getElementById('transList').style.display;\n        if (t1 !== \"none\") {\n            // if function list is displayed when input is clicked...\n            $('#transList').fadeOut(100);\n            return false;\n        }\n\n        // highlight the text\n        $(this).select();\n\n        var pos = $('#tInput').offset();\n        pos.top += $('#tInput').width();\n        $('#transSel').fadeIn(100);\n        return false;\n    });\n\n    $('#tInput').keyup(function (event) {\n        var t = document.getElementById('transSel').style.display;\n        var t1 = document.getElementById('transList').style.display;\n\n        if (t !== \"none\") {\n            $('#transSel').fadeOut(100);\n        } else if (t1 !== \"none\") {\n            $('#transList').fadeOut(100);\n        }\n\n        if (event.keyCode == 13) {\n            // keyup on \"Enter\"\n            var n = $('#tInput').val();\n            var t = transParse(n = n);\n            if (t === null) {\n                return;\n            }\n            transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n        }\n    });\n\n    $('#transList li').click(function (event) {\n        var tvar = $('#tInput').val();\n\n        // if interact is selected, show variable list again\n        if ($(this).text() === \"interact(d,e)\") {\n            $('#tInput').val(tvar.concat('*'));\n            selInteract = true;\n            $(this).parent().fandeOut(100);\n            $('#transSel').fadeIn(100);\n            event.stopPropagation();\n            return;\n        }\n\n        var tfunc = $(this).text().replace(\"d\", \"_transvar0\");\n        var tcall = $(this).text().replace(\"d\", tvar);\n        $('#tInput').val(tcall);\n        $(this).parent().fadeOut(100);\n        event.stopPropagation();\n        transform(n = tvar, t = tfunc, typeTransform = false);\n    });\n\n    // populating the variable list in the left panel\n    d3.select(\"#tab1\").selectAll(\"p\").data(valueKey).enter().append(\"p\").attr(\"id\", function (d) {\n        return d.replace(/\\W/g, \"_\"); // replace non-alphanumerics for selection purposes\n    }) // perhapse ensure this id is unique by adding '_' to the front?\n    .text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        if (findNodeIndex(d) > 2) {\n            return varColor;\n        }\n        return hexToRgba(selVarColor);\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"right\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Summary Statistics\");\n\n    d3.select(\"#models\").style('height', 2000).style('overfill', 'scroll');\n\n    var modellist = Object.keys(mods);\n\n    d3.select(\"#models\").selectAll(\"p\").data(modellist).enter().append(\"p\").attr(\"id\", function (d) {\n        return \"_model_\".concat(d);\n    }).text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        return varColor;\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"top\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Model Description\").attr(\"data-content\", function (d) {\n        return mods[d];\n    });\n\n    if (typeof callback === \"function\") {\n        callback(); // this calls layout() because at this point all scaffolding is up and ready\n    }\n}\n\nfunction layout(v) {\n    var myValues = [];\n    nodes = [];\n    links = [];\n\n    if (v === \"add\" | v === \"move\") {\n        d3.select(\"#tab1\").selectAll(\"p\").style('background-color', varColor);\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) {\n                continue;\n            }\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, \"_\");\n            selectMe = \"#\".concat(selectMe);\n            d3.select(selectMe).style('background-color', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (allNodes.length > 2) {\n            nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            nodes = [allNodes[0], allNodes[1]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            nodes = [allNodes[0]];\n        } else {\n            alert(\"There are zero variables in the metadata.\");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and setx panels\n    populatePopover(); // pipes in the summary stats shown on mouseovers\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on('tick', tick);\n\n    // define arrow markers for graph links\n    svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').style('fill', '#000');\n\n    svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').style('fill', '#000');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');\n\n    // handles to link and node element groups\n    var path = svg.append('svg:g').selectAll('path'),\n        circle = svg.append('svg:g').selectAll('g');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        // draw directed edges with proper padding from node centers\n        path.attr('d', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? allR + 5 : allR,\n                targetPadding = d.right ? allR + 5 : allR,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n        });\n\n        circle.attr('transform', function (d) {\n            return 'translate(' + d.x + ',' + d.y + ')';\n        });\n    }\n\n    //  add listeners to leftpanel.left.  every time a variable is clicked, nodes updates and background color changes.  mouseover shows summary stats or model description.\n    d3.select(\"#tab1\").selectAll(\"p\").on(\"mouseover\", function (d) {\n        // REMOVED THIS TOOLTIP CODE AND MADE A BOOTSTRAP POPOVER COMPONENT\n        $(\"body div.popover\").addClass(\"variables\");\n        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n    }).on(\"click\", function varClick() {\n        if (allNodes[findNodeIndex(this.id)].grayout) {\n            return null;\n        }\n        d3.select(this).style('background-color', function (d) {\n            var myText = d3.select(this).text();\n            var myColor = d3.select(this).style('background-color');\n            var mySC = allNodes[findNodeIndex(myText)].strokeColor;\n\n            zparams.zvars = []; //empty the zvars array\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                // we are adding a var\n                if (nodes.length == 0) {\n                    nodes.push(findNode(myText));\n                    nodes[0].reflexive = true;\n                } else {\n                    nodes.push(findNode(myText));\n                }\n                return hexToRgba(selVarColor);\n            } else {\n                // dropping a variable\n                nodes.splice(findNode(myText)[\"index\"], 1);\n                spliceLinksForNode(findNode(myText));\n\n                if (mySC == dvColor) {\n                    var dvIndex = zparams.zdv.indexOf(myText);\n                    if (dvIndex > -1) {\n                        zparams.zdv.splice(dvIndex, 1);\n                    }\n                } else if (mySC == csColor) {\n                    var csIndex = zparams.zcross.indexOf(myText);\n                    if (csIndex > -1) {\n                        zparams.zcross.splice(csIndex, 1);\n                    }\n                } else if (mySC == timeColor) {\n                    var timeIndex = zparams.ztime.indexOf(myText);\n                    if (timeIndex > -1) {\n                        zparams.ztime.splice(timeIndex, 1);\n                    }\n                } else if (mySC == nomColor) {\n                    var nomIndex = zparams.znom.indexOf(myText);\n                    if (nomIndex > -1) {\n                        zparams.znom.splice(dvIndex, 1);\n                    }\n                }\n\n                nodeReset(allNodes[findNodeIndex(myText)]);\n                borderState();\n                legend();\n                return varColor;\n            }\n        });\n        panelPlots();\n        restart();\n    });\n\n    d3.select(\"#models\").selectAll(\"p\") // models tab\n    //  d3.select(\"#Display_content\")\n    .on(\"click\", function () {\n        var myColor = d3.select(this).style('background-color');\n        d3.select(\"#models\").selectAll(\"p\").style('background-color', varColor);\n        d3.select(this).style('background-color', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(selVarColor);\n            } else {\n                zparams.zmodel = \"\";\n                return varColor;\n            }\n        });\n        restart();\n    });\n\n    // update graph (called when needed)\n    function restart() {\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] === \"true\") {\n            force.gravity(0.1);\n            force.charge(-800);\n            force.linkStrength(1);\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are \"selected\". this is disabled for now\n        path.classed('selected', function (d) {\n            return;\n        }) //return d === selected_link; })\n        .style('marker-start', function (d) {\n            return d.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (d) {\n            return d.right ? 'url(#end-arrow)' : '';\n        });\n\n        // add new links\n        path.enter().append('svg:path').attr('class', 'link').classed('selected', function (d) {\n            return;\n        }) //return d === selected_link; })\n        .style('marker-start', function (d) {\n            return d.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (d) {\n            return d.right ? 'url(#end-arrow)' : '';\n        }).on('mousedown', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj1 = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj1 === JSON.stringify(links[j])) {\n                    links.splice(j, 1);\n                }\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (d) {\n            return d.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        //d3.rgb is the function adjusting the color here.\n        circle.selectAll('circle').classed('reflexive', function (d) {\n            return d.reflexive;\n        }).style('fill', function (d) {\n            return d3.rgb(d.nodeCol);\n        }).style('stroke', function (d) {\n            return d3.rgb(d.strokeColor);\n        }).style('stroke-width', function (d) {\n            return d.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append('svg:g').attr(\"id\", function (d) {\n            var myname = d.name + \"biggroup\";\n            return myname;\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype === \"continuous\") {\n                densityNode(d, obj = this);\n            } else if (d.plottype === \"bar\") {\n                barsNode(d, obj = this);\n            }\n        });\n\n        g.append(\"path\").attr(\"id\", function (d) {\n            return \"dvArc\".concat(d.id);\n        }).attr(\"d\", arc3).style(\"fill\", dvColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            d3.select(this).transition().attr(\"fill-opacity\", .3).delay(0).duration(100);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", .9).delay(0).duration(100);\n        }).on('mouseout', function (d) {\n            d3.select(this).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        }).on('click', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            restart();\n        });\n        g.append(\"text\").attr(\"id\", function (d) {\n            return \"dvText\".concat(d.id);\n        }).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", function (d) {\n            return \"#dvArc\".concat(d.id);\n        }).text(\"Dep Var\");\n\n        g.append(\"path\").attr(\"id\", function (d) {\n            return \"nomArc\".concat(d.id);\n        }).attr(\"d\", arc4).style(\"fill\", nomColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            d3.select(this).transition().attr(\"fill-opacity\", .3).delay(0).duration(100);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", .9).delay(0).duration(100);\n        }).on('mouseout', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            d3.select(this).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        }).on('click', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            setColors(d, nomColor);\n            legend(nomColor);\n            restart();\n        });\n        g.append(\"text\").attr(\"id\", function (d) {\n            return \"nomText\".concat(d.id);\n        }).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", function (d) {\n            return \"#nomArc\".concat(d.id);\n        }).text(\"Nominal\");\n\n        g.append('svg:circle').attr('class', 'node').attr('r', allR).style('pointer-events', 'inherit').style('fill', function (d) {\n            return d.nodeCol;\n        }).style('opacity', \"0.5\").style('stroke', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed('reflexive', function (d) {\n            return d.reflexive;\n        }).on('dblclick', function (d) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            summaryHold = true;\n        }).on('contextmenu', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation(); // stop right click from bubbling\n            rightClickLast = true;\n\n            mousedown_node = d;\n            if (mousedown_node === selected_node) selected_node = null;else selected_node = mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n            svg.on('mousemove', mousemove);\n            restart();\n        }).on('mouseup', function (d) {\n            d3.event.stopPropagation(); // stop mouseup from bubbling\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed('hidden', true).style('marker-end', '');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr('transform', '');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = 'right';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = 'left';\n            }\n\n            var link;\n            link = links.filter(function (l) {\n                return l.source === source && l.target === target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on('mousemove', null);\n\n            resetMouseVars();\n            restart();\n        });\n\n        // show node Names\n        g.append('svg:text').attr('x', 0).attr('y', 15).attr('class', 'id').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn't support text wrapping, use html instead\n        g.selectAll(\"circle.node\").on(\"mouseover\", function (d) {\n            tabLeft(\"tab3\");\n            varSummary(d);\n            document.getElementById('transformations').setAttribute(\"style\", \"display:block\");\n            var select = document.getElementById(\"transSel\");\n            select.selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            d3.select(\"#dvArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            if (d.defaultNumchar == \"numeric\") {\n                d3.select(\"#nomArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n                d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            }\n            d3.select(\"#csArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#csText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            d3.select(\"#timeArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#timeText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n        }).on(\"mouseout\", function (d) {\n            if (summaryHold === false) {\n                tabLeft(lefttab);\n            }\n\n            d3.select(\"#csArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#csText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#timeArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#timeText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        });\n\n        // populating transformation dropdown\n        var t = [];\n        for (var j = 0; j < nodes.length; j++) {\n            t.push(nodes[j].name);\n        }\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select(\"#transSel\").selectAll('li').remove();\n\n        d3.select(\"#transSel\").selectAll('li').data(t) //set to variables in model space as they're added\n        .enter().append(\"li\").text(function (d) {\n            return d;\n        });\n\n        $('#transSel li').click(function (event) {\n            // if 'interaction' is the selected function, don't show the function list again\n            if (selInteract === true) {\n                var n = $('#tInput').val().concat($(this).text());\n                $('#tInput').val(n);\n                event.stopPropagation();\n                var t = transParse(n = n);\n                if (t === null) {\n                    return;\n                }\n                $(this).parent().fadeOut(100);\n                transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                return;\n            }\n\n            $('#tInput').val($(this).text());\n            $(this).parent().fadeOut(100);\n            $('#transList').fadeIn(100);\n            event.stopPropagation();\n        });\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n    }\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed('active', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) {\n            return;\n        }\n        restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n\n        // update drag line\n        drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed('hidden', true).style('marker-end', '');\n        }\n        // because :active only works in WebKit?\n        svg.classed('active', false);\n\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr('id', function () {\n        return \"whitespace\".concat(myspace);\n    }).attr('height', height).on('mousedown', function () {\n        mousedown(this);\n    }).on('mouseup', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on('click', function () {\n        //NOTE: all clicks will bubble here unless event.stopPropagation()\n        $('#transList').fadeOut(100);\n        $('#transSel').fadeOut(100);\n    });\n\n    restart(); // this is the call the restart that initializes the force.layout()\n    fakeClick();\n} // end layout\n\n// returns id\nvar findNodeIndex = function findNodeIndex(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i][\"name\"] === nodeName) {\n            return allNodes[i][\"id\"];\n        }\n    };\n};\n\nvar nodeIndex = function nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i][\"name\"] === nodeName) {\n            return i;\n        }\n    }\n};\n\nvar findNode = function findNode(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i][\"name\"] === nodeName) return allNodes[i];\n    };\n};\n\n// function called by force button\nfunction forceSwitch() {\n    if (forcetoggle[0] === \"true\") {\n        forcetoggle = [\"false\"];\n    } else {\n        forcetoggle = [\"true\"];\n    }\n\n    if (forcetoggle[0] === \"false\") {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn active\");\n    } else {\n        document.getElementById('btnForce').setAttribute(\"class\", \"btn btn-default\");\n        fakeClick();\n    }\n}\n\nfunction spliceLinksForNode(node) {\n    var toSplice = links.filter(function (l) {\n        return l.source === node || l.target === node;\n    });\n    toSplice.map(function (l) {\n        links.splice(links.indexOf(l), 1);\n    });\n}\n\nfunction zPop() {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n\n    for (var j = 0; j < links.length; j++) {\n        //populate zedges array\n        var srctgt = [];\n        //correct the source target ordering for Zelig\n        if (links[j].left === false) {\n            srctgt = [links[j].source.name, links[j].target.name];\n        } else {\n            srctgt = [links[j].target.name, links[j].source.name];\n        }\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction estimate(btn) {\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    zPop();\n    // write links to file & run R CMD\n\n    // package the output as JSON\n    // add call history and package the zparams object as JSON\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    var urlcall = rappURL + \"zeligapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    zparams.allVars = valueKey.slice(10, 25); // this is because the URL is too long...\n    var jsonout = JSON.stringify(zparams);\n    //var selectorBase = rappURL+\"selectorapp?solaJSON=\";\n    var selectorurlcall = rappURL + \"selectorapp\"; //.concat(jsonout);\n\n    function estimateSuccess(btn, json) {\n        estimateLadda.stop(); // stop spinner\n        allResults.push(json);\n        console.log(allResults);\n        console.log(\"json in: \", json);\n\n        var myparent = document.getElementById(\"results\");\n        if (estimated == false) {\n            myparent.removeChild(document.getElementById(\"resultsHolder\"));\n        }\n\n        estimated = true;\n        d3.select(\"#results\").style(\"display\", \"block\");\n\n        d3.select(\"#resultsView\").style(\"display\", \"block\");\n\n        d3.select(\"#modelView\").style(\"display\", \"block\");\n\n        // programmatic click on Results button\n        $(\"#btnResults\").trigger(\"click\");\n\n        modelCount = modelCount + 1;\n        var model = \"Model\".concat(modelCount);\n\n        function modCol() {\n            d3.select(\"#modelView\").selectAll(\"p\").style('background-color', hexToRgba(varColor));\n        }\n        modCol();\n\n        d3.select(\"#modelView\").insert(\"p\", \":first-child\") // top stack for results\n        .attr(\"id\", model).text(model).style('background-color', hexToRgba(selVarColor)).on(\"click\", function () {\n            var a = this.style.backgroundColor.replace(/\\s*/g, \"\");\n            var b = hexToRgba(selVarColor).replace(/\\s*/g, \"\");\n            if (a.substr(0, 17) === b.substr(0, 17)) {\n                return; // escapes the function early if the displayed model is clicked\n            }\n            modCol();\n            d3.select(this).style('background-color', hexToRgba(selVarColor));\n            viz(this.id);\n        });\n\n        var rCall = [];\n        rCall[0] = json.call;\n        logArray.push(\"estimate: \".concat(rCall[0]));\n        showLog();\n\n        viz(model);\n    }\n\n    function estimateFail(btn) {\n        estimateLadda.stop(); // stop spinner\n        estimated = true;\n    }\n\n    function selectorSuccess(btn, json) {\n        d3.select(\"#ticker\").text(\"Suggested variables and percent improvement on RMSE: \" + json.vars);\n        console.log(\"selectorSuccess: \", json);\n    }\n\n    function selectorFail(btn) {\n        alert(\"Selector Fail\");\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, estimateSuccess, estimateFail, solajsonout);\n}\n\nfunction dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    var jsonout = JSON.stringify(zparams);\n    var btn = \"nobutton\";\n\n    var urlcall = rappURL + \"dataapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function downloadSuccess(btn, json) {\n        console.log(\"dataDownload json in: \", json);\n        zparams.zsessionid = json.sessionid[0];\n\n        // set the link URL\n        if (production) {\n            var logURL = rappURL + \"log_dir/log_\" + zparams.zsessionid + \".txt\";\n            document.getElementById(\"logID\").href = logURL;\n        } else {\n            var logURL = \"rook/log_\" + zparams.zsessionid + \".txt\";\n            document.getElementById(\"logID\").href = logURL;\n        }\n    }\n\n    function downloadFail(btn) {\n        console.log(\"Data have not been downloaded\");\n    }\n\n    makeCorsRequest(urlcall, btn, downloadSuccess, downloadFail, solajsonout);\n}\n\nfunction viz(m) {\n    var mym = +m.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    var myparent = document.getElementById(\"resultsView\");\n    removeKids(myparent);\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement(\"img\");\n        zfig.setAttribute(\"src\", json.images[i]);\n        zfig.setAttribute('width', 200);\n        zfig.setAttribute('height', 200);\n        document.getElementById(\"resultsView\").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \"colnames\") {\n            continue;\n        }\n\n        obj = json.sumInfo[key];\n        resultsArray.push(obj);\n        /* SO says this is important check, but I don't see how it helps here...\n         for (var prop in obj) {\n         // important check that this is objects own property\n         // not from prototype prop inherited\n         if(obj.hasOwnProperty(prop)){\n         alert(prop + \" = \" + obj[prop]);\n         }\n         }  */\n    }\n\n    var table = d3.select(\"#resultsView\").append(\"p\").append(\"table\");\n\n    var thead = table.append(\"thead\");\n    thead.append(\"tr\").selectAll(\"th\").data(json.sumInfo.colnames).enter().append(\"th\").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append(\"tbody\");\n    tbody.selectAll(\"tr\").data(resultsArray).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) {\n            return d;\n        }\n        return myNum.toPrecision(3);\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    }) // for no discernable reason\n    .on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n\n    d3.select(\"#resultsView\").append(\"p\").html(function () {\n        return \"<b>Formula: </b>\".concat(json.call[0]);\n    });\n}\n\n// this function parses the transformation input. variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = \"_transvar\".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n=\"wars+2\", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 !== null) {\n            out2.push(m2[0]);\n        }\n\n        var re = new RegExp(valueKey[i], \"g\");\n        var s = n.search(re);\n        if (s != -1) {\n            indexed.push({\n                from: s,\n                to: s + valueKey[i].length\n            });\n        }\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don't affect the splice\n    console.log(\"indexed \", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) {\n                continue;\n            }\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                console.log(i, \" is nested in \", j);\n                out2.splice(i, 1);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that'll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = \"_transvar\".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        console.log(\"new out \", out2);\n        return out2;\n    } else {\n        alert(\"No variable name found. Perhaps check your spelling?\");\n        return null;\n    }\n}\n\nfunction transform(n, t, typeTransform) {\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    if (!typeTransform) {\n        t = t.replace(\"+\", \"_plus_\"); // can't send the plus operator\n    }\n\n    console.log(n);\n    console.log(t);\n\n    var btn = document.getElementById('btnEstimate');\n\n    var myn = allNodes[findNodeIndex(n[0])];\n    if (typeof myn === \"undefined\") {\n        var myn = allNodes[findNodeIndex(n)];\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    console.log(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == \"nominal\" & typeof myn.plotvalues !== \"undefined\") {\n            myn.plottype = \"bar\";\n            barsNode(myn);\n            populatePopover();\n            panelPlots();\n            return;\n        } else if (myn.nature != \"nominal\" & typeof myn.plotx !== \"undefined\") {\n            myn.plottype = \"continuous\";\n            densityNode(myn);\n            populatePopover();\n            panelPlots();\n            return;\n        }\n    }\n\n    //package the output as JSON\n    var transformstuff = {\n        zdataurl: dataurl,\n        zvars: n,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes\n    };\n    var jsonout = JSON.stringify(transformstuff);\n    //var base = rappURL+\"transformapp?solaJSON=\"\n\n    var urlcall = rappURL + \"transformapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function transformSuccess(btn, json) {\n        estimateLadda.stop();\n        console.log(\"json in: \", json);\n\n        if (json.typeTransform[0]) {\n\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n\n                    if (allNodes[myIndex].plottype === \"continuous\") {\n                        densityNode(allNodes[myIndex]);\n                    } else if (allNodes[myIndex].plottype === \"bar\") {\n                        barsNode(allNodes[myIndex]);\n                    }\n                }\n\n                fakeClick();\n                populatePopover();\n                panelPlots();\n                console.log(allNodes[myIndex]);\n            });\n        } else {\n            callHistory.push({\n                func: \"transform\",\n                zvars: n,\n                transform: t\n            });\n\n            var subseted = false;\n            var rCall = [];\n            rCall[0] = json.call;\n            var newVar = rCall[0][0];\n            trans.push(newVar);\n\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    if (typeof myIndex !== \"undefined\") {\n                        alert(\"Invalid transformation: this variable name already exists.\");\n                        return;\n                    }\n                    // add transformed variable to the current space\n                    var i = allNodes.length;\n                    var obj1 = {\n                        id: i,\n                        reflexive: false,\n                        \"name\": key,\n                        \"labl\": \"transformlabel\",\n                        data: [5, 15, 20, 0, 5, 15, 20],\n                        count: [.6, .2, .9, .8, .1, .3, .4],\n                        \"nodeCol\": colors(i),\n                        \"baseCol\": colors(i),\n                        \"strokeColor\": selVarColor,\n                        \"strokeWidth\": \"1\",\n                        \"subsetplot\": false,\n                        \"subsetrange\": [\"\", \"\"],\n                        \"setxplot\": false,\n                        \"setxvals\": [\"\", \"\"],\n                        \"grayout\": false,\n                        \"defaultInterval\": jsondata[key][\"interval\"],\n                        \"defaultNumchar\": jsondata[key][\"numchar\"],\n                        \"defaultNature\": jsondata[key][\"nature\"],\n                        \"defaultBinary\": jsondata[key][\"binary\"]\n                    };\n\n                    jQuery.extend(true, obj1, jsondata[key]);\n                    allNodes.push(obj1);\n\n                    scaffoldingPush(rCall[0]);\n                    valueKey.push(newVar);\n                    nodes.push(allNodes[i]);\n                    fakeClick();\n                    panelPlots();\n\n                    if (allNodes[i].plottype === \"continuous\") {\n                        densityNode(allNodes[i]);\n                    } else if (allNodes[i].plottype === \"bar\") {\n                        barsNode(allNodes[i]);\n                    }\n                } //for\n\n            });\n\n            // update the log\n            logArray.push(\"transform: \".concat(rCall[0]));\n            showLog();\n        }\n    }\n\n    function transformFail(btn) {\n        alert(\"transform fail\");\n        estimateLadda.stop();\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, transformSuccess, transformFail, solajsonout);\n}\n\nfunction scaffoldingPush(v) {\n    // adding a variable to the variable list after a transformation\n    d3.select(\"#tab1\").data(v).append(\"p\").attr(\"id\", function () {\n        return v[0].replace(/\\W/g, \"_\");\n    }).text(v[0]).style('background-color', hexToRgba(selVarColor)).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"right\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Summary Statistics\").on(\"click\", function varClick() {\n        // we've added a new variable, so we need to add the listener\n        d3.select(this).style('background-color', function (d) {\n            var myText = d3.select(this).text();\n            var myColor = d3.select(this).style('background-color');\n            var mySC = allNodes[findNodeIndex(myText)].strokeColor;\n\n            zparams.zvars = []; //empty the zvars array\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                // we are adding a var\n                if (nodes.length == 0) {\n                    nodes.push(findNode(myText));\n                    nodes[0].reflexive = true;\n                } else {\n                    nodes.push(findNode(myText));\n                }\n                return hexToRgba(selVarColor);\n            } else {\n                // dropping a variable\n\n                nodes.splice(findNode(myText)[\"index\"], 1);\n                spliceLinksForNode(findNode(myText));\n\n                if (mySC == dvColor) {\n                    var dvIndex = zparams.zdv.indexOf(myText);\n                    if (dvIndex > -1) {\n                        zparams.zdv.splice(dvIndex, 1);\n                    }\n                } else if (mySC == csColor) {\n                    var csIndex = zparams.zcross.indexOf(myText);\n                    if (csIndex > -1) {\n                        zparams.zcross.splice(csIndex, 1);\n                    }\n                } else if (mySC == timeColor) {\n                    var timeIndex = zparams.ztime.indexOf(myText);\n                    if (timeIndex > -1) {\n                        zparams.ztime.splice(dvIndex, 1);\n                    }\n                } else if (mySC == nomColor) {\n                    var nomIndex = zparams.znom.indexOf(myText);\n                    if (nomIndex > -1) {\n                        zparams.znom.splice(dvIndex, 1);\n                    }\n                }\n\n                nodeReset(allNodes[findNodeIndex(myText)]);\n                borderState();\n                return varColor;\n            }\n        });\n        fakeClick();\n        panelPlots();\n    });\n    populatePopover(); // pipes in the summary stats\n\n    // drop down menu for tranformation toolbar\n    d3.select(\"#transSel\").data(v).append(\"option\").text(function (d) {\n        return d;\n    });\n}\n\n// below from http://www.html5rocks.com/en/tutorials/cors/ for cross-origin resource sharing\n// Create the XHR object.\nfunction createCORSRequest(method, url, callback) {\n    var xhr = new XMLHttpRequest();\n    if (\"withCredentials\" in xhr) {\n        // XHR for Chrome/Firefox/Opera/Safari.\n        xhr.open(method, url, true);\n    } else if (typeof XDomainRequest != \"undefined\") {\n        // XDomainRequest for IE.\n        xhr = new XDomainRequest();\n        xhr.open(method, url);\n    } else {\n        // CORS not supported.\n        xhr = null;\n    }\n    //    xhr.setRequestHeader('Content-Type', 'text/plain');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    return xhr;\n}\n\n// Make the actual CORS request.\nfunction makeCorsRequest(url, btn, callback, warningcallback, jsonstring) {\n    var xhr = createCORSRequest('POST', url);\n    if (!xhr) {\n        alert('CORS not supported');\n        return;\n    }\n    // Response handlers for asynchronous load\n    // onload or onreadystatechange?\n\n    xhr.onload = function () {\n        var text = xhr.responseText;\n        console.log(\"text \", text);\n\n        try {\n            var json = JSON.parse(text); // should wrap in try / catch\n            var names = Object.keys(json);\n        } catch (err) {\n            estimateLadda.stop();\n            selectLadda.stop();\n            console.log(err);\n            alert('Error: Could not parse incoming JSON.');\n        }\n\n        if (names[0] == \"warning\") {\n            warningcallback(btn);\n            alert(\"Warning: \" + json.warning);\n        } else {\n            callback(btn, json);\n        }\n    };\n    xhr.onerror = function () {\n        // note: xhr.readystate should be 4, and status should be 200.  a status of 0 occurs when the url becomes too large\n        if (xhr.status == 0) {\n            alert('There was an error making the request. xmlhttprequest status is 0.');\n        } else if (xhr.readyState != 4) {\n            alert('There was an error making the request. xmlhttprequest readystate is not 4.');\n        } else {\n            alert('Woops, there was an error making the request.');\n        }\n        console.log(xhr);\n        estimateLadda.stop();\n        selectLadda.stop();\n    };\n    xhr.send(jsonstring);\n}\n\nfunction legend(c) {\n    // this could be made smarter\n    if (zparams.ztime.length != 0 | zparams.zcross.length != 0 | zparams.zdv.length != 0 | zparams.znom.length != 0) {\n        document.getElementById(\"legend\").setAttribute(\"style\", \"display:block\");\n    } else {\n        document.getElementById(\"legend\").setAttribute(\"style\", \"display:none\");\n    }\n\n    if (zparams.ztime.length == 0) {\n        document.getElementById(\"timeButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"timeButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.zcross.length == 0) {\n        document.getElementById(\"csButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"csButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.zdv.length == 0) {\n        document.getElementById(\"dvButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"dvButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.znom.length == 0) {\n        document.getElementById(\"nomButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        document.getElementById(\"nomButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n\n    borderState();\n}\n\nfunction reset() {\n    location.reload();\n}\n\n// programmatically deselecting every selected variable...\nfunction erase() {\n    leftpanelMedium();\n    rightpanelMedium();\n    document.getElementById(\"legend\").setAttribute(\"style\", \"display:none\");\n\n    tabLeft('tab1');\n\n    jQuery.fn.d3Click = function () {\n        this.children().each(function (i, e) {\n            var mycol = d3.rgb(this.style.backgroundColor);\n            if (mycol.toString() === varColor.toString()) {\n                return;\n            }\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n            e.dispatchEvent(evt);\n        });\n    };\n    $(\"#tab1\").d3Click();\n}\n\nfunction deselect(d) {\n    console.log(d);\n}\n\n// http://www.tutorials2learn.com/tutorials/scripts/javascript/xml-parser-javascript.html\nfunction loadXMLDoc(XMLname) {\n    var xmlDoc;\n    if (window.XMLHttpRequest) {\n        xmlDoc = new window.XMLHttpRequest();\n        xmlDoc.open(\"GET\", XMLname, false);\n        xmlDoc.send(\"\");\n        return xmlDoc.responseXML;\n    }\n    // IE 5 and IE 6\n    else if (ActiveXObject(\"Microsoft.XMLDOM\")) {\n            xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = false;\n            xmlDoc.load(XMLname);\n            return xmlDoc;\n        }\n    alert(\"Error loading document!\");\n    return null;\n}\n\nfunction tabLeft(tab) {\n\n    if (tab != \"tab3\") {\n        lefttab = tab;\n    }\n    var tabi = tab.substring(3);\n\n    document.getElementById('tab1').style.display = 'none';\n    document.getElementById('tab2').style.display = 'none';\n    document.getElementById('tab3').style.display = 'none';\n\n    if (tab === \"tab1\") {\n        summaryHold = false;\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn active\");\n        document.getElementById(\"btnSelect\").style.display = 'none';\n\n        d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    } else if (tab === \"tab2\") {\n        summaryHold = false;\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn active\");\n\n        d3.select(\"#leftpanel\").attr(\"class\", function (d) {\n            if (this.getAttribute(\"class\") === \"sidepanel container clearfix expandpanel\") {\n                document.getElementById(\"btnSelect\").style.display = 'none';\n                return \"sidepanel container clearfix\";\n            } else {\n                document.getElementById(\"btnSelect\").style.display = 'block';\n                return \"sidepanel container clearfix expandpanel\";\n            }\n        });\n    } else {\n        document.getElementById('btnSubset').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnVariables').setAttribute(\"class\", \"btn btn-default\");\n\n        d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    }\n\n    document.getElementById(tab).style.display = 'block';\n}\n\nfunction tabRight(tabid) {\n\n    document.getElementById('models').style.display = 'none';\n    document.getElementById('setx').style.display = 'none';\n    document.getElementById('results').style.display = 'none';\n\n    if (tabid == \"btnModels\") {\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn active\");\n        document.getElementById('models').style.display = 'block';\n\n        d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    } else if (tabid == \"btnSetx\") {\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn active\");\n        document.getElementById('setx').style.display = 'block';\n\n        if (righttab == \"btnSetx\" | d3.select(\"#rightpanel\").attr(\"class\") == \"sidepanel container clearfix\") {\n            toggleR();\n        };\n    } else if (tabid == \"btnResults\") {\n        document.getElementById('btnModels').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnSetx').setAttribute(\"class\", \"btn btn-default\");\n        document.getElementById('btnResults').setAttribute(\"class\", \"btn active\");\n        document.getElementById('results').style.display = 'block';\n\n        if (estimated === false) {\n            d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n        } else if (righttab == \"btnResults\" | d3.select(\"#rightpanel\").attr(\"class\") == \"sidepanel container clearfix\") {\n            toggleR();\n        };\n    }\n\n    righttab = tabid; // a global that may be of use\n\n    function toggleR() {\n        d3.select(\"#rightpanel\").attr(\"class\", function (d) {\n            if (this.getAttribute(\"class\") === \"sidepanel container clearfix expandpanel\") {\n                return \"sidepanel container clearfix\";\n            } else {\n                return \"sidepanel container clearfix expandpanel\";\n            }\n        });\n    }\n}\n\nfunction varSummary(d) {\n\n    var rint = d3.format(\"r\");\n\n    var summarydata = [],\n        tmpDataset = [],\n        t1 = [\"Mean:\", \"Median:\", \"Most Freq:\", \"Occurrences:\", \"Median Freq:\", \"Occurrences:\", \"Least Freq:\", \"Occurrences:\", \"Stand.Dev:\", \"Minimum:\", \"Maximum:\", \"Invalid:\", \"Valid:\", \"Uniques:\", \"Herfindahl:\"],\n        t2 = [(+d.mean).toPrecision(4).toString(), (+d.median).toPrecision(4).toString(), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), (+d.sd).toPrecision(4).toString(), (+d.min).toPrecision(4).toString(), (+d.max).toPrecision(4).toString(), rint(d.invalid), rint(d.valid), rint(d.uniques), (+d.herfindahl).toPrecision(4).toString()],\n        i,\n        j;\n    if (priv) {\n        if (d.meanCI) {\n            t1 = [\"Mean:\", \"Median:\", \"Most Freq:\", \"Occurrences:\", \"Median Freq:\", \"Occurrences:\", \"Least Freq:\", \"Occurrences:\", \"Stand.Dev:\", \"Minimum:\", \"Maximum:\", \"Invalid:\", \"Valid:\", \"Uniques:\", \"Herfindahl:\"], t2 = [(+d.mean).toPrecision(2).toString() + \" (\" + (+d.meanCI.lowerBound).toPrecision(2).toString() + \" - \" + (+d.meanCI.upperBound).toPrecision(2).toString() + \")\", (+d.median).toPrecision(4).toString(), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), (+d.sd).toPrecision(4).toString(), (+d.min).toPrecision(4).toString(), (+d.max).toPrecision(4).toString(), rint(d.invalid), rint(d.valid), rint(d.uniques), (+d.herfindahl).toPrecision(4).toString()], i, j;\n        }\n    }\n\n    for (i = 0; i < t1.length; i++) {\n        if (t2[i].indexOf(\"NaN\") > -1 | t2[i] == \"NA\" | t2[i] == \"\") continue;\n        tmpDataset = [];\n        tmpDataset.push(t1[i]);\n        tmpDataset.push(t2[i]);\n        summarydata.push(tmpDataset);\n    };\n\n    //  console.log(summarydata);\n    d3.select(\"#tab3\") //tab when you mouseover a pebble\n    .select(\"p\").html(\"<center><b>\" + d.name + \"</b><br><i>\" + d.labl + \"</i></center>\").append(\"table\").selectAll(\"tr\").data(summarydata).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        return d;\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    }) // for no discernable reason\n    .on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n    //    .style(\"font-size\", \"12px\");\n\n\n    var plotsvg = d3.select(\"#tab3\").selectAll(\"svg\").remove();\n\n    if (typeof d.plottype === \"undefined\") {\n        // .properties is undefined for some vars\n        return;\n    } else if (d.plottype === \"continuous\") {\n        density(d, div = \"varSummary\", priv);\n    } else if (d.plottype === \"bar\") {\n        bars(d, div = \"varSummary\", priv);\n    } else {\n        var plotsvg = d3.select(\"#tab3\") // no graph to draw, but still need to remove previous graph\n        .selectAll(\"svg\").remove();\n    };\n}\n\nfunction populatePopover() {\n    d3.select(\"#tab1\").selectAll(\"p\").attr(\"data-content\", function (d) {\n        var onNode = findNodeIndex(d);\n        return popoverContent(allNodes[onNode]);\n    });\n}\n\nfunction popoverContent(d) {\n\n    var rint = d3.format(\"r\");\n\n    var outtext = \"\";\n\n    if (d.labl != \"\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Label</label><div class='col-sm-6'><p class='form-control-static'><i>\" + d.labl + \"</i></p></div></div>\";\n    }\n\n    if (d.mean != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\";\n        if (priv && d.meanCI) {\n            outtext += (+d.mean).toPrecision(2).toString() + \" (\" + (+d.meanCI.lowerBound).toPrecision(2).toString() + \" - \" + (+d.meanCI.upperBound).toPrecision(2).toString() + \")\";\n        } else {\n            outtext += (+d.mean).toPrecision(4).toString();\n        }\n        outtext += \"</p></div></div>\";\n    }\n\n    if (d.median != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.median).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.mode != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Most Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\";\n    }\n\n    if (d.freqmode != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqmode) + \"</p></div></div>\";\n    }\n\n    if (d.mid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Median Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mid + \"</p></div></div>\";\n    }\n\n    if (d.freqmid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqmid) + \"</p></div></div>\";\n    }\n    if (d.fewest != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Least Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.fewest + \"</p></div></div>\";\n    }\n\n    if (d.freqfewest != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqfewest) + \"</p></div></div>\";\n    }\n\n    if (d.sd != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.sd).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.max != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.max).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    if (d.min != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.min).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n    if (d.invalid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\";\n    }\n    if (d.valid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\";\n    }\n\n    if (d.uniques != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Uniques</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.uniques) + \"</p></div></div>\";\n    }\n    if (d.herfindahl != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Herfindahl</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.herfindahl).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n\n    return outtext;\n}\n\nfunction popupX(d) {\n\n    var tsf = d3.format(\".4r\");\n    var rint = d3.format(\"r\");\n\n    //Create the tooltip label\n    d3.select(\"#tooltip\").style(\"left\", tempX + \"px\").style(\"top\", tempY + \"px\").select(\"#tooltiptext\").html(\"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.mean) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.median) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Mode</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.sd) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.max) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.min) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\");\n}\n\nfunction panelPlots() {\n    // build arrays from nodes in main\n    var varArray = [];\n    var idArray = [];\n\n    for (var j = 0; j < nodes.length; j++) {\n        varArray.push(nodes[j].name.replace(/\\(|\\)/g, \"\"));\n        idArray.push(nodes[j].id);\n    }\n\n    //remove all plots, could be smarter here\n    d3.select(\"#setx\").selectAll(\"svg\").remove();\n    d3.select(\"#tab2\").selectAll(\"svg\").remove();\n\n    for (var i = 0; i < varArray.length; i++) {\n        allNodes[idArray[i]].setxplot = false;\n        allNodes[idArray[i]].subsetplot = false;\n        if (allNodes[idArray[i]].plottype === \"continuous\" & allNodes[idArray[i]].setxplot == false) {\n            allNodes[idArray[i]].setxplot = true;\n            console.log(priv);\n            density(allNodes[idArray[i]], div = \"setx\", priv);\n            allNodes[idArray[i]].subsetplot = true;\n            density(allNodes[idArray[i]], div = \"subset\", priv);\n        } else if (allNodes[idArray[i]].plottype === \"bar\" & allNodes[idArray[i]].setxplot == false) {\n            allNodes[idArray[i]].setxplot = true;\n            bars(allNodes[idArray[i]], div = \"setx\", priv);\n            allNodes[idArray[i]].subsetplot = true;\n            barsSubset(allNodes[idArray[i]]);\n        }\n    }\n\n    d3.select(\"#setx\").selectAll(\"svg\").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setx_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        var j = varArray.indexOf(myname);\n\n        if (j == -1) {\n            allNodes[nodeid].setxplot = false;\n            var temp = \"#\".concat(myname, \"_setx_\", nodeid);\n            d3.select(temp).remove();\n\n            allNodes[nodeid].subsetplot = false;\n            var temp = \"#\".concat(myname, \"_tab2_\", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n// easy functions to collapse panels to base\nfunction rightpanelMedium() {\n    d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\nfunction leftpanelMedium() {\n    d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\n// function to convert color codes\nfunction hexToRgba(hex) {\n    var h = hex.replace('#', '');\n\n    var bigint = parseInt(h, 16);\n    var r = bigint >> 16 & 255;\n    var g = bigint >> 8 & 255;\n    var b = bigint & 255;\n    var a = '0.5';\n\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n}\n\n// function takes a node and a color and updates zparams\nfunction setColors(n, c) {\n\n    if (n.strokeWidth == '1') {\n        // adding time, cs, dv, nom to a node with no stroke\n        n.strokeWidth = '4';\n        n.strokeColor = c;\n        n.nodeCol = taggedColor;\n        if (dvColor == c) {\n            // check if array, if not, make it an array\n            //  console.log(Object.prototype.toString.call(zparams.zdv));\n            zparams.zdv = Object.prototype.toString.call(zparams.zdv) == \"[object Array]\" ? zparams.zdv : [];\n            zparams.zdv.push(n.name);\n        } else if (csColor == c) {\n            zparams.zcross = Object.prototype.toString.call(zparams.zcross) == \"[object Array]\" ? zparams.zcross : [];\n            zparams.zcross.push(n.name);\n        } else if (timeColor == c) {\n            zparams.ztime = Object.prototype.toString.call(zparams.ztime) == \"[object Array]\" ? zparams.ztime : [];\n            zparams.ztime.push(n.name);\n        } else if (nomColor == c) {\n            zparams.znom = Object.prototype.toString.call(zparams.znom) == \"[object Array]\" ? zparams.znom : [];\n            zparams.znom.push(n.name);\n            allNodes[findNodeIndex(n.name)].nature = \"nominal\";\n            transform(n.name, t = null, typeTransform = true);\n        }\n\n        d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(c));\n    } else if (n.strokeWidth == '4') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = '1';\n            n.strokeColor = selVarColor;\n            n.nodeCol = colors(n.id);\n            d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(selVarColor));\n\n            if (dvColor == c) {\n                var dvIndex = zparams.zdv.indexOf(n.name);\n                if (dvIndex > -1) {\n                    zparams.zdv.splice(dvIndex, 1);\n                }\n            } else if (csColor == c) {\n                var csIndex = zparams.zcross.indexOf(n.name);\n                if (csIndex > -1) {\n                    zparams.zcross.splice(csIndex, 1);\n                }\n            } else if (timeColor == c) {\n                var timeIndex = zparams.ztime.indexOf(n.name);\n                if (timeIndex > -1) {\n                    zparams.ztime.splice(timeIndex, 1);\n                }\n            } else if (nomColor == c) {\n                var nomIndex = zparams.znom.indexOf(n.name);\n                if (nomIndex > -1) {\n                    zparams.znom.splice(nomIndex, 1);\n                    allNodes[findNodeIndex(n.name)].nature = allNodes[findNodeIndex(n.name)].defaultNature;\n                    transform(n.name, t = null, typeTransform = true);\n                }\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            if (dvColor == n.strokeColor) {\n                var dvIndex = zparams.zdv.indexOf(n.name);\n                if (dvIndex > -1) {\n                    zparams.zdv.splice(dvIndex, 1);\n                }\n            } else if (csColor == n.strokeColor) {\n                var csIndex = zparams.zcross.indexOf(n.name);\n                if (csIndex > -1) {\n                    zparams.zcross.splice(csIndex, 1);\n                }\n            } else if (timeColor == n.strokeColor) {\n                var timeIndex = zparams.ztime.indexOf(n.name);\n                if (timeIndex > -1) {\n                    zparams.ztime.splice(timeIndex, 1);\n                }\n            } else if (nomColor == n.strokeColor) {\n                var nomIndex = zparams.znom.indexOf(n.name);\n                if (nomIndex > -1) {\n                    zparams.znom.splice(nomIndex, 1);\n                    allNodes[findNodeIndex(n.name)].nature = allNodes[findNodeIndex(n.name)].defaultNature;\n                    transform(n.name, t = null, typeTransform = true);\n                }\n            }\n            n.strokeColor = c;\n            d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(c));\n\n            if (dvColor == c) {\n                zparams.zdv.push(n.name);\n            } else if (csColor == c) {\n                zparams.zcross.push(n.name);\n            } else if (timeColor == c) {\n                zparams.ztime.push(n.name);\n            } else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                allNodes[findNodeIndex(n.name)].nature = \"nominal\";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\nfunction borderState() {\n    if (zparams.zdv.length > 0) {\n        $('#dvButton .rectColor svg circle').attr('stroke', dvColor);\n    } else {\n        $('#dvButton').css('border-color', '#ccc');\n    }\n    if (zparams.zcross.length > 0) {\n        $('#csButton .rectColor svg circle').attr('stroke', csColor);\n    } else {\n        $('#csButton').css('border-color', '#ccc');\n    }\n    if (zparams.ztime.length > 0) {\n        $('#timeButton .rectColor svg circle').attr('stroke', timeColor);\n    } else {\n        $('#timeButton').css('border-color', '#ccc');\n    }\n    if (zparams.znom.length > 0) {\n        $('#nomButton .rectColor svg circle').attr('stroke', nomColor);\n    } else {\n        $('#nomButton').css('border-color', '#ccc');\n    }\n}\n\n// small appearance resets, but perhaps this will become a hard reset back to all original allNode values?\nfunction nodeReset(n) {\n    n.strokeColor = selVarColor;\n    n.strokeWidth = \"1\";\n    n.nodeCol = n.baseCol;\n}\n\nfunction subsetSelect(btn) {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    zparams.zvars = [];\n    zparams.zplot = [];\n\n    var subsetEmpty = true;\n\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != \"\") {\n                zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            }\n            if (zparams.zsubset[j][1] != \"\") {\n                zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n            }\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != \"\") {\n            subsetEmpty = false;\n        } //only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert(\"Warning: No new subset selected.\");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    var subsetstuff = {\n        zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes\n    };\n\n    var jsonout = JSON.stringify(subsetstuff);\n    var urlcall = rappURL + \"subsetapp\";\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function subsetSelectSuccess(btn, json) {\n        selectLadda.stop(); // stop motion\n        $(\"#btnVariables\").trigger(\"click\"); // programmatic clicks\n        $(\"#btnModels\").trigger(\"click\");\n\n        var grayOuts = [];\n\n        var rCall = [];\n        rCall[0] = json.call;\n\n        // store contents of the pre-subset space\n        zPop();\n        var myNodes = jQuery.extend(true, [], allNodes);\n        var myParams = jQuery.extend(true, {}, zparams);\n        var myTrans = jQuery.extend(true, [], trans);\n        var myForce = jQuery.extend(true, [], forcetoggle);\n        var myPreprocess = jQuery.extend(true, {}, preprocess);\n        var myLog = jQuery.extend(true, [], logArray);\n        var myHistory = jQuery.extend(true, [], callHistory);\n\n        spaces[myspace] = {\n            \"allNodes\": myNodes,\n            \"zparams\": myParams,\n            \"trans\": myTrans,\n            \"force\": myForce,\n            \"preprocess\": myPreprocess,\n            \"logArray\": myLog,\n            \"callHistory\": myHistory\n        };\n\n        // remove pre-subset svg\n        var selectMe = \"#m\".concat(myspace);\n        d3.select(selectMe).attr('class', 'item');\n        selectMe = \"#whitespace\".concat(myspace);\n        d3.select(selectMe).remove();\n\n        myspace = spaces.length;\n        callHistory.push({\n            func: \"subset\",\n            zvars: jQuery.extend(true, [], zparams.zvars),\n            zsubset: jQuery.extend(true, [], zparams.zsubset),\n            zplot: jQuery.extend(true, [], zparams.zplot)\n        });\n\n        // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n        function varOut(v) {\n            // if in nodes, remove\n            // gray out in left panel\n            // make unclickable in left panel\n            for (var i = 0; i < v.length; i++) {\n                var selectMe = v[i].replace(/\\W/g, \"_\");\n                document.getElementById(selectMe).style.color = hexToRgba(grayColor);\n                selectMe = \"p#\".concat(selectMe);\n                d3.select(selectMe).on(\"click\", null);\n            }\n        }\n\n        logArray.push(\"subset: \".concat(rCall[0]));\n        showLog();\n        reWriteLog();\n\n        d3.select(\"#innercarousel\").append('div').attr('class', 'item active').attr('id', function () {\n            return \"m\".concat(myspace.toString());\n        }).append('svg').attr('id', 'whitespace');\n        svg = d3.select(\"#whitespace\");\n\n        d3.json(json.url, function (error, json) {\n            if (error) return console.warn(error);\n            var jsondata = json;\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n\n                allNodes[myIndex].plotx = undefined;\n                allNodes[myIndex].ploty = undefined;\n                allNodes[myIndex].plotvalues = undefined;\n                allNodes[myIndex].plottype = \"\";\n\n                jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n\n                allNodes[myIndex].subsetplot = false;\n                allNodes[myIndex].subsetrange = [\"\", \"\"];\n                allNodes[myIndex].setxplot = false;\n                allNodes[myIndex].setxvals = [\"\", \"\"];\n\n                if (allNodes[myIndex].valid == 0) {\n                    grayOuts.push(allNodes[myIndex].name);\n                    allNodes[myIndex].grayout = true;\n                }\n            }\n\n            rePlot();\n            populatePopover();\n            layout(v = \"add\");\n        });\n\n        varOut(grayOuts);\n    }\n\n    function subsetSelectFail(btn) {\n        selectLadda.stop(); //stop motion\n    }\n\n    selectLadda.start(); //start button motion\n    makeCorsRequest(urlcall, btn, subsetSelectSuccess, subsetSelectFail, solajsonout);\n}\n\nfunction readPreprocess(url, p, v, callback) {\n    console.log(url);\n    d3.json(url, function (error, json) {\n        if (error) return console.warn(error);\n        var jsondata = json;\n\n        console.log(\"inside readPreprocess function\");\n        console.log(jsondata);\n        console.log(jsondata[\"variables\"]);\n\n        if (jsondata.dataset.priv) {\n            priv = jsondata[\"dataset\"][\"priv\"];\n        };\n\n        //copying the object\n        for (var key in jsondata[\"variables\"]) {\n            p[key] = jsondata[\"variables\"][key];\n        }\n\n        if (typeof callback === \"function\") {\n            callback();\n        }\n    });\n}\n\nfunction about() {\n    $('#about').show();\n}\n\nfunction closeabout() {\n    $('#about').hide();\n}\n\nfunction opencite() {\n    $('#cite').show();\n}\n\nfunction closecite(toggle) {\n    if (toggle == false) {\n        $('#cite').hide();\n    }\n}\n\nfunction clickcite(toggle) {\n    if (toggle == false) {\n        $('#cite').show();\n        return true;\n    } else {\n        $('#cite').hide();\n        return false;\n    }\n}\n\n// function to remove all the children svgs inside subset and setx divs\nfunction rePlot() {\n    d3.select(\"#tab2\").selectAll(\"svg\").remove();\n\n    d3.select(\"#setx\").selectAll(\"svg\").remove();\n\n    // make this smarter\n    for (var i = 0; i < allNodes.length; i++) {\n        allNodes[i].setxplot = false;\n        allNodes[i].subsetplot = false;\n    }\n}\n\nfunction showLog() {\n    if (logArray.length > 0) {\n        document.getElementById('logdiv').setAttribute(\"style\", \"display:block\");\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n    } else {\n        document.getElementById('logdiv').setAttribute(\"style\", \"display:none\");\n    }\n}\n\nfunction reWriteLog() {\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n        return d;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nfunction fakeClick() {\n    var myws = \"#whitespace\".concat(myspace);\n    // d3 and programmatic events don't mesh well, here's a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n            e.dispatchEvent(evt);\n        });\n    };\n    $(myws).d3Click();\n\n    d3.select(myws).classed('active', false); // remove active class\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwX2RkaS5qcz9mYzU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vLy8vLy8vLy9cbi8vIEdsb2JhbHNcblxuLy8gaG9zdG5hbWUgZGVmYXVsdCAtIHRoZSBhcHAgd2lsbCB1c2UgaXQgdG8gb2J0YWluIHRoZSB2YXJpYWJsZSBtZXRhZGF0YVxuLy8gKGRkaSkgYW5kIHByZS1wcm9jZXNzZWQgZGF0YSBpbmZvIGlmIHRoZSBmaWxlIGlkIGlzIHN1cHBsaWVkIGFzIGFuIFxuLy8gYXJndW1lbnQgKGZvciBleC4sIGd1aS5odG1sP2RmSWQ9MTcpLCBidXQgaG9zdG5hbWUgaXNuJ3QuIFxuLy8gRWRpdCBpdCB0byBzdWl0IHlvdXIgaW5zdGFsbGF0aW9uLiBcbi8vIChOT1RFIHRoYXQgaWYgdGhlIGZpbGUgaWQgaXNuJ3Qgc3VwcGxpZWQsIHRoZSBhcHAgd2lsbCBkZWZhdWx0IHRvIHRoZSBcbi8vIGxvY2FsIGZpbGVzIHNwZWNpZmllZCBiZWxvdyEpXG4vLyBORVc6IGl0IGlzIGFsc28gcG9zc2libGUgbm93IHRvIHN1cHBseSBjb21wbGV0ZSB1cmxzIGZvciB0aGUgZGRpIGFuZCBcbi8vIHRoZSB0YWItZGVsaW1pdGVkIGRhdGEgZmlsZTsgdGhlIHBhcmFtZXRlcnMgYXJlIGRkaXVybCBhbmQgZGF0YXVybC4gXG4vLyBUaGVzZSBuZXcgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIElmIHRoZXkgYXJlIG5vdCBzdXBwbGllZCwgdGhlIGFwcFxuLy8gd2lsbCBnbyB0aGUgb2xkIHJvdXRlIC0gd2lsbCB0cnkgdG8gY29vayBzdGFuZGFyZCBkYXRhdmVyc2UgdXJscyBcbi8vIGZvciBib3RoIHRoZSBkYXRhIGFuZCBtZXRhZGF0YSwgaWYgdGhlIGZpbGUgaWQgaXMgc3VwcGxpZWQ7IG9yIHRoZSBcbi8vIGxvY2FsIGZpbGVzIGlmIG5vdGhpbmcgaXMgc3VwcGxpZWQuIFxuLy8gLS0gTC5BLlxuXG52YXIgdmFyQ29sb3IgPSAnI2YwZjhmZic7IC8vZDMucmdiKFwiYWxpY2VibHVlXCIpO1xudmFyIHNlbFZhckNvbG9yID0gJyNmYTgwNzInOyAvL2QzLnJnYihcInNhbG1vblwiKTtcbnZhciBkdkNvbG9yID0gJyMyOGE0YzknO1xudmFyIG5vbUNvbG9yID0gJyNmZjY2MDAnO1xuXG4vLyB0cmFuc2Zvcm1hdGlvbiB0b29sYmFyIG9wdGlvbnNcbnZhciB0cmFuc2Zvcm1MaXN0ID0gW1wibG9nKGQpXCIsIFwiZXhwKGQpXCIsIFwiZF4yXCIsIFwic3FydChkKVwiLCBcImludGVyYWN0KGQsZSlcIl07XG5cbi8vIFJhZGl1cyBvZiBjaXJjbGVcbnZhciBhbGxSID0gNDA7XG5cbi8vIHNwYWNlIGluZGV4XG52YXIgbXlzcGFjZSA9IDA7XG5cbnZhciBmb3JjZXRvZ2dsZSA9IFtcInRydWVcIl07XG52YXIgcHJpdiA9IGZhbHNlO1xuXG52YXIgenBhcmFtcyA9IHtcblx0emRhdGE6IFtdLFxuXHR6ZWRnZXM6IFtdLFxuXHR6dGltZTogW10sXG5cdHpub206IFtdLFxuXHR6Y3Jvc3M6IFtdLFxuXHR6bW9kZWw6IFwiXCIsXG5cdHp2YXJzOiBbXSxcblx0emR2OiBbXSxcblx0emRhdGF1cmw6IFwiXCIsXG5cdHpzdWJzZXQ6IFtdLFxuXHR6c2V0eDogW10sXG5cdHptb2RlbGNvdW50OiAwLFxuXHR6cGxvdDogW10sXG5cdHpzZXNzaW9uaWQ6IFwiXCIsXG5cdHpkYXRhY2l0ZTogXCJcIlxufTtcblxudmFyIG1vZGVsQ291bnQgPSAwO1xudmFyIHN1bW1hcnlIb2xkID0gZmFsc2U7XG5cbnZhciB2YWx1ZUtleSA9IFtdO1xudmFyIGFsbE5vZGVzID0gW107XG52YXIgbm9kZXMgPSBbXTtcbnZhciBsaW5rcyA9IFtdO1xudmFyIG1vZHMgPSB7fTtcblxudmFyIHN2Zywgd2lkdGgsIGhlaWdodCwgZGl2LCBvYmosIHJhcHBVUkw7XG52YXIgYXJjMywgYXJjNDtcblxudmFyIGRhdGF1cmw7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1haW4oZmlsZWlkLCBob3N0bmFtZSwgZGRpdXJsLCBkYXRhdXJsKSB7XG5cdGRhdGF1cmwgPSBkYXRhdXJsO1xuICAgIHZhciBwcm9kdWN0aW9uID0gZmFsc2U7XG5cbiAgICBpZiAocHJvZHVjdGlvbiAmJiBmaWxlaWQgPT0gXCJcIikge1xuICAgICAgICBhbGVydChcIkVycm9yOiBObyBmaWxlaWQgaGFzIGJlZW4gcHJvdmlkZWQuXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvcjogTm8gZmlsZWlkIGhhcyBiZWVuIHByb3ZpZGVkLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YXZlcnNldXJsID0gXCJcIjtcbiAgICBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgZGF0YXZlcnNldXJsID0gXCJodHRwczovL1wiICsgaG9zdG5hbWU7XG4gICAgfSBlbHNlIGlmIChwcm9kdWN0aW9uKSB7XG4gICAgICAgIGRhdGF2ZXJzZXVybCA9IFwiJVBST0RVQ1RJT05fREFUQVZFUlNFX1VSTCVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhdmVyc2V1cmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MFwiO1xuICAgIH1cblxuICAgIGlmIChmaWxlaWQgJiYgIWRhdGF1cmwpIHtcbiAgICAgICAgLy8gZmlsZSBpZCBzdXBwbGllZDsgd2UgYXJlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAgICAgLy8gYSBkYXRhdmVyc2UgYW5kIGNvb2sgYSBzdGFuZGFyZCBkYXRhdmVyc2UgZGF0YSBhY2Nlc3MgdXJsLFxuICAgICAgICAvLyB3aXRoIHRoZSBmaWxlaWQgc3VwcGxpZWQgYW5kIHRoZSBob3N0bmFtZSB3ZSBoYXZlXG4gICAgICAgIC8vIGVpdGhlciBzdXBwbGllZCBvciBjb25maWd1cmVkOlxuICAgICAgICBkYXRhdXJsID0gZGF0YXZlcnNldXJsICsgXCIvYXBpL2FjY2Vzcy9kYXRhZmlsZS9cIiArIGZpbGVpZDtcbiAgICAgICAgZGF0YXVybCA9IGRhdGF1cmwgKyBcIj9rZXk9XCIgKyBhcGlrZXk7XG4gICAgICAgIC8vIChpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHN1cHBseSBkYXRhdXJsIHRvIHRoZSBzY3JpcHQgZGlyZWN0bHksIFxuICAgICAgICAvLyBhcyBhbiBhcmd1bWVudCAtLSBMLkEuKVxuICAgIH1cblxuICAgIC8vIGJhc2UgVVJMIGZvciB0aGUgUiBhcHBzOlxuICAgIGlmICghcHJvZHVjdGlvbikge1xuICAgICAgICByYXBwVVJMID0gXCJodHRwOi8vMC4wLjAuMDo4MDAwL2N1c3RvbS9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYXBwVVJMID0gXCJodHRwczovL2JldGEuZGF0YXZlcnNlLm9yZy9jdXN0b20vXCI7XG4gICAgfVxuXG4gICAgc3ZnID0gZDMuc2VsZWN0KFwiI21haW4ubGVmdCBkaXYuY2Fyb3VzZWwtaW5uZXJcIikuYXR0cignaWQnLCAnaW5uZXJjYXJvdXNlbCcpXG4gICAgICAgIC5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2l0ZW0gYWN0aXZlJykuYXR0cignaWQnLCAnbTAnKS5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2lkJywgJ3doaXRlc3BhY2UnKTtcblxuICAgIHZhciBsb2dBcnJheSA9IFtdO1xuXG4gICAgdmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChcIiNtYWluLmxlZnRcIikuc3R5bGUoXCJ3aWR0aFwiKVxuICAgIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCAodGVtcFdpZHRoLmxlbmd0aCAtIDIpKTtcbiAgICBoZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCkgLSAxMjA7IC8vIEhhcmQgY29kaW5nIGZvciBoZWFkZXIgYW5kIGZvb3RlciBhbmQgYm90dG9tIG1hcmdpbi5cblxuICAgIHZhciBlc3RpbWF0ZWQgPSBmYWxzZTtcbiAgICB2YXIgZXN0aW1hdGVMYWRkYSA9IExhZGRhLmNyZWF0ZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ0bkVzdGltYXRlXCIpKTtcbiAgICB2YXIgc2VsZWN0TGFkZGEgPSBMYWRkYS5jcmVhdGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikpO1xuICAgIHZhciByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xuXG4gICAgLy8gdGhpcyBpcyB0aGUgaW5pdGlhbCBjb2xvciBzY2FsZSB0aGF0IGlzIHVzZWQgdG8gZXN0YWJsaXNoIHRoZSBpbml0aWFsIGNvbG9ycyBvZiB0aGUgbm9kZXMuICBhbGxOb2Rlcy5wdXNoKCkgYmVsb3cgZXN0YWJsaXNoZXMgYSBmaWVsZCBmb3IgdGhlIG1hc3RlciBub2RlIGFycmF5IGFsbE5vZGVzIGNhbGxlZCBcIm5vZGVDb2xcIiBhbmQgYXNzaWducyBhIGNvbG9yIGZyb20gdGhpcyBzY2FsZSB0byB0aGF0IGZpZWxkLiAgZXZlcnl0aGluZyB0aGVyZSBhZnRlciBzaG91bGQgcmVmZXIgdG8gdGhlIG5vZGVDb2wgYW5kIG5vdCB0aGUgY29sb3Igc2NhbGUsIHRoaXMgZW5hYmxlcyB1cyB0byB1cGRhdGUgY29sb3JzIGFuZCBwYXNzIHRoZSB2YXJpYWJsZSB0eXBlIHRvIFIgYmFzZWQgb24gaXRzIGNvbG9yaW5nXG4gICAgdmFyIGNvbG9ycyA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKTtcblxuICAgIHZhciBjb2xvclRpbWUgPSBmYWxzZTtcbiAgICB2YXIgdGltZUNvbG9yID0gJyMyZDZjYTInO1xuXG4gICAgdmFyIGNvbG9yQ1MgPSBmYWxzZTtcbiAgICB2YXIgY3NDb2xvciA9ICcjNDE5NjQxJztcblxuICAgIHZhciBkZXBWYXIgPSBmYWxzZTtcblxuICAgIHZhciBzdWJzZXRkaXYgPSBmYWxzZTtcbiAgICB2YXIgc2V0eGRpdiA9IGZhbHNlO1xuXG4gICAgdmFyIHRhZ2dlZENvbG9yID0gJyNmNWY1ZjUnOyAvL2QzLnJnYihcIndoaXRlc21va2VcIik7XG4gICAgdmFyIGdyYXlDb2xvciA9ICcjYzBjMGMwJztcblxuICAgIHZhciBsZWZ0dGFiID0gXCJ0YWIxXCI7IC8vZ2xvYmFsIGZvciBjdXJyZW50IHRhYiBpbiBsZWZ0IHBhbmVsXG4gICAgdmFyIHJpZ2h0dGFiID0gXCJidG5Nb2RlbHNcIjsgLy8gZ2xvYmFsIGZvciBjdXJyZW50IHRhYiBpbiByaWdodCBwYW5lbFxuXG4gICAgLy9XaWR0aCBhbmQgaGVpZ2h0IGZvciBoaXN0Z3JhbXNcbiAgICB2YXIgYmFyd2lkdGggPSAxLjMgKiBhbGxSO1xuICAgIHZhciBiYXJoZWlnaHQgPSAwLjUgKiBhbGxSO1xuICAgIHZhciBiYXJQYWRkaW5nID0gMC4zNTtcbiAgICB2YXIgYmFybnVtYmVyID0gNztcblxuICAgIHZhciBhcmMwID0gZDMuc3ZnLmFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cyhhbGxSICsgNSlcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAyMClcbiAgICAgICAgLnN0YXJ0QW5nbGUoMClcbiAgICAgICAgLmVuZEFuZ2xlKDMuMik7XG5cbiAgICB2YXIgYXJjMSA9IGQzLnN2Zy5hcmMoKVxuICAgICAgICAuaW5uZXJSYWRpdXMoYWxsUiArIDUpXG4gICAgICAgIC5vdXRlclJhZGl1cyhhbGxSICsgMjApXG4gICAgICAgIC5zdGFydEFuZ2xlKDApXG4gICAgICAgIC5lbmRBbmdsZSgxKTtcblxuICAgIHZhciBhcmMyID0gZDMuc3ZnLmFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cyhhbGxSICsgNSlcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAyMClcbiAgICAgICAgLnN0YXJ0QW5nbGUoMS4xKVxuICAgICAgICAuZW5kQW5nbGUoMi4yKTtcblxuICAgIGFyYzMgPSBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyA1KVxuICAgICAgICAub3V0ZXJSYWRpdXMoYWxsUiArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSgyLjMpXG4gICAgICAgIC5lbmRBbmdsZSgzLjMpO1xuXG4gICAgYXJjNCA9IGQzLnN2Zy5hcmMoKVxuICAgICAgICAuaW5uZXJSYWRpdXMoYWxsUiArIDUpXG4gICAgICAgIC5vdXRlclJhZGl1cyhhbGxSICsgMjApXG4gICAgICAgIC5zdGFydEFuZ2xlKDQuMylcbiAgICAgICAgLmVuZEFuZ2xlKDUuMyk7XG5cbiAgICAvLyBGcm9tIC5jc3ZcbiAgICB2YXIgZGF0YXNldDIgPSBbXTtcbiAgICB2YXIgbGFibEFycmF5ID0gW107XG4gICAgdmFyIGhvbGQgPSBbXTtcbiAgICB2YXIgYWxsUmVzdWx0cyA9IFtdO1xuICAgIHZhciBzdWJzZXROb2RlcyA9IFtdO1xuICAgIHZhciB0cmFuc2Zvcm1WYXIgPSBcIlwiO1xuICAgIHZhciBzZWxJbnRlcmFjdCA9IGZhbHNlO1xuICAgIHZhciBjYWxsSGlzdG9yeSA9IFtdOyAvLyB1bmlxdWUgdG8gdGhlIHNwYWNlLiBzYXZlcyB0cmFuc2Zvcm0gYW5kIHN1YnNldCBjYWxscy5cbiAgICB2YXIgY2l0ZXRvZ2dsZSA9IGZhbHNlO1xuXG4gICAgdmFyIHNwYWNlcyA9IFtdO1xuICAgIHZhciB0cmFucyA9IFtdOyAvL3ZhciBsaXN0IGZvciBlYWNoIHNwYWNlIGNvbnRhaW4gdmFyaWFibGVzIGluIG9yaWdpbmFsIGRhdGEgcGx1cyB0cmFucyBpbiB0aGF0IHNwYWNlXG5cbiAgICAvLyBjb2xsYXBzYWJsZSB1c2VyIGxvZ1xuICAgICQoJyNjb2xsYXBzZUxvZycpLm9uKCdzaG93bi5icy5jb2xsYXBzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgLmRhdGEobG9nQXJyYXkpXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgJCgnI2NvbGxhcHNlTG9nJykub24oJ2hpZGRlbi5icy5jb2xsYXBzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gdGV4dCBmb3IgdGhlIGFib3V0IGJveFxuICAgIC8vIG5vdGUgdGhhdCAudGV4dENvbnRlbnQgaXMgdGhlIG5ldyB3YXkgdG8gd3JpdGUgdGV4dCB0byBhIGRpdlxuICAgICQoJyNhYm91dCBkaXYucGFuZWwtYm9keScpLnRleHQoJ1R3b1JhdmVucyB2MC4xIFwiRGFsbGFzXCIgLS0gVGhlIE5vcnNlIGdvZCBPZGluIGhhZCB0d28gdGFsa2luZyByYXZlbnMgYXMgYWR2aXNvcnMsIHdobyB3b3VsZCBmbHkgb3V0IGludG8gdGhlIHdvcmxkIGFuZCByZXBvcnQgYmFjayBhbGwgdGhleSBvYnNlcnZlZC4gIEluIHRoZSBOb3JzZSwgdGhlaXIgbmFtZXMgd2VyZSBcIlRob3VnaHRcIiBhbmQgXCJNZW1vcnlcIi4gIEluIG91ciBjb21pbmcgcmVsZWFzZSwgb3VyIHRob3VnaHQtcmF2ZW4gYXV0b21hdGljYWxseSBhZHZpc2VzIG9uIHN0YXRpc3RpY2FsIG1vZGVsIHNlbGVjdGlvbiwgd2hpbGUgb3VyIG1lbW9yeS1yYXZlbiBhY2N1bXVsYXRlcyBwcmV2aW91cyBzdGF0aXN0aWNhbCBtb2RlbHMgZnJvbSBEYXRhdmVyc2UsIHRvIHByb3ZpZGUgY3VtbXVsYXRpdmUgZ3VpZGFuY2UgYW5kIG1ldGEtYW5hbHlzaXMuJyk7IC8vVGhpcyBpcyB0aGUgZmlyc3QgcHVibGljIHJlbGVhc2Ugb2YgYSBuZXcsIGludGVyYWN0aXZlIFdlYiBhcHBsaWNhdGlvbiB0byBleHBsb3JlIGRhdGEsIHZpZXcgZGVzY3JpcHRpdmUgc3RhdGlzdGljcywgYW5kIGVzdGltYXRlIHN0YXRpc3RpY2FsIG1vZGVscy5cIjtcblxuICAgIC8vIHJlYWQgRERJIG1ldGFkYXRhIHdpdGggZDM6XG4gICAgdmFyIG1ldGFkYXRhdXJsID0gXCJcIjtcbiAgICBpZiAoZGRpdXJsKSB7XG4gICAgICAgIG1ldGFkYXRhdXJsID0gZGRpdXJsO1xuICAgIH0gZWxzZSBpZiAoZmlsZWlkKSB7XG4gICAgICAgIC8vIGZpbGUgaWQgc3VwcGxpZWQ7IHdlJ3JlIGdvaW5nIHRvIGNvb2sgYSBzdGFuZGFyZCBkYXRhdmVyc2VcbiAgICAgICAgLy8gbWV0YWRhdGEgdXJsLCB3aXRoIHRoZSBmaWxlIGlkIHByb3ZpZGVkIGFuZCB0aGUgaG9zdG5hbWVcbiAgICAgICAgLy8gc3VwcGxpZWQgb3IgY29uZmlndXJlZDpcbiAgICAgICAgbWV0YWRhdGF1cmwgPSBkYXRhdmVyc2V1cmwgKyBcIi9hcGkvbWV0YS9kYXRhZmlsZS9cIiArIGZpbGVpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZWl0aGVyIGEgZnVsbCBkZGkgdXJsLCBub3IgZmlsZSBpZCBzdXBwbGllZFxuICAgICAgICAvLyB1c2Ugb25lIG9mIHRoZSBzYW1wbGUgZGF0YSBmaWxlcyBkaXN0cmlidXRlZCB3aXRoIHRoZSBhcHAgaW4gdGhlICdkYXRhJyBkaXJlY3RvcnlcbiAgICAgICAgbWV0YWRhdGF1cmwgPSBcImRhdGEvUFVNUzVzbWFsbC1kZGkueG1sXCI7IC8vIFRoaXMgaXMgQ2FsaWZvcm5pYSBQVU1TIHN1YnNldFxuICAgIH1cblxuICAgIC8vIFJlYWRpbmcgcHJlLXByb2Nlc3NlZCBtZXRhZGF0YTpcbiAgICAvLyBQcmUtcHJvY2Vzc2VkIGRhdGE6XG4gICAgdmFyIHBVUkwgPSBcIlwiO1xuICAgIGlmIChkYXRhdXJsKSB7XG4gICAgICAgIHBVUkwgPSBkYXRhdXJsICsgXCImZm9ybWF0PXByZXBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2Ugb25lIG9mIHRoZSBzYW1wbGUgZGF0YSBmaWxlcyBkaXN0cmlidXRlZCB3aXRoIHRoZSBhcHAgaW4gdGhlICdkYXRhJyBkaXJlY3RvcnlcbiAgICAgICAgcFVSTCA9IFwiZGF0YS9wcmVwcm9jZXNzUFVNUzVzbWFsbC5qc29uXCI7IC8vIENhbGlmb3JuaWEgUFVNUyBzdWJzZXRcbiAgICB9XG5cbiAgICB2YXIgcHJlcHJvY2VzcyA9IHt9O1xuXG4gICAgLy8gdGhpcyBpcyB0aGUgZnVuY3Rpb24gYW5kIGNhbGxiYWNrIHJvdXRpbmUgdGhhdCBsb2FkcyBhbGwgZXh0ZXJuYWwgZGF0YTogbWV0YWRhdGEgKERWTidzIGRkaSksIHByZXByb2Nlc3NlZCAoZm9yIHBsb3R0aW5nIGRpc3RyaWJ1dGlvbnMpLCBhbmQgemVsaWdtb2RlbHMgKHByb2R1Y2VkIGJ5IFplbGlnKSBhbmQgaW5pdGlhdGVzIHRoZSBkYXRhIGRvd25sb2FkIHRvIHRoZSBzZXJ2ZXJcbiAgICB2YXIgdXJsLCBwLCB2LCBjYWxsYmFjaztcbiAgICByZWFkUHJlcHJvY2Vzcyh1cmwgPSBwVVJMLCBwID0gcHJlcHJvY2VzcywgdiA9IG51bGwsIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzLnhtbChtZXRhZGF0YXVybCwgXCJhcHBsaWNhdGlvbi94bWxcIiwgZnVuY3Rpb24oeG1sKSB7XG4gICAgICAgICAgICB2YXIgdmFycyA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ2YXJcIik7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmaWxlTmFtZVwiKTtcbiAgICAgICAgICAgIHpwYXJhbXMuemRhdGEgPSB0ZW1wWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuXG4gICAgICAgICAgICAvLyBjbGVhbiB0aGUgY2l0YXRpb24gc28gdGhhdCB0aGUgUE9TVCBpcyB2YWxpZCBqc29uXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhbnN0cmluZyhzKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXFwmL2csIFwiYW5kXCIpO1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL1xcOy9nLCBcIixcIik7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXFwlL2csIFwiLVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNpdGUgPSB4bWwuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYmlibENpdFwiKTtcbiAgICAgICAgICAgIHpwYXJhbXMuemRhdGFjaXRlID0gY2l0ZVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIHpwYXJhbXMuemRhdGFjaXRlID0gY2xlYW5zdHJpbmcoenBhcmFtcy56ZGF0YWNpdGUpO1xuXG4gICAgICAgICAgICAvLyBkYXRhc2V0IG5hbWUgdHJpbW1lZCB0byAxMiBjaGFyc1xuICAgICAgICAgICAgdmFyIGRhdGFuYW1lID0genBhcmFtcy56ZGF0YS5yZXBsYWNlKC9cXC4oLiopLywgXCJcIik7IC8vIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBkcm9wIGFueSBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgICAgLy8gUHV0IGRhdGFzZXQgbmFtZSwgZnJvbSBtZXRhLWRhdGEsIGludG8gdG9wIHBhbmVsXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjZGF0YU5hbWVcIilcbiAgICAgICAgICAgICAgICAuaHRtbChkYXRhbmFtZSk7XG5cbiAgICAgICAgICAgICQoJyNjaXRlIGRpdi5wYW5lbC1ib2R5JykudGV4dCh6cGFyYW1zLnpkYXRhY2l0ZSk7XG5cbiAgICAgICAgICAgIC8vIFB1dCBkYXRhc2V0IG5hbWUsIGZyb20gbWV0YS1kYXRhLCBpbnRvIHBhZ2UgdGl0bGVcbiAgICAgICAgICAgIGQzLnNlbGVjdChcInRpdGxlXCIpLmh0bWwoXCJUd29SYXZlbnMgXCIgKyBkYXRhbmFtZSlcblxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHZhbHVlcyBmb3IgaG9sZCB0aGF0IGNvcnJlc3BvbmQgdG8gaGlzdG9ncmFtIGJpbnNcbiAgICAgICAgICAgIGhvbGQgPSBbLjYsIC4yLCAuOSwgLjgsIC4xLCAuMywgLjRdO1xuICAgICAgICAgICAgdmFyIG15dmFsdWVzID0gWzAsIDAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVLZXlbaV0gPSB2YXJzW2ldLmF0dHJpYnV0ZXMubmFtZS5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFyc1tpXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxhYmxcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmxBcnJheVtpXSA9IFwibm8gbGFiZWxcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYWJsQXJyYXlbaV0gPSB2YXJzW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YXNldGNvdW50ID0gZDMubGF5b3V0Lmhpc3RvZ3JhbSgpXG4gICAgICAgICAgICAgICAgICAgIC5iaW5zKGJhcm51bWJlcikuZnJlcXVlbmN5KGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAobXl2YWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjcmVhdGVzIGFuIG9iamVjdCB0byBiZSBwdXNoZWQgdG8gYWxsTm9kZXMuIHRoaXMgY29udGFpbnMgYWxsIHRoZSBwcmVwcm9jZXNzZWQgZGF0YSB3ZSBoYXZlIGZvciB0aGUgdmFyaWFibGUsIGFzIHdlbGwgYXMgVUkgZGF0YSBwZXJ0aW5lbnQgdG8gdGhhdCB2YXJpYWJsZSwgc3VjaCBhcyBzZXR4IHZhbHVlcyAoaWYgdGhlIHVzZXIgaGFzIHNlbGVjdGVkIHRoZW0pIGFuZCBwZWJibGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICB2YXIgb2JqMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgIHJlZmxleGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiB2YWx1ZUtleVtpXSxcbiAgICAgICAgICAgICAgICAgICAgXCJsYWJsXCI6IGxhYmxBcnJheVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogWzUsIDE1LCAyMCwgMCwgNSwgMTUsIDIwXSxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGhvbGQsXG4gICAgICAgICAgICAgICAgICAgIFwibm9kZUNvbFwiOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgIFwiYmFzZUNvbFwiOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogc2VsVmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3Vic2V0cGxvdFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdWJzZXRyYW5nZVwiOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgIFwic2V0eHBsb3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwic2V0eHZhbHNcIjogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICBcImdyYXlvdXRcIjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgb2JqMSwgcHJlcHJvY2Vzc1t2YWx1ZUtleVtpXV0pO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gob2JqMSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBSZWFkaW5nIHRoZSB6ZWxpZyBtb2RlbHMgYW5kIHBvcHVsYXRpbmcgdGhlIG1vZGVsIGxpc3QgaW4gdGhlIHJpZ2h0IHBhbmVsLlxuICAgICAgICAgICAgZDMuanNvbihcImRhdGEvemVsaWc1bW9kZWxzLmpzb25cIiwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInplbGlnIG1vZGVscyBqc29uOiBcIiwganNvbmRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBqc29uZGF0YS56ZWxpZzVtb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25kYXRhLnplbGlnNW1vZGVscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RzW2pzb25kYXRhLnplbGlnNW1vZGVsc1trZXldLm5hbWVbMF1dID0ganNvbmRhdGEuemVsaWc1bW9kZWxzW2tleV0uZGVzY3JpcHRpb25bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkMy5qc29uKFwiZGF0YS96ZWxpZzVjaG9pY2Vtb2RlbHMuanNvblwiLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInplbGlnIGNob2ljZSBtb2RlbHMganNvbjogXCIsIGpzb25kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhLnplbGlnNWNob2ljZW1vZGVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25kYXRhLnplbGlnNWNob2ljZW1vZGVscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kc1tqc29uZGF0YS56ZWxpZzVjaG9pY2Vtb2RlbHNba2V5XS5uYW1lWzBdXSA9IGpzb25kYXRhLnplbGlnNWNob2ljZW1vZGVsc1trZXldLmRlc2NyaXB0aW9uWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2NhZmZvbGRpbmcoY2FsbGJhY2sgPSBsYXlvdXQpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhRG93bmxvYWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLy8gc2NhZmZvbGRpbmcgaXMgY2FsbGVkIGFmdGVyIGFsbCBleHRlcm5hbCBkYXRhIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgYmVlbiByZWFkIHRvIGNvbXBsZXRpb24uIHRoaXMgcG9wdWxhdGVzIHRoZSBsZWZ0IHBhbmVsIHdpdGggdmFyaWFibGUgbmFtZXMsIHRoZSByaWdodCBwYW5lbCB3aXRoIG1vZGVsIG5hbWVzLCB0aGUgdHJhbnNmb3JtYXRpb24gdG9vbCwgYW4gdGhlIGFzc29jaWF0ZWQgbW91c2VvdmVycy4gaXRzIGNhbGxiYWNrIGlzIGxheW91dCgpLCB3aGljaCBpbml0aWFsaXplcyB0aGUgbW9kZWxpbmcgc3BhY2VcbmZ1bmN0aW9uIHNjYWZmb2xkaW5nKGNhbGxiYWNrKSB7XG4gICAgLy8gZXN0YWJsaXNoaW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBlbGVtZW50XG4gICAgZDMuc2VsZWN0KFwiI3RyYW5zZm9ybWF0aW9uc1wiKVxuICAgICAgICAuYXBwZW5kKFwiaW5wdXRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInRJbnB1dFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZm9ybS1jb250cm9sXCIpXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCBcIlZhcmlhYmxlIHRyYW5zZm9ybWF0aW9uXCIpO1xuXG4gICAgLy8gdmFyaWFibGUgZHJvcGRvd25cbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ1bFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwidHJhbnNTZWxcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YShbXCJhXCIsIFwiYlwiXSkgLy9zZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAvLyBmdW5jdGlvbiBkcm9wZG93blxuICAgIGQzLnNlbGVjdChcIiN0cmFuc2Zvcm1hdGlvbnNcIilcbiAgICAgICAgLmFwcGVuZChcInVsXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJ0cmFuc0xpc3RcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YSh0cmFuc2Zvcm1MaXN0KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgICQoJyN0SW5wdXQnKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJhbnNTZWwnKS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICBpZiAodCAhPT0gXCJub25lXCIpIHsgLy8gaWYgdmFyaWFibGUgbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmICh0MSAhPT0gXCJub25lXCIpIHsgLy8gaWYgZnVuY3Rpb24gbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSB0ZXh0XG4gICAgICAgICQodGhpcykuc2VsZWN0KCk7XG5cbiAgICAgICAgdmFyIHBvcyA9ICQoJyN0SW5wdXQnKS5vZmZzZXQoKTtcbiAgICAgICAgcG9zLnRvcCArPSAkKCcjdElucHV0Jykud2lkdGgoKTtcbiAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZUluKDEwMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgICQoJyN0SW5wdXQnKS5rZXl1cChmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFuc1NlbCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIHZhciB0MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFuc0xpc3QnKS5zdHlsZS5kaXNwbGF5O1xuXG4gICAgICAgIGlmICh0ICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICB9IGVsc2UgaWYgKHQxICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7IC8vIGtleXVwIG9uIFwiRW50ZXJcIlxuICAgICAgICAgICAgdmFyIG4gPSAkKCcjdElucHV0JykudmFsKCk7XG4gICAgICAgICAgICB2YXIgdCA9IHRyYW5zUGFyc2UobiA9IG4pO1xuICAgICAgICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2Zvcm0obiA9IHQuc2xpY2UoMCwgdC5sZW5ndGggLSAxKSwgdCA9IHRbdC5sZW5ndGggLSAxXSwgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJCgnI3RyYW5zTGlzdCBsaScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB0dmFyID0gJCgnI3RJbnB1dCcpLnZhbCgpO1xuXG4gICAgICAgIC8vIGlmIGludGVyYWN0IGlzIHNlbGVjdGVkLCBzaG93IHZhcmlhYmxlIGxpc3QgYWdhaW5cbiAgICAgICAgaWYgKCQodGhpcykudGV4dCgpID09PSBcImludGVyYWN0KGQsZSlcIikge1xuICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbCh0dmFyLmNvbmNhdCgnKicpKTtcbiAgICAgICAgICAgIHNlbEludGVyYWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFuZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGZ1bmMgPSAkKHRoaXMpLnRleHQoKS5yZXBsYWNlKFwiZFwiLCBcIl90cmFuc3ZhcjBcIik7XG4gICAgICAgIHZhciB0Y2FsbCA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAkKCcjdElucHV0JykudmFsKHRjYWxsKTtcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0cmFuc2Zvcm0obiA9IHR2YXIsIHQgPSB0ZnVuYywgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRpbmcgdGhlIHZhcmlhYmxlIGxpc3QgaW4gdGhlIGxlZnQgcGFuZWxcbiAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKHZhbHVlS2V5KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7IC8vIHJlcGxhY2Ugbm9uLWFscGhhbnVtZXJpY3MgZm9yIHNlbGVjdGlvbiBwdXJwb3Nlc1xuICAgICAgICB9KSAvLyBwZXJoYXBzZSBlbnN1cmUgdGhpcyBpZCBpcyB1bmlxdWUgYnkgYWRkaW5nICdfJyB0byB0aGUgZnJvbnQ/XG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKGZpbmROb2RlSW5kZXgoZCkgPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwiZGF0YS1jb250YWluZXJcIiwgXCJib2R5XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJwb3BvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10cmlnZ2VyXCIsIFwiaG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXBsYWNlbWVudFwiLCBcInJpZ2h0XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1odG1sXCIsIFwidHJ1ZVwiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdmVyXCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3V0XCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIsIFwiU3VtbWFyeSBTdGF0aXN0aWNzXCIpO1xuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKVxuICAgICAgICAuc3R5bGUoJ2hlaWdodCcsIDIwMDApXG4gICAgICAgIC5zdHlsZSgnb3ZlcmZpbGwnLCAnc2Nyb2xsJyk7XG5cbiAgICB2YXIgbW9kZWxsaXN0ID0gT2JqZWN0LmtleXMobW9kcyk7XG5cbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEobW9kZWxsaXN0KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIl9tb2RlbF9cIi5jb25jYXQoZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJNb2RlbCBEZXNjcmlwdGlvblwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGVudFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kc1tkXTtcbiAgICAgICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2soKTsgLy8gdGhpcyBjYWxscyBsYXlvdXQoKSBiZWNhdXNlIGF0IHRoaXMgcG9pbnQgYWxsIHNjYWZmb2xkaW5nIGlzIHVwIGFuZCByZWFkeVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbGF5b3V0KHYpIHtcbiAgICB2YXIgbXlWYWx1ZXMgPSBbXTtcbiAgICBub2RlcyA9IFtdO1xuICAgIGxpbmtzID0gW107XG5cbiAgICBpZiAodiA9PT0gXCJhZGRcIiB8IHYgPT09IFwibW92ZVwiKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpLnNlbGVjdEFsbChcInBcIikuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCB2YXJDb2xvcik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56dmFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlpID0gZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2pdKTtcbiAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpaV0uZ3JheW91dCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMucHVzaChhbGxOb2Rlc1tpaV0pO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE1lID0genBhcmFtcy56dmFyc1tqXS5yZXBsYWNlKC9cXFcvZywgXCJfXCIpO1xuICAgICAgICAgICAgc2VsZWN0TWUgPSBcIiNcIi5jb25jYXQoc2VsZWN0TWUpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb1JnYmEobm9kZXNbal0uc3Ryb2tlQ29sb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuemVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbXlzcmMgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMF0pO1xuICAgICAgICAgICAgdmFyIG15dGd0ID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzFdKTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbbXlzcmNdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbbXl0Z3RdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbGxOb2Rlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV0sIGFsbE5vZGVzWzJdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV1dO1xuICAgICAgICAgICAgbGlua3MgPSBbe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydChcIlRoZXJlIGFyZSB6ZXJvIHZhcmlhYmxlcyBpbiB0aGUgbWV0YWRhdGEuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFuZWxQbG90cygpOyAvLyBhZnRlciBub2RlcyBpcyBwb3B1bGF0ZWQsIGFkZCBzdWJzZXQgYW5kIHNldHggcGFuZWxzXG4gICAgcG9wdWxhdGVQb3BvdmVyKCk7IC8vIHBpcGVzIGluIHRoZSBzdW1tYXJ5IHN0YXRzIHNob3duIG9uIG1vdXNlb3ZlcnNcblxuICAgIHZhciBmb3JjZSA9IGQzLmxheW91dC5mb3JjZSgpXG4gICAgICAgIC5ub2Rlcyhub2RlcylcbiAgICAgICAgLmxpbmtzKGxpbmtzKVxuICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pXG4gICAgICAgIC5saW5rRGlzdGFuY2UoMTUwKVxuICAgICAgICAuY2hhcmdlKC04MDApXG4gICAgICAgIC5vbigndGljaycsIHRpY2spO1xuXG4gICAgLy8gZGVmaW5lIGFycm93IG1hcmtlcnMgZm9yIGdyYXBoIGxpbmtzXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnZW5kLWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNilcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RhcnQtYXJyb3cnKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDEwIDEwJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCA0KVxuICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCAzKVxuICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgMylcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMTAsLTVMMCwwTDEwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgLy8gbGluZSBkaXNwbGF5ZWQgd2hlbiBkcmFnZ2luZyBuZXcgbm9kZXNcbiAgICB2YXIgZHJhZ19saW5lID0gc3ZnLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluayBkcmFnbGluZSBoaWRkZW4nKVxuICAgICAgICAuYXR0cignZCcsICdNMCwwTDAsMCcpO1xuXG4gICAgLy8gaGFuZGxlcyB0byBsaW5rIGFuZCBub2RlIGVsZW1lbnQgZ3JvdXBzXG4gICAgdmFyIHBhdGggPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgncGF0aCcpLFxuICAgICAgICBjaXJjbGUgPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgnZycpO1xuXG4gICAgLy8gbW91c2UgZXZlbnQgdmFyc1xuICAgIHZhciBzZWxlY3RlZF9ub2RlID0gbnVsbCxcbiAgICAgICAgc2VsZWN0ZWRfbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbCxcbiAgICAgICAgbW91c2Vkb3duX25vZGUgPSBudWxsLFxuICAgICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRNb3VzZVZhcnMoKSB7XG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbDtcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcbiAgICAgICAgbW91c2Vkb3duX2xpbmsgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBmb3JjZSBsYXlvdXQgKGNhbGxlZCBhdXRvbWF0aWNhbGx5IGVhY2ggaXRlcmF0aW9uKVxuICAgIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICAgIC8vIGRyYXcgZGlyZWN0ZWQgZWRnZXMgd2l0aCBwcm9wZXIgcGFkZGluZyBmcm9tIG5vZGUgY2VudGVyc1xuICAgICAgICBwYXRoLmF0dHIoJ2QnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGFYID0gZC50YXJnZXQueCAtIGQuc291cmNlLngsXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gZC50YXJnZXQueSAtIGQuc291cmNlLnksXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpLFxuICAgICAgICAgICAgICAgIG5vcm1YID0gZGVsdGFYIC8gZGlzdCxcbiAgICAgICAgICAgICAgICBub3JtWSA9IGRlbHRhWSAvIGRpc3QsXG4gICAgICAgICAgICAgICAgc291cmNlUGFkZGluZyA9IGQubGVmdCA/IGFsbFIgKyA1IDogYWxsUixcbiAgICAgICAgICAgICAgICB0YXJnZXRQYWRkaW5nID0gZC5yaWdodCA/IGFsbFIgKyA1IDogYWxsUixcbiAgICAgICAgICAgICAgICBzb3VyY2VYID0gZC5zb3VyY2UueCArIChzb3VyY2VQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgICAgIHNvdXJjZVkgPSBkLnNvdXJjZS55ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0WCA9IGQudGFyZ2V0LnggLSAodGFyZ2V0UGFkZGluZyAqIG5vcm1YKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRZID0gZC50YXJnZXQueSAtICh0YXJnZXRQYWRkaW5nICogbm9ybVkpO1xuICAgICAgICAgICAgcmV0dXJuICdNJyArIHNvdXJjZVggKyAnLCcgKyBzb3VyY2VZICsgJ0wnICsgdGFyZ2V0WCArICcsJyArIHRhcmdldFk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNpcmNsZS5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAgYWRkIGxpc3RlbmVycyB0byBsZWZ0cGFuZWwubGVmdC4gIGV2ZXJ5IHRpbWUgYSB2YXJpYWJsZSBpcyBjbGlja2VkLCBub2RlcyB1cGRhdGVzIGFuZCBiYWNrZ3JvdW5kIGNvbG9yIGNoYW5nZXMuICBtb3VzZW92ZXIgc2hvd3Mgc3VtbWFyeSBzdGF0cyBvciBtb2RlbCBkZXNjcmlwdGlvbi5cbiAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAvLyBSRU1PVkVEIFRISVMgVE9PTFRJUCBDT0RFIEFORCBNQURFIEEgQk9PVFNUUkFQIFBPUE9WRVIgQ09NUE9ORU5UXG4gICAgICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlclwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInZhcmlhYmxlc1wiKTtcbiAgICAgICAgICAgICQoXCJib2R5IGRpdi5wb3BvdmVyIGRpdi5wb3BvdmVyLWNvbnRlbnRcIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJmb3JtLWhvcml6b250YWxcIik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIHZhckNsaWNrKCkge1xuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgodGhpcy5pZCldLmdyYXlvdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15VGV4dCA9IGQzLnNlbGVjdCh0aGlzKS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteUNvbG9yID0gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteVNDID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChteVRleHQpXS5zdHJva2VDb2xvcjtcblxuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnp2YXJzID0gW107IC8vZW1wdHkgdGhlIHp2YXJzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5yZ2IobXlDb2xvcikudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSkgeyAvLyB3ZSBhcmUgYWRkaW5nIGEgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGZpbmROb2RlKG15VGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzWzBdLnJlZmxleGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goZmluZE5vZGUobXlUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZHJvcHBpbmcgYSB2YXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGZpbmROb2RlKG15VGV4dClbXCJpbmRleFwiXSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2VMaW5rc0Zvck5vZGUoZmluZE5vZGUobXlUZXh0KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChteVNDID09IGR2Q29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHZJbmRleCA9IHpwYXJhbXMuemR2LmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHZJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG15U0MgPT0gY3NDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc0luZGV4ID0genBhcmFtcy56Y3Jvc3MuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc0luZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Y3Jvc3Muc3BsaWNlKGNzSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobXlTQyA9PSB0aW1lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZUluZGV4ID0genBhcmFtcy56dGltZS5pbmRleE9mKG15VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuenRpbWUuc3BsaWNlKHRpbWVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChteVNDID09IG5vbUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9tSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpub20uc3BsaWNlKGR2SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlc2V0KGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobXlUZXh0KV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpIC8vIG1vZGVscyB0YWJcbiAgICAgICAgLy8gIGQzLnNlbGVjdChcIiNEaXNwbGF5X2NvbnRlbnRcIilcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbXlDb2xvciA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgdmFyQ29sb3IpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnptb2RlbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgZ3JhcGggKGNhbGxlZCB3aGVuIG5lZWRlZClcbiAgICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgICAgICAvLyBub2Rlcy5pZCBpcyBwZWdnZWQgdG8gYWxsTm9kZXMsIGkuZS4gdGhlIG9yZGVyIGluIHdoaWNoIHZhcmlhYmxlcyBhcmUgcmVhZCBpblxuICAgICAgICAvLyBub2Rlcy5pbmRleCBpcyBmbG9hdGluZyBhbmQgZGVwZW5kcyBvbiB1cGRhdGVzIHRvIG5vZGVzLiAgYSB2YXJpYWJsZXMgaW5kZXggY2hhbmdlcyB3aGVuIG5ldyB2YXJpYWJsZXMgYXJlIGFkZGVkLlxuICAgICAgICBjaXJjbGUuY2FsbChmb3JjZS5kcmFnKTtcbiAgICAgICAgaWYgKGZvcmNldG9nZ2xlWzBdID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgZm9yY2UuZ3Jhdml0eSgwLjEpO1xuICAgICAgICAgICAgZm9yY2UuY2hhcmdlKC04MDApO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yY2UuZ3Jhdml0eSgwKTtcbiAgICAgICAgICAgIGZvcmNlLmNoYXJnZSgwKTtcbiAgICAgICAgICAgIGZvcmNlLmxpbmtTdHJlbmd0aCgwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3JjZS5yZXN1bWUoKTtcblxuICAgICAgICAvLyBwYXRoIChsaW5rKSBncm91cFxuICAgICAgICBwYXRoID0gcGF0aC5kYXRhKGxpbmtzKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgbGlua3NcbiAgICAgICAgLy8gVkpEOiBkYXNoZWQgbGlua3MgYmV0d2VlbiBwZWJibGVzIGFyZSBcInNlbGVjdGVkXCIuIHRoaXMgaXMgZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICBwYXRoLmNsYXNzZWQoJ3NlbGVjdGVkJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pIC8vcmV0dXJuIGQgPT09IHNlbGVjdGVkX2xpbms7IH0pXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1zdGFydCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sZWZ0ID8gJ3VybCgjc3RhcnQtYXJyb3cpJyA6ICcnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5yaWdodCA/ICd1cmwoI2VuZC1hcnJvdyknIDogJyc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgbmV3IGxpbmtzXG4gICAgICAgIHBhdGguZW50ZXIoKS5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5rJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3RlZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KSAvL3JldHVybiBkID09PSBzZWxlY3RlZF9saW5rOyB9KVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucmlnaHQgPyAndXJsKCNlbmQtYXJyb3cpJyA6ICcnO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZCkgeyAvLyBkbyB3ZSBldmVyIG5lZWQgdG8gc2VsZWN0IGEgbGluaz8gbWFrZSBpdCBkZWxldGUuLlxuICAgICAgICAgICAgICAgIHZhciBvYmoxID0gSlNPTi5zdHJpbmdpZnkoZCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqMSA9PT0gSlNPTi5zdHJpbmdpZnkobGlua3Nbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW1vdmUgb2xkIGxpbmtzXG4gICAgICAgIHBhdGguZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIGNpcmNsZSAobm9kZSkgZ3JvdXBcbiAgICAgICAgY2lyY2xlID0gY2lyY2xlLmRhdGEobm9kZXMsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmlkO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBub2RlcyAocmVmbGV4aXZlICYgc2VsZWN0ZWQgdmlzdWFsIHN0YXRlcylcbiAgICAgICAgLy9kMy5yZ2IgaXMgdGhlIGZ1bmN0aW9uIGFkanVzdGluZyB0aGUgY29sb3IgaGVyZS5cbiAgICAgICAgY2lyY2xlLnNlbGVjdEFsbCgnY2lyY2xlJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucmVmbGV4aXZlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDMucmdiKGQubm9kZUNvbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChkMy5yZ2IoZC5zdHJva2VDb2xvcikpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZC5zdHJva2VXaWR0aCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgbmV3IG5vZGVzXG4gICAgICAgIHZhciBnID0gY2lyY2xlLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHZhciBteW5hbWUgPSBkLm5hbWUgKyBcImJpZ2dyb3VwXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChteW5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIHBsb3RcbiAgICAgICAgZy5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChkLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgIGRlbnNpdHlOb2RlKGQsIG9iaiA9IHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgYmFyc05vZGUoZCwgb2JqID0gdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZHZBcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzMpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGR2Q29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2VGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjkpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjZHZUZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZHZDb2xvcik7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZHZUZXh0XCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIjZHZBcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRleHQoXCJEZXAgVmFyXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibm9tQXJjXCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmM0KVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBub21Db2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4zKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC45KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21UZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgbm9tQ29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChub21Db2xvcik7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibm9tVGV4dFwiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI25vbUFyY1wiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGV4dChcIk5vbWluYWxcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoJ3N2ZzpjaXJjbGUnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ25vZGUnKVxuICAgICAgICAgICAgLmF0dHIoJ3InLCBhbGxSKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdpbmhlcml0JylcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5ub2RlQ29sO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIFwiMC41XCIpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDMucmdiKGQuc3Ryb2tlQ29sb3IpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3JlZmxleGl2ZScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5yZWZsZXhpdmU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgc3VtbWFyeUhvbGQgPSB0cnVlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY29udGV4dG1lbnUnLCBmdW5jdGlvbihkKSB7IC8vIHJpZ2h0IGNsaWNrIG9uIG5vZGVcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBzdG9wIHJpZ2h0IGNsaWNrIGZyb20gYnViYmxpbmdcbiAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBtb3VzZWRvd25fbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlID09PSBzZWxlY3RlZF9ub2RlKSBzZWxlY3RlZF9ub2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlbHNlIHNlbGVjdGVkX25vZGUgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHJlcG9zaXRpb24gZHJhZyBsaW5lXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICd1cmwoI2VuZC1hcnJvdyknKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgJ00nICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkgKyAnTCcgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSk7XG5cbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2V1cCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBtb3VzZXVwIGZyb20gYnViYmxpbmdcblxuICAgICAgICAgICAgICAgIGlmIChyaWdodENsaWNrTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZGVkIGJ5IEZGXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHJhZy10by1zZWxmXG4gICAgICAgICAgICAgICAgbW91c2V1cF9ub2RlID0gZDtcbiAgICAgICAgICAgICAgICBpZiAobW91c2V1cF9ub2RlID09PSBtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdW5lbmxhcmdlIHRhcmdldCBub2RlXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3RyYW5zZm9ybScsICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBsaW5rIHRvIGdyYXBoICh1cGRhdGUgaWYgZXhpc3RzKVxuICAgICAgICAgICAgICAgIC8vIE5COiBsaW5rcyBhcmUgc3RyaWN0bHkgc291cmNlIDwgdGFyZ2V0OyBhcnJvd3Mgc2VwYXJhdGVseSBzcGVjaWZpZWQgYnkgYm9vbGVhbnNcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlLCB0YXJnZXQsIGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobW91c2Vkb3duX25vZGUuaWQgPCBtb3VzZXVwX25vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNldXBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxpbms7XG4gICAgICAgICAgICAgICAgbGluayA9IGxpbmtzLmZpbHRlcihmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobC5zb3VyY2UgPT09IHNvdXJjZSAmJiBsLnRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgbmV3IGxpbmtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbGluaztcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9ub2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIHNob3cgbm9kZSBOYW1lc1xuICAgICAgICBnLmFwcGVuZCgnc3ZnOnRleHQnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAxNSlcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpZCcpXG4gICAgICAgICAgICAudGV4dChkID0+IGQubmFtZSApXG5cblxuICAgICAgICAvLyBzaG93IHN1bW1hcnkgc3RhdHMgb24gbW91c2VvdmVyXG4gICAgICAgIC8vIFNWRyBkb2Vzbid0IHN1cHBvcnQgdGV4dCB3cmFwcGluZywgdXNlIGh0bWwgaW5zdGVhZFxuICAgICAgICBnLnNlbGVjdEFsbChcImNpcmNsZS5ub2RlXCIpXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHRhYkxlZnQoXCJ0YWIzXCIpO1xuICAgICAgICAgICAgICAgIHZhclN1bW1hcnkoZCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zZm9ybWF0aW9ucycpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpibG9ja1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cmFuc1NlbFwiKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGQuaWQ7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmFyID0gdmFsdWVLZXlbZC5pZF07XG5cbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjZHZBcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4xKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2VGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjUpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcIm51bWVyaWNcIikge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjbm9tQXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21UZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc0FyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjEpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjY3NUZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuNSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0aW1lQXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuMSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0aW1lVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjUpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeUhvbGQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYkxlZnQobGVmdHRhYik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2NzQXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2NzVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0aW1lQXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RpbWVUZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2QXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2VGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21BcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjbm9tVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcG9wdWxhdGluZyB0cmFuc2Zvcm1hdGlvbiBkcm9wZG93blxuICAgICAgICB2YXIgdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0LnB1c2gobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgdHJhbnNmb3JtYXRpb24gdmFyaWFibGUgbGlzdCBpcyBzaWxlbnRseSB1cGRhdGVkIGFzIHBlYmJsZXMgYXJlIGFkZGVkL3JlbW92ZWRcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgICAgICAuZGF0YSh0KSAvL3NldCB0byB2YXJpYWJsZXMgaW4gbW9kZWwgc3BhY2UgYXMgdGhleSdyZSBhZGRlZFxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJsaVwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnI3RyYW5zU2VsIGxpJykuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGlmICdpbnRlcmFjdGlvbicgaXMgdGhlIHNlbGVjdGVkIGZ1bmN0aW9uLCBkb24ndCBzaG93IHRoZSBmdW5jdGlvbiBsaXN0IGFnYWluXG4gICAgICAgICAgICBpZiAoc2VsSW50ZXJhY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9ICQoJyN0SW5wdXQnKS52YWwoKS5jb25jYXQoJCh0aGlzKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwobik7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0cmFuc1BhcnNlKG4gPSBuKTtcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuID0gdC5zbGljZSgwLCB0Lmxlbmd0aCAtIDEpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbCgkKHRoaXMpLnRleHQoKSk7XG4gICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW1vdmUgb2xkIG5vZGVzXG4gICAgICAgIGNpcmNsZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGZvcmNlLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGQpIHtcbiAgICAgICAgLy8gcHJldmVudCBJLWJhciBvbiBkcmFnXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICBpZiAoZDMuZXZlbnQuY3RybEtleSB8fCBtb3VzZWRvd25fbm9kZSB8fCBtb3VzZWRvd25fbGluaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZCkge1xuICAgICAgICBpZiAoIW1vdXNlZG93bl9ub2RlKSByZXR1cm47XG5cbiAgICAgICAgLy8gdXBkYXRlIGRyYWcgbGluZVxuICAgICAgICBkcmFnX2xpbmUuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgZDMubW91c2UodGhpcylbMF0gKyAnLCcgKyBkMy5tb3VzZSh0aGlzKVsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cChkKSB7XG4gICAgICAgIGlmIChtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIHRydWUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIGZhbHNlKTtcblxuICAgICAgICAvLyBjbGVhciBtb3VzZSBldmVudCB2YXJzXG4gICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgfVxuXG4gICAgLy8gYXBwIHN0YXJ0cyBoZXJlXG4gICAgc3ZnLmF0dHIoJ2lkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbW91c2Vkb3duKHRoaXMpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vdXNldXAodGhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KHdpbmRvdylcbiAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyAvL05PVEU6IGFsbCBjbGlja3Mgd2lsbCBidWJibGUgaGVyZSB1bmxlc3MgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgcmVzdGFydCgpOyAvLyB0aGlzIGlzIHRoZSBjYWxsIHRoZSByZXN0YXJ0IHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGZvcmNlLmxheW91dCgpXG4gICAgZmFrZUNsaWNrKCk7XG59IC8vIGVuZCBsYXlvdXRcblxuLy8gcmV0dXJucyBpZFxudmFyIGZpbmROb2RlSW5kZXggPSBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgIGZvciAodmFyIGkgaW4gYWxsTm9kZXMpIHtcbiAgICAgICAgaWYgKGFsbE5vZGVzW2ldW1wibmFtZVwiXSA9PT0gbm9kZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxOb2Rlc1tpXVtcImlkXCJdO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxudmFyIG5vZGVJbmRleCA9IGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSBpbiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZXNbaV1bXCJuYW1lXCJdID09PSBub2RlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBmaW5kTm9kZSA9IGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSBpbiBhbGxOb2Rlcykge1xuICAgICAgICBpZiAoYWxsTm9kZXNbaV1bXCJuYW1lXCJdID09PSBub2RlTmFtZSkgcmV0dXJuIGFsbE5vZGVzW2ldXG4gICAgfTtcbn1cblxuLy8gZnVuY3Rpb24gY2FsbGVkIGJ5IGZvcmNlIGJ1dHRvblxuZnVuY3Rpb24gZm9yY2VTd2l0Y2goKSB7XG4gICAgaWYgKGZvcmNldG9nZ2xlWzBdID09PSBcInRydWVcIikge1xuICAgICAgICBmb3JjZXRvZ2dsZSA9IFtcImZhbHNlXCJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNldG9nZ2xlID0gW1widHJ1ZVwiXVxuICAgIH1cblxuICAgIGlmIChmb3JjZXRvZ2dsZVswXSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuRm9yY2UnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzcGxpY2VMaW5rc0Zvck5vZGUobm9kZSkge1xuICAgIHZhciB0b1NwbGljZSA9IGxpbmtzLmZpbHRlcihmdW5jdGlvbihsKSB7XG4gICAgICAgIHJldHVybiAobC5zb3VyY2UgPT09IG5vZGUgfHwgbC50YXJnZXQgPT09IG5vZGUpO1xuICAgIH0pO1xuICAgIHRvU3BsaWNlLm1hcChmdW5jdGlvbihsKSB7XG4gICAgICAgIGxpbmtzLnNwbGljZShsaW5rcy5pbmRleE9mKGwpLCAxKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gelBvcCgpIHtcbiAgICBpZiAoZGF0YXVybCkge1xuICAgICAgICB6cGFyYW1zLnpkYXRhdXJsID0gZGF0YXVybDtcbiAgICB9XG4gICAgenBhcmFtcy56bW9kZWxjb3VudCA9IG1vZGVsQ291bnQ7XG4gICAgenBhcmFtcy56ZWRnZXMgPSBbXTtcbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7IC8vcG9wdWxhdGUgenZhcnMgYXJyYXlcbiAgICAgICAgenBhcmFtcy56dmFycy5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICB2YXIgdGVtcCA9IG5vZGVzW2pdLmlkO1xuXG4gICAgICAgIHpwYXJhbXMuenNldHhbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zZXR4dmFscztcbiAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdID0gYWxsTm9kZXNbdGVtcF0uc3Vic2V0cmFuZ2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHplZGdlcyBhcnJheVxuICAgICAgICB2YXIgc3JjdGd0ID0gW107XG4gICAgICAgIC8vY29ycmVjdCB0aGUgc291cmNlIHRhcmdldCBvcmRlcmluZyBmb3IgWmVsaWdcbiAgICAgICAgaWYgKGxpbmtzW2pdLmxlZnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzcmN0Z3QgPSBbbGlua3Nbal0uc291cmNlLm5hbWUsIGxpbmtzW2pdLnRhcmdldC5uYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNyY3RndCA9IFtsaW5rc1tqXS50YXJnZXQubmFtZSwgbGlua3Nbal0uc291cmNlLm5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHpwYXJhbXMuemVkZ2VzLnB1c2goc3JjdGd0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVzdGltYXRlKGJ0bikge1xuICAgIGlmIChwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PSBcIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG5cbiAgICAvLyBwYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcblxuICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwiemVsaWdhcHBcIjsgLy9iYXNlLmNvbmNhdChqc29ub3V0KTtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY29uc29sZS5sb2coXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgIHpwYXJhbXMuYWxsVmFycyA9IHZhbHVlS2V5LnNsaWNlKDEwLCAyNSk7IC8vIHRoaXMgaXMgYmVjYXVzZSB0aGUgVVJMIGlzIHRvbyBsb25nLi4uXG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICAvL3ZhciBzZWxlY3RvckJhc2UgPSByYXBwVVJMK1wic2VsZWN0b3JhcHA/c29sYUpTT049XCI7XG4gICAgdmFyIHNlbGVjdG9ydXJsY2FsbCA9IHJhcHBVUkwgKyBcInNlbGVjdG9yYXBwXCI7IC8vLmNvbmNhdChqc29ub3V0KTtcblxuICAgIGZ1bmN0aW9uIGVzdGltYXRlU3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7IC8vIHN0b3Agc3Bpbm5lclxuICAgICAgICBhbGxSZXN1bHRzLnB1c2goanNvbik7XG4gICAgICAgIGNvbnNvbGUubG9nKGFsbFJlc3VsdHMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImpzb24gaW46IFwiLCBqc29uKTtcblxuICAgICAgICB2YXIgbXlwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc3VsdHNcIik7XG4gICAgICAgIGlmIChlc3RpbWF0ZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG15cGFyZW50LnJlbW92ZUNoaWxkKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzdWx0c0hvbGRlclwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblxuICAgICAgICAvLyBwcm9ncmFtbWF0aWMgY2xpY2sgb24gUmVzdWx0cyBidXR0b25cbiAgICAgICAgJChcIiNidG5SZXN1bHRzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcblxuICAgICAgICBtb2RlbENvdW50ID0gbW9kZWxDb3VudCArIDE7XG4gICAgICAgIHZhciBtb2RlbCA9IFwiTW9kZWxcIi5jb25jYXQobW9kZWxDb3VudCk7XG5cbiAgICAgICAgZnVuY3Rpb24gbW9kQ29sKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHZhckNvbG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kQ29sKCk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLmluc2VydChcInBcIiwgXCI6Zmlyc3QtY2hpbGRcIikgLy8gdG9wIHN0YWNrIGZvciByZXN1bHRzXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIG1vZGVsKVxuICAgICAgICAgICAgLnRleHQobW9kZWwpXG4gICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKVxuICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvci5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHZhciBiID0gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKS5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChhLnN1YnN0cigwLCAxNykgPT09IGIuc3Vic3RyKDAsIDE3KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVzY2FwZXMgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZSBkaXNwbGF5ZWQgbW9kZWwgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RDb2woKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSk7XG4gICAgICAgICAgICAgICAgdml6KHRoaXMuaWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJDYWxsID0gW107XG4gICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgICAgICBsb2dBcnJheS5wdXNoKFwiZXN0aW1hdGU6IFwiLmNvbmNhdChyQ2FsbFswXSkpO1xuICAgICAgICBzaG93TG9nKCk7XG5cbiAgICAgICAgdml6KG1vZGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUZhaWwoYnRuKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RvclN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0aWNrZXJcIilcbiAgICAgICAgICAgIC50ZXh0KFwiU3VnZ2VzdGVkIHZhcmlhYmxlcyBhbmQgcGVyY2VudCBpbXByb3ZlbWVudCBvbiBSTVNFOiBcIiArIGpzb24udmFycyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0b3JTdWNjZXNzOiBcIiwganNvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0b3JGYWlsKGJ0bikge1xuICAgICAgICBhbGVydChcIlNlbGVjdG9yIEZhaWxcIik7XG4gICAgfVxuXG4gICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgZXN0aW1hdGVTdWNjZXNzLCBlc3RpbWF0ZUZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuZnVuY3Rpb24gZGF0YURvd25sb2FkKCkge1xuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG5cbiAgICAvL3BhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG4gICAgdmFyIGJ0biA9IFwibm9idXR0b25cIjtcblxuICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwiZGF0YWFwcFwiOyAvL2Jhc2UuY29uY2F0KGpzb25vdXQpO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICBjb25zb2xlLmxvZyhcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuXG4gICAgZnVuY3Rpb24gZG93bmxvYWRTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBjb25zb2xlLmxvZyhcImRhdGFEb3dubG9hZCBqc29uIGluOiBcIiwganNvbik7XG4gICAgICAgIHpwYXJhbXMuenNlc3Npb25pZCA9IGpzb24uc2Vzc2lvbmlkWzBdO1xuXG4gICAgICAgIC8vIHNldCB0aGUgbGluayBVUkxcbiAgICAgICAgaWYgKHByb2R1Y3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsb2dVUkwgPSByYXBwVVJMICsgXCJsb2dfZGlyL2xvZ19cIiArIHpwYXJhbXMuenNlc3Npb25pZCArIFwiLnR4dFwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2dJRFwiKS5ocmVmID0gbG9nVVJMO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvZ1VSTCA9IFwicm9vay9sb2dfXCIgKyB6cGFyYW1zLnpzZXNzaW9uaWQgKyBcIi50eHRcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibG9nSURcIikuaHJlZiA9IGxvZ1VSTDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG93bmxvYWRGYWlsKGJ0bikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGEgaGF2ZSBub3QgYmVlbiBkb3dubG9hZGVkXCIpO1xuICAgIH1cblxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIGRvd25sb2FkU3VjY2VzcywgZG93bmxvYWRGYWlsLCBzb2xhanNvbm91dCk7XG59XG5cbmZ1bmN0aW9uIHZpeihtKSB7XG4gICAgdmFyIG15bSA9ICttLnN1YnN0cig1LCA1KSAtIDE7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVLaWRzKHBhcmVudCkge1xuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbXlwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc3VsdHNWaWV3XCIpO1xuICAgIHJlbW92ZUtpZHMobXlwYXJlbnQpO1xuXG4gICAgdmFyIGpzb24gPSBhbGxSZXN1bHRzW215bV07XG5cbiAgICAvLyBwaXBlIGluIGZpZ3VyZXMgdG8gcmlnaHQgcGFuZWxcbiAgICB2YXIgZmlsZWxpc3QgPSBuZXcgQXJyYXk7XG4gICAgZm9yICh2YXIgaSBpbiBqc29uLmltYWdlcykge1xuICAgICAgICB2YXIgemZpZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIGpzb24uaW1hZ2VzW2ldKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMjAwKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDIwMCk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzdWx0c1ZpZXdcIikuYXBwZW5kQ2hpbGQoemZpZyk7XG4gICAgfVxuXG4gICAgLy8gd3JpdGUgdGhlIHJlc3VsdHMgdGFibGVcbiAgICB2YXIgcmVzdWx0c0FycmF5ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGpzb24uc3VtSW5mbykge1xuICAgICAgICBpZiAoa2V5ID09IFwiY29sbmFtZXNcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBqc29uLnN1bUluZm9ba2V5XTtcbiAgICAgICAgcmVzdWx0c0FycmF5LnB1c2gob2JqKTtcbiAgICAgICAgLyogU08gc2F5cyB0aGlzIGlzIGltcG9ydGFudCBjaGVjaywgYnV0IEkgZG9uJ3Qgc2VlIGhvdyBpdCBoZWxwcyBoZXJlLi4uXG4gICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgLy8gaW1wb3J0YW50IGNoZWNrIHRoYXQgdGhpcyBpcyBvYmplY3RzIG93biBwcm9wZXJ0eVxuICAgICAgICAgLy8gbm90IGZyb20gcHJvdG90eXBlIHByb3AgaW5oZXJpdGVkXG4gICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkocHJvcCkpe1xuICAgICAgICAgYWxlcnQocHJvcCArIFwiID0gXCIgKyBvYmpbcHJvcF0pO1xuICAgICAgICAgfVxuICAgICAgICAgfSAgKi9cbiAgICB9XG5cbiAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmFwcGVuZChcInRhYmxlXCIpO1xuXG4gICAgdmFyIHRoZWFkID0gdGFibGUuYXBwZW5kKFwidGhlYWRcIik7XG4gICAgdGhlYWQuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRoXCIpXG4gICAgICAgIC5kYXRhKGpzb24uc3VtSW5mby5jb2xuYW1lcylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInRoXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcblxuICAgIHZhciB0Ym9keSA9IHRhYmxlLmFwcGVuZChcInRib2R5XCIpO1xuICAgIHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgIC5kYXRhKHJlc3VsdHNBcnJheSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgbXlOdW0gPSBOdW1iZXIoZCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4obXlOdW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbXlOdW0udG9QcmVjaXNpb24oMyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCJhbGljZWJsdWVcIilcbiAgICAgICAgfSkgLy8gZm9yIG5vIGRpc2Nlcm5hYmxlIHJlYXNvblxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRjlGOUY5XCIpXG4gICAgICAgIH0pOyAvLyhidXQgbWF5YmUgd2UnbGwgdGhpbmsgb2Ygb25lKVxuXG4gICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5odG1sKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiPGI+Rm9ybXVsYTogPC9iPlwiLmNvbmNhdChqc29uLmNhbGxbMF0pO1xuICAgICAgICB9KTtcbn1cblxuLy8gdGhpcyBmdW5jdGlvbiBwYXJzZXMgdGhlIHRyYW5zZm9ybWF0aW9uIGlucHV0LiB2YXJpYWJsZSBuYW1lcyBhcmUgb2Z0ZW4gbmVzdGVkIGluc2lkZSBvbmUgYW5vdGhlciwgZS5nLiwgZXRod2FyLCB3YXIsIHdhcnMsIGFuZCBzbyB0aGlzIGlzIGhhbmRsZWRcbmZ1bmN0aW9uIHRyYW5zUGFyc2Uobikge1xuICAgIHZhciBvdXQyID0gW107XG4gICAgdmFyIHQyID0gbjtcbiAgICB2YXIgazIgPSAwO1xuICAgIHZhciBzdWJNZTIgPSBcIl90cmFuc3ZhclwiLmNvbmNhdChrMik7XG4gICAgdmFyIGluZGV4ZWQgPSBbXTtcblxuICAgIC8vIG91dDIgaXMgYWxsIG1hdGNoZWQgdmFyaWFibGVzLCBpbmRleGVkIGlzIGFuIGFycmF5LCBlYWNoIGVsZW1lbnQgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG1hdGNoZWQgdmFyaWFibGVzIHN0YXJ0aW5nIGluZGV4IGFuZCBmaW5pc2hpbmcgaW5kZXguICBlLmcuLCBuPVwid2FycysyXCIsIG91dDI9W3dhciwgd2Fyc10sIGluZGV4ZWQ9W3swLDJ9LHswLDN9XVxuICAgIGZvciAodmFyIGkgaW4gdmFsdWVLZXkpIHtcbiAgICAgICAgdmFyIG0yID0gbi5tYXRjaCh2YWx1ZUtleVtpXSk7XG4gICAgICAgIGlmIChtMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0Mi5wdXNoKG0yWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAodmFsdWVLZXlbaV0sIFwiZ1wiKVxuICAgICAgICB2YXIgcyA9IG4uc2VhcmNoKHJlKTtcbiAgICAgICAgaWYgKHMgIT0gLTEpIHtcbiAgICAgICAgICAgIGluZGV4ZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgZnJvbTogcyxcbiAgICAgICAgICAgICAgICB0bzogcyArIHZhbHVlS2V5W2ldLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBuZXN0ZWQgbG9vcCBub3QgZ29vZCwgYnV0IGluZGV4ZWQgaXMgbm90IGxpa2VseSB0byBiZSB2ZXJ5IGxhcmdlLlxuICAgIC8vIGlmIGEgdmFyaWFibGUgaXMgbmVzdGVkLCBpdCBpcyByZW1vdmVkIGZyb20gb3V0MlxuICAgIC8vIG5vdGljZSwgbG9vcCBpcyBiYWNrd2FyZHMgc28gdGhhdCBpbmRleCBjaGFuZ2VzIGRvbid0IGFmZmVjdCB0aGUgc3BsaWNlXG4gICAgY29uc29sZS5sb2coXCJpbmRleGVkIFwiLCBpbmRleGVkKTtcbiAgICBmb3IgKHZhciBpID0gaW5kZXhlZC5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgICBmb3IgKHZhciBqID0gaW5kZXhlZC5sZW5ndGggLSAxOyBqID4gLTE7IGotLSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaW5kZXhlZFtpXS5mcm9tID49IGluZGV4ZWRbal0uZnJvbSkgJiAoaW5kZXhlZFtpXS50byA8PSBpbmRleGVkW2pdLnRvKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGksIFwiIGlzIG5lc3RlZCBpbiBcIiwgaik7XG4gICAgICAgICAgICAgICAgb3V0Mi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIG91dDIpIHtcbiAgICAgICAgdDIgPSB0Mi5yZXBsYWNlKG91dDJbaV0sIHN1Yk1lMik7IC8vc29tZXRoaW5nIHRoYXQnbGwgbmV2ZXIgYmUgYSB2YXJpYWJsZSBuYW1lXG4gICAgICAgIGsyID0gazIgKyAxO1xuICAgICAgICBzdWJNZTIgPSBcIl90cmFuc3ZhclwiLmNvbmNhdChrMik7XG4gICAgfVxuXG4gICAgaWYgKG91dDIubGVuZ3RoID4gMCkge1xuICAgICAgICBvdXQyLnB1c2godDIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm5ldyBvdXQgXCIsIG91dDIpO1xuICAgICAgICByZXR1cm4gKG91dDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KFwiTm8gdmFyaWFibGUgbmFtZSBmb3VuZC4gUGVyaGFwcyBjaGVjayB5b3VyIHNwZWxsaW5nP1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm0obiwgdCwgdHlwZVRyYW5zZm9ybSkge1xuICAgIGlmIChwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PSBcIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdHlwZVRyYW5zZm9ybSkge1xuICAgICAgICB0ID0gdC5yZXBsYWNlKFwiK1wiLCBcIl9wbHVzX1wiKTsgLy8gY2FuJ3Qgc2VuZCB0aGUgcGx1cyBvcGVyYXRvclxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKG4pO1xuICAgIGNvbnNvbGUubG9nKHQpO1xuXG4gICAgdmFyIGJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Fc3RpbWF0ZScpO1xuXG4gICAgdmFyIG15biA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgoblswXSldO1xuICAgIGlmICh0eXBlb2YgbXluID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBteW4gPSBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG4pXTtcbiAgICB9XG5cbiAgICB2YXIgb3V0dHlwZXMgPSB7XG4gICAgICAgIHZhcm5hbWVzVHlwZXM6IG4sXG4gICAgICAgIGludGVydmFsOiBteW4uaW50ZXJ2YWwsXG4gICAgICAgIG51bWNoYXI6IG15bi5udW1jaGFyLFxuICAgICAgICBuYXR1cmU6IG15bi5uYXR1cmUsXG4gICAgICAgIGJpbmFyeTogbXluLmJpbmFyeVxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZyhteW4pO1xuICAgIC8vIGlmIHR5cGVUcmFuc2Zvcm0gYnV0IHdlIGFscmVhZHkgaGF2ZSB0aGUgbWV0YWRhdGFcbiAgICBpZiAodHlwZVRyYW5zZm9ybSkge1xuICAgICAgICBpZiAobXluLm5hdHVyZSA9PSBcIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHZhbHVlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlID0gXCJiYXJcIjtcbiAgICAgICAgICAgIGJhcnNOb2RlKG15bik7XG4gICAgICAgICAgICBwb3B1bGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChteW4ubmF0dXJlICE9IFwibm9taW5hbFwiICYgdHlwZW9mIG15bi5wbG90eCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlID0gXCJjb250aW51b3VzXCI7XG4gICAgICAgICAgICBkZW5zaXR5Tm9kZShteW4pO1xuICAgICAgICAgICAgcG9wdWxhdGVQb3BvdmVyKCk7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL3BhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgdmFyIHRyYW5zZm9ybXN0dWZmID0ge1xuICAgICAgICB6ZGF0YXVybDogZGF0YXVybCxcbiAgICAgICAgenZhcnM6IG4sXG4gICAgICAgIHpzZXNzaW9uaWQ6IHpwYXJhbXMuenNlc3Npb25pZCxcbiAgICAgICAgdHJhbnNmb3JtOiB0LFxuICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgIHR5cGVUcmFuc2Zvcm06IHR5cGVUcmFuc2Zvcm0sXG4gICAgICAgIHR5cGVTdHVmZjogb3V0dHlwZXNcbiAgICB9O1xuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkodHJhbnNmb3Jtc3R1ZmYpO1xuICAgIC8vdmFyIGJhc2UgPSByYXBwVVJMK1widHJhbnNmb3JtYXBwP3NvbGFKU09OPVwiXG5cbiAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcInRyYW5zZm9ybWFwcFwiOyAvL2Jhc2UuY29uY2F0KGpzb25vdXQpO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICBjb25zb2xlLmxvZyhcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtU3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwianNvbiBpbjogXCIsIGpzb24pO1xuXG4gICAgICAgIGlmIChqc29uLnR5cGVUcmFuc2Zvcm1bMF0pIHtcblxuICAgICAgICAgICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15SW5kZXggPSBmaW5kTm9kZUluZGV4KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgYWxsTm9kZXNbbXlJbmRleF0sIGpzb25kYXRhW2tleV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tteUluZGV4XS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNpdHlOb2RlKGFsbE5vZGVzW215SW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlc1tteUluZGV4XS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyc05vZGUoYWxsTm9kZXNbbXlJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICAgICAgcG9wdWxhdGVQb3BvdmVyKCk7XG4gICAgICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFsbE5vZGVzW215SW5kZXhdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbEhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgZnVuYzogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICB6dmFyczogbixcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc3Vic2V0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciByQ2FsbCA9IFtdO1xuICAgICAgICAgICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG4gICAgICAgICAgICB2YXIgbmV3VmFyID0gckNhbGxbMF1bMF07XG4gICAgICAgICAgICB0cmFucy5wdXNoKG5ld1Zhcik7XG5cbiAgICAgICAgICAgIGQzLmpzb24oanNvbi51cmwsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG15SW5kZXggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiSW52YWxpZCB0cmFuc2Zvcm1hdGlvbjogdGhpcyB2YXJpYWJsZSBuYW1lIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdHJhbnNmb3JtZWQgdmFyaWFibGUgdG8gdGhlIGN1cnJlbnQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhbGxOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmoxID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZXhpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGFibFwiOiBcInRyYW5zZm9ybWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGVDb2xcIjogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiYXNlQ29sXCI6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlQ29sb3JcIjogc2VsVmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cm9rZVdpZHRoXCI6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdWJzZXRwbG90XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdWJzZXRyYW5nZVwiOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNldHhwbG90XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzZXR4dmFsc1wiOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImdyYXlvdXRcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHRJbnRlcnZhbFwiOiBqc29uZGF0YVtrZXldW1wiaW50ZXJ2YWxcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHROdW1jaGFyXCI6IGpzb25kYXRhW2tleV1bXCJudW1jaGFyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWZhdWx0TmF0dXJlXCI6IGpzb25kYXRhW2tleV1bXCJuYXR1cmVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHRCaW5hcnlcIjoganNvbmRhdGFba2V5XVtcImJpbmFyeVwiXVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgb2JqMSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gob2JqMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NhZmZvbGRpbmdQdXNoKHJDYWxsWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXkucHVzaChuZXdWYXIpO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGFsbE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsTm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5zaXR5Tm9kZShhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcnNOb2RlKGFsbE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy9mb3JcblxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBsb2dcbiAgICAgICAgICAgIGxvZ0FycmF5LnB1c2goXCJ0cmFuc2Zvcm06IFwiLmNvbmNhdChyQ2FsbFswXSkpO1xuICAgICAgICAgICAgc2hvd0xvZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtRmFpbChidG4pIHtcbiAgICAgICAgYWxlcnQoXCJ0cmFuc2Zvcm0gZmFpbFwiKTtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgfVxuXG4gICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgdHJhbnNmb3JtU3VjY2VzcywgdHJhbnNmb3JtRmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG5mdW5jdGlvbiBzY2FmZm9sZGluZ1B1c2godikgeyAvLyBhZGRpbmcgYSB2YXJpYWJsZSB0byB0aGUgdmFyaWFibGUgbGlzdCBhZnRlciBhIHRyYW5zZm9ybWF0aW9uXG4gICAgZDMuc2VsZWN0KFwiI3RhYjFcIilcbiAgICAgICAgLmRhdGEodilcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB2WzBdLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgIH0pXG4gICAgICAgIC50ZXh0KHZbMF0pXG4gICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShzZWxWYXJDb2xvcikpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1jb250YWluZXJcIiwgXCJib2R5XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJwb3BvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10cmlnZ2VyXCIsIFwiaG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXBsYWNlbWVudFwiLCBcInJpZ2h0XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1odG1sXCIsIFwidHJ1ZVwiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdmVyXCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3V0XCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIsIFwiU3VtbWFyeSBTdGF0aXN0aWNzXCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIHZhckNsaWNrKCkgeyAvLyB3ZSd2ZSBhZGRlZCBhIG5ldyB2YXJpYWJsZSwgc28gd2UgbmVlZCB0byBhZGQgdGhlIGxpc3RlbmVyXG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteVRleHQgPSBkMy5zZWxlY3QodGhpcykudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlDb2xvciA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlTQyA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobXlUZXh0KV0uc3Ryb2tlQ29sb3I7XG5cbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56dmFycyA9IFtdOyAvL2VtcHR5IHRoZSB6dmFycyBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpZiAoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHsgLy8gd2UgYXJlIGFkZGluZyBhIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChmaW5kTm9kZShteVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1swXS5yZWZsZXhpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGZpbmROb2RlKG15VGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGRyb3BwaW5nIGEgdmFyaWFibGVcblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGZpbmROb2RlKG15VGV4dClbXCJpbmRleFwiXSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2VMaW5rc0Zvck5vZGUoZmluZE5vZGUobXlUZXh0KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChteVNDID09IGR2Q29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHZJbmRleCA9IHpwYXJhbXMuemR2LmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHZJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG15U0MgPT0gY3NDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc0luZGV4ID0genBhcmFtcy56Y3Jvc3MuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc0luZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Y3Jvc3Muc3BsaWNlKGNzSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobXlTQyA9PSB0aW1lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZUluZGV4ID0genBhcmFtcy56dGltZS5pbmRleE9mKG15VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuenRpbWUuc3BsaWNlKGR2SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobXlTQyA9PSBub21Db2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub21JbmRleCA9IHpwYXJhbXMuem5vbS5pbmRleE9mKG15VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZXNldChhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG15VGV4dCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICB9KTtcbiAgICBwb3B1bGF0ZVBvcG92ZXIoKTsgLy8gcGlwZXMgaW4gdGhlIHN1bW1hcnkgc3RhdHNcblxuICAgIC8vIGRyb3AgZG93biBtZW51IGZvciB0cmFuZm9ybWF0aW9uIHRvb2xiYXJcbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgLmRhdGEodilcbiAgICAgICAgLmFwcGVuZChcIm9wdGlvblwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG59XG5cbi8vIGJlbG93IGZyb20gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY29ycy8gZm9yIGNyb3NzLW9yaWdpbiByZXNvdXJjZSBzaGFyaW5nXG4vLyBDcmVhdGUgdGhlIFhIUiBvYmplY3QuXG5mdW5jdGlvbiBjcmVhdGVDT1JTUmVxdWVzdChtZXRob2QsIHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgaWYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyKSB7XG4gICAgICAgIC8vIFhIUiBmb3IgQ2hyb21lL0ZpcmVmb3gvT3BlcmEvU2FmYXJpLlxuICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBmb3IgSUUuXG4gICAgICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ09SUyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICB4aHIgPSBudWxsO1xuICAgIH1cbiAgICAvLyAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW4nKTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIHJldHVybiB4aHI7XG59XG5cbi8vIE1ha2UgdGhlIGFjdHVhbCBDT1JTIHJlcXVlc3QuXG5mdW5jdGlvbiBtYWtlQ29yc1JlcXVlc3QodXJsLCBidG4sIGNhbGxiYWNrLCB3YXJuaW5nY2FsbGJhY2ssIGpzb25zdHJpbmcpIHtcbiAgICB2YXIgeGhyID0gY3JlYXRlQ09SU1JlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGFsZXJ0KCdDT1JTIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXNwb25zZSBoYW5kbGVycyBmb3IgYXN5bmNocm9ub3VzIGxvYWRcbiAgICAvLyBvbmxvYWQgb3Igb25yZWFkeXN0YXRlY2hhbmdlP1xuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidGV4dCBcIiwgdGV4dCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTsgLy8gc2hvdWxkIHdyYXAgaW4gdHJ5IC8gY2F0Y2hcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICAgICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgIGFsZXJ0KCdFcnJvcjogQ291bGQgbm90IHBhcnNlIGluY29taW5nIEpTT04uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZXNbMF0gPT0gXCJ3YXJuaW5nXCIpIHtcbiAgICAgICAgICAgIHdhcm5pbmdjYWxsYmFjayhidG4pO1xuICAgICAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBcIiArIGpzb24ud2FybmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhidG4sIGpzb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub3RlOiB4aHIucmVhZHlzdGF0ZSBzaG91bGQgYmUgNCwgYW5kIHN0YXR1cyBzaG91bGQgYmUgMjAwLiAgYSBzdGF0dXMgb2YgMCBvY2N1cnMgd2hlbiB0aGUgdXJsIGJlY29tZXMgdG9vIGxhcmdlXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09IDApIHtcbiAgICAgICAgICAgIGFsZXJ0KCdUaGVyZSB3YXMgYW4gZXJyb3IgbWFraW5nIHRoZSByZXF1ZXN0LiB4bWxodHRwcmVxdWVzdCBzdGF0dXMgaXMgMC4nKTtcbiAgICAgICAgfSBlbHNlIGlmICh4aHIucmVhZHlTdGF0ZSAhPSA0KSB7XG4gICAgICAgICAgICBhbGVydCgnVGhlcmUgd2FzIGFuIGVycm9yIG1ha2luZyB0aGUgcmVxdWVzdC4geG1saHR0cHJlcXVlc3QgcmVhZHlzdGF0ZSBpcyBub3QgNC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KCdXb29wcywgdGhlcmUgd2FzIGFuIGVycm9yIG1ha2luZyB0aGUgcmVxdWVzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyh4aHIpO1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICAgICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgIH07XG4gICAgeGhyLnNlbmQoanNvbnN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZChjKSB7IC8vIHRoaXMgY291bGQgYmUgbWFkZSBzbWFydGVyXG4gICAgaWYgKHpwYXJhbXMuenRpbWUubGVuZ3RoICE9IDAgfCB6cGFyYW1zLnpjcm9zcy5sZW5ndGggIT0gMCB8IHpwYXJhbXMuemR2Lmxlbmd0aCAhPSAwIHwgenBhcmFtcy56bm9tLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGVnZW5kXCIpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpibG9ja1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlZ2VuZFwiKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6bm9uZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoenBhcmFtcy56dGltZS5sZW5ndGggPT0gMCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRpbWVCdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBoaWRlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGltZUJ1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IHNob3dcIik7XG4gICAgfVxuICAgIGlmICh6cGFyYW1zLnpjcm9zcy5sZW5ndGggPT0gMCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNzQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggaGlkZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNzQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggc2hvd1wiKTtcbiAgICB9XG4gICAgaWYgKHpwYXJhbXMuemR2Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHZCdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBoaWRlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHZCdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBzaG93XCIpO1xuICAgIH1cbiAgICBpZiAoenBhcmFtcy56bm9tLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibm9tQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggaGlkZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vbUJ1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IHNob3dcIik7XG4gICAgfVxuXG4gICAgYm9yZGVyU3RhdGUoKTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgbG9jYXRpb24ucmVsb2FkKCk7XG59XG5cbi8vIHByb2dyYW1tYXRpY2FsbHkgZGVzZWxlY3RpbmcgZXZlcnkgc2VsZWN0ZWQgdmFyaWFibGUuLi5cbmZ1bmN0aW9uIGVyYXNlKCkge1xuICAgIGxlZnRwYW5lbE1lZGl1bSgpO1xuICAgIHJpZ2h0cGFuZWxNZWRpdW0oKTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlZ2VuZFwiKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6bm9uZVwiKTtcblxuICAgIHRhYkxlZnQoJ3RhYjEnKTtcblxuICAgIGpRdWVyeS5mbi5kM0NsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGksIGUpIHtcbiAgICAgICAgICAgIHZhciBteWNvbCA9IGQzLnJnYih0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICBpZiAobXljb2wudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG5cbiAgICAgICAgICAgIGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgICQoXCIjdGFiMVwiKS5kM0NsaWNrKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2VsZWN0KGQpIHtcbiAgICBjb25zb2xlLmxvZyhkKTtcbn1cblxuLy8gaHR0cDovL3d3dy50dXRvcmlhbHMybGVhcm4uY29tL3R1dG9yaWFscy9zY3JpcHRzL2phdmFzY3JpcHQveG1sLXBhcnNlci1qYXZhc2NyaXB0Lmh0bWxcbmZ1bmN0aW9uIGxvYWRYTUxEb2MoWE1MbmFtZSkge1xuICAgIHZhciB4bWxEb2M7XG4gICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICB4bWxEb2MgPSBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhtbERvYy5vcGVuKFwiR0VUXCIsIFhNTG5hbWUsIGZhbHNlKTtcbiAgICAgICAgeG1sRG9jLnNlbmQoXCJcIik7XG4gICAgICAgIHJldHVybiB4bWxEb2MucmVzcG9uc2VYTUw7XG4gICAgfVxuICAgIC8vIElFIDUgYW5kIElFIDZcbiAgICBlbHNlIGlmIChBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKSkge1xuICAgICAgICB4bWxEb2MgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgIHhtbERvYy5hc3luYyA9IGZhbHNlO1xuICAgICAgICB4bWxEb2MubG9hZChYTUxuYW1lKTtcbiAgICAgICAgcmV0dXJuIHhtbERvYztcbiAgICB9XG4gICAgYWxlcnQoXCJFcnJvciBsb2FkaW5nIGRvY3VtZW50IVwiKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuXG5mdW5jdGlvbiB0YWJMZWZ0KHRhYikge1xuXG4gICAgaWYgKHRhYiAhPSBcInRhYjNcIikge1xuICAgICAgICBsZWZ0dGFiID0gdGFiO1xuICAgIH1cbiAgICB2YXIgdGFiaSA9IHRhYi5zdWJzdHJpbmcoMyk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGFiMScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RhYjInKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0YWIzJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIGlmICh0YWIgPT09IFwidGFiMVwiKSB7XG4gICAgICAgIHN1bW1hcnlIb2xkID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TdWJzZXQnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blZhcmlhYmxlcycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBkMy5zZWxlY3QoXCIjbGVmdHBhbmVsXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbiAgICB9IGVsc2UgaWYgKHRhYiA9PT0gXCJ0YWIyXCIpIHtcbiAgICAgICAgc3VtbWFyeUhvbGQgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blZhcmlhYmxlcycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU3Vic2V0Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNsZWZ0cGFuZWxcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpID09PSBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXggZXhwYW5kcGFuZWxcIikge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ0blNlbGVjdFwiKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXggZXhwYW5kcGFuZWxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU3Vic2V0Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5WYXJpYWJsZXMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjbGVmdHBhbmVsXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YWIpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xufVxuXG5mdW5jdGlvbiB0YWJSaWdodCh0YWJpZCkge1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGVscycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHgnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXN1bHRzJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIGlmICh0YWJpZCA9PSBcImJ0bk1vZGVsc1wiKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TZXR4Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5SZXN1bHRzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Nb2RlbHMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2RlbHMnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG4gICAgfSBlbHNlIGlmICh0YWJpZCA9PSBcImJ0blNldHhcIikge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuTW9kZWxzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5SZXN1bHRzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TZXR4Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0eCcpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgIGlmIChyaWdodHRhYiA9PSBcImJ0blNldHhcIiB8IGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpLmF0dHIoXCJjbGFzc1wiKSA9PSBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIikge1xuICAgICAgICAgICAgdG9nZ2xlUigpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YWJpZCA9PSBcImJ0blJlc3VsdHNcIikge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuTW9kZWxzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TZXR4Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5SZXN1bHRzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzdWx0cycpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgIGlmIChlc3RpbWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0dGFiID09IFwiYnRuUmVzdWx0c1wiIHwgZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIikuYXR0cihcImNsYXNzXCIpID09IFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKSB7XG4gICAgICAgICAgICB0b2dnbGVSKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByaWdodHRhYiA9IHRhYmlkOyAvLyBhIGdsb2JhbCB0aGF0IG1heSBiZSBvZiB1c2VcblxuICAgIGZ1bmN0aW9uIHRvZ2dsZVIoKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSA9PT0gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4IGV4cGFuZHBhbmVsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXggZXhwYW5kcGFuZWxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gdmFyU3VtbWFyeShkKSB7XG5cbiAgICB2YXIgcmludCA9IGQzLmZvcm1hdChcInJcIik7XG5cbiAgICB2YXIgc3VtbWFyeWRhdGEgPSBbXSxcbiAgICAgICAgdG1wRGF0YXNldCA9IFtdLFxuICAgICAgICB0MSA9IFtcIk1lYW46XCIsIFwiTWVkaWFuOlwiLCBcIk1vc3QgRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgXCJNZWRpYW4gRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgXCJMZWFzdCBGcmVxOlwiLCBcIk9jY3VycmVuY2VzOlwiLCBcIlN0YW5kLkRldjpcIiwgXCJNaW5pbXVtOlwiLCBcIk1heGltdW06XCIsIFwiSW52YWxpZDpcIiwgXCJWYWxpZDpcIiwgXCJVbmlxdWVzOlwiLCBcIkhlcmZpbmRhaGw6XCJdLFxuICAgICAgICB0MiA9IFsoK2QubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSwgKCtkLm1lZGlhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLCAoK2Quc2QpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksICgrZC5taW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksICgrZC5tYXgpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksIHJpbnQoZC5pbnZhbGlkKSwgcmludChkLnZhbGlkKSwgcmludChkLnVuaXF1ZXMpLCAoK2QuaGVyZmluZGFobCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKV0sXG4gICAgICAgIGksIGo7XG4gICAgaWYgKHByaXYpIHtcbiAgICAgICAgaWYgKGQubWVhbkNJKSB7XG4gICAgICAgICAgICB0MSA9IFtcIk1lYW46XCIsIFwiTWVkaWFuOlwiLCBcIk1vc3QgRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgXCJNZWRpYW4gRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgXCJMZWFzdCBGcmVxOlwiLCBcIk9jY3VycmVuY2VzOlwiLCBcIlN0YW5kLkRldjpcIiwgXCJNaW5pbXVtOlwiLCBcIk1heGltdW06XCIsIFwiSW52YWxpZDpcIiwgXCJWYWxpZDpcIiwgXCJVbmlxdWVzOlwiLCBcIkhlcmZpbmRhaGw6XCJdLFxuICAgICAgICAgICAgICAgIHQyID0gWygrZC5tZWFuKS50b1ByZWNpc2lvbigyKS50b1N0cmluZygpICsgXCIgKFwiICsgKCtkLm1lYW5DSS5sb3dlckJvdW5kKS50b1ByZWNpc2lvbigyKS50b1N0cmluZygpICsgXCIgLSBcIiArICgrZC5tZWFuQ0kudXBwZXJCb3VuZCkudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiKVwiLCAoK2QubWVkaWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCBkLm1vZGUsIHJpbnQoZC5mcmVxbW9kZSksIGQubWlkLCByaW50KGQuZnJlcW1pZCksIGQuZmV3ZXN0LCByaW50KGQuZnJlcWZld2VzdCksICgrZC5zZCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSwgKCtkLm1pbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSwgKCtkLm1heCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSwgcmludChkLmludmFsaWQpLCByaW50KGQudmFsaWQpLCByaW50KGQudW5pcXVlcyksICgrZC5oZXJmaW5kYWhsKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpXSxcbiAgICAgICAgICAgICAgICBpLCBqO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHQxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0MltpXS5pbmRleE9mKFwiTmFOXCIpID4gLTEgfCB0MltpXSA9PSBcIk5BXCIgfCB0MltpXSA9PSBcIlwiKSBjb250aW51ZTtcbiAgICAgICAgdG1wRGF0YXNldCA9IFtdO1xuICAgICAgICB0bXBEYXRhc2V0LnB1c2godDFbaV0pO1xuICAgICAgICB0bXBEYXRhc2V0LnB1c2godDJbaV0pO1xuICAgICAgICBzdW1tYXJ5ZGF0YS5wdXNoKHRtcERhdGFzZXQpO1xuICAgIH07XG5cbiAgICAvLyAgY29uc29sZS5sb2coc3VtbWFyeWRhdGEpO1xuICAgIGQzLnNlbGVjdChcIiN0YWIzXCIpIC8vdGFiIHdoZW4geW91IG1vdXNlb3ZlciBhIHBlYmJsZVxuICAgICAgICAuc2VsZWN0KFwicFwiKVxuICAgICAgICAuaHRtbChcIjxjZW50ZXI+PGI+XCIgKyBkLm5hbWUgKyBcIjwvYj48YnI+PGk+XCIgKyBkLmxhYmwgKyBcIjwvaT48L2NlbnRlcj5cIilcbiAgICAgICAgLmFwcGVuZChcInRhYmxlXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0clwiKVxuICAgICAgICAuZGF0YShzdW1tYXJ5ZGF0YSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImFsaWNlYmx1ZVwiKVxuICAgICAgICB9KSAvLyBmb3Igbm8gZGlzY2VybmFibGUgcmVhc29uXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNGOUY5RjlcIilcbiAgICAgICAgfSk7IC8vKGJ1dCBtYXliZSB3ZSdsbCB0aGluayBvZiBvbmUpXG4gICAgLy8gICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKTtcblxuXG4gICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QoXCIjdGFiM1wiKVxuICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIGlmICh0eXBlb2YgZC5wbG90dHlwZSA9PT0gXCJ1bmRlZmluZWRcIikgeyAvLyAucHJvcGVydGllcyBpcyB1bmRlZmluZWQgZm9yIHNvbWUgdmFyc1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChkLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICBkZW5zaXR5KGQsIGRpdiA9IFwidmFyU3VtbWFyeVwiLCBwcml2KTtcbiAgICB9IGVsc2UgaWYgKGQucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgYmFycyhkLCBkaXYgPSBcInZhclN1bW1hcnlcIiwgcHJpdik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QoXCIjdGFiM1wiKSAvLyBubyBncmFwaCB0byBkcmF3LCBidXQgc3RpbGwgbmVlZCB0byByZW1vdmUgcHJldmlvdXMgZ3JhcGhcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwb3B1bGF0ZVBvcG92ZXIoKSB7XG4gICAgZDMuc2VsZWN0KFwiI3RhYjFcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGVudFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgb25Ob2RlID0gZmluZE5vZGVJbmRleChkKTtcbiAgICAgICAgICAgIHJldHVybiBwb3BvdmVyQ29udGVudChhbGxOb2Rlc1tvbk5vZGVdKTtcbiAgICAgICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvcG92ZXJDb250ZW50KGQpIHtcblxuICAgIHZhciByaW50ID0gZDMuZm9ybWF0KFwiclwiKTtcblxuICAgIHZhciBvdXR0ZXh0ID0gXCJcIjtcblxuICAgIGlmIChkLmxhYmwgIT0gXCJcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5MYWJlbDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz48aT5cIiArIGQubGFibCArIFwiPC9pPjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBpZiAoZC5tZWFuICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NZWFuPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiXG4gICAgICAgIGlmIChwcml2ICYmIGQubWVhbkNJKSB7XG4gICAgICAgICAgICBvdXR0ZXh0ICs9ICgrZC5tZWFuKS50b1ByZWNpc2lvbigyKS50b1N0cmluZygpICsgXCIgKFwiICsgKCtkLm1lYW5DSS5sb3dlckJvdW5kKS50b1ByZWNpc2lvbigyKS50b1N0cmluZygpICsgXCIgLSBcIiArICgrZC5tZWFuQ0kudXBwZXJCb3VuZCkudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXR0ZXh0ICs9ICgrZC5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpXG4gICAgICAgIH1cbiAgICAgICAgb3V0dGV4dCArPSBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBpZiAoZC5tZWRpYW4gIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lZGlhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArICgrZC5tZWRpYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBpZiAoZC5tb2RlICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5Nb3N0IEZyZXE8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyBkLm1vZGUgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBpZiAoZC5mcmVxbW9kZSAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+T2NjdXJyZW5jZXM8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuZnJlcW1vZGUpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQubWlkICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NZWRpYW4gRnJlcTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIGQubWlkICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQuZnJlcW1pZCAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+T2NjdXJyZW5jZXM8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuZnJlcW1pZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgaWYgKGQuZmV3ZXN0ICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5MZWFzdCBGcmVxPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgZC5mZXdlc3QgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBpZiAoZC5mcmVxZmV3ZXN0ICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5PY2N1cnJlbmNlczwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC5mcmVxZmV3ZXN0KSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cblxuICAgIGlmIChkLnNkICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5TdGFuZCBEZXY8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyAoK2Quc2QpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBpZiAoZC5tYXggIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1heGltdW08L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyAoK2QubWF4KS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuXG4gICAgaWYgKGQubWluICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NaW5pbXVtPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgKCtkLm1pbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBpZiAoZC5pbnZhbGlkICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5JbnZhbGlkPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLmludmFsaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLnZhbGlkICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5WYWxpZDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBpZiAoZC51bmlxdWVzICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5VbmlxdWVzPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLnVuaXF1ZXMpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLmhlcmZpbmRhaGwgIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPkhlcmZpbmRhaGw8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyAoK2QuaGVyZmluZGFobCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cblxuICAgIHJldHVybiBvdXR0ZXh0O1xufVxuXG5mdW5jdGlvbiBwb3B1cFgoZCkge1xuXG4gICAgdmFyIHRzZiA9IGQzLmZvcm1hdChcIi40clwiKTtcbiAgICB2YXIgcmludCA9IGQzLmZvcm1hdChcInJcIik7XG5cbiAgICAvL0NyZWF0ZSB0aGUgdG9vbHRpcCBsYWJlbFxuICAgIGQzLnNlbGVjdChcIiN0b29sdGlwXCIpXG4gICAgICAgIC5zdHlsZShcImxlZnRcIiwgdGVtcFggKyBcInB4XCIpXG4gICAgICAgIC5zdHlsZShcInRvcFwiLCB0ZW1wWSArIFwicHhcIilcbiAgICAgICAgLnNlbGVjdChcIiN0b29sdGlwdGV4dFwiKVxuICAgICAgICAuaHRtbChcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lYW4pICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVkaWFuPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQubWVkaWFuKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcblxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1vZGU8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyBkLm1vZGUgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG5cbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5TdGFuZCBEZXY8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyB0c2YoZC5zZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG5cbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NYXhpbXVtPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQubWF4KSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcblxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1pbmltdW08L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyB0c2YoZC5taW4pICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+VmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQudmFsaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+SW52YWxpZDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC5pbnZhbGlkKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiXG4gICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIHBhbmVsUGxvdHMoKSB7XG4gICAgLy8gYnVpbGQgYXJyYXlzIGZyb20gbm9kZXMgaW4gbWFpblxuICAgIHZhciB2YXJBcnJheSA9IFtdO1xuICAgIHZhciBpZEFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhckFycmF5LnB1c2gobm9kZXNbal0ubmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpKTtcbiAgICAgICAgaWRBcnJheS5wdXNoKG5vZGVzW2pdLmlkKTtcbiAgICB9XG5cbiAgICAvL3JlbW92ZSBhbGwgcGxvdHMsIGNvdWxkIGJlIHNtYXJ0ZXIgaGVyZVxuICAgIGQzLnNlbGVjdChcIiNzZXR4XCIpLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoXCIjdGFiMlwiKS5zZWxlY3RBbGwoXCJzdmdcIikucmVtb3ZlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhckFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnN1YnNldHBsb3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFsbE5vZGVzW2lkQXJyYXlbaV1dLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiAmIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnNldHhwbG90ID09IGZhbHNlKSB7XG4gICAgICAgICAgICBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zZXR4cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwcml2KTtcbiAgICAgICAgICAgIGRlbnNpdHkoYWxsTm9kZXNbaWRBcnJheVtpXV0sIGRpdiA9IFwic2V0eFwiLCBwcml2KTtcbiAgICAgICAgICAgIGFsbE5vZGVzW2lkQXJyYXlbaV1dLnN1YnNldHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgZGVuc2l0eShhbGxOb2Rlc1tpZEFycmF5W2ldXSwgZGl2ID0gXCJzdWJzZXRcIiwgcHJpdik7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXNbaWRBcnJheVtpXV0ucGxvdHR5cGUgPT09IFwiYmFyXCIgJiBhbGxOb2Rlc1tpZEFycmF5W2ldXS5zZXR4cGxvdCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgYWxsTm9kZXNbaWRBcnJheVtpXV0uc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFycyhhbGxOb2Rlc1tpZEFycmF5W2ldXSwgZGl2ID0gXCJzZXR4XCIsIHByaXYpO1xuICAgICAgICAgICAgYWxsTm9kZXNbaWRBcnJheVtpXV0uc3Vic2V0cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBiYXJzU3Vic2V0KGFsbE5vZGVzW2lkQXJyYXlbaV1dKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZDMuc2VsZWN0KFwiI3NldHhcIikuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHJlZ3N0ciA9IC8oLispX3NldHhfKFxcZCspLztcbiAgICAgICAgICAgIHZhciBteW5hbWUgPSByZWdzdHIuZXhlYyh0aGlzLmlkKTtcbiAgICAgICAgICAgIHZhciBub2RlaWQgPSBteW5hbWVbMl07XG4gICAgICAgICAgICBteW5hbWUgPSBteW5hbWVbMV07XG4gICAgICAgICAgICB2YXIgaiA9IHZhckFycmF5LmluZGV4T2YobXluYW1lKTtcblxuICAgICAgICAgICAgaWYgKGogPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tub2RlaWRdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl9zZXR4X1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tub2RlaWRdLnN1YnNldHBsb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IFwiI1wiLmNvbmNhdChteW5hbWUsIFwiX3RhYjJfXCIsIG5vZGVpZCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRlbXApXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59XG5cbi8vIGVhc3kgZnVuY3Rpb25zIHRvIGNvbGxhcHNlIHBhbmVscyB0byBiYXNlXG5mdW5jdGlvbiByaWdodHBhbmVsTWVkaXVtKCkge1xuICAgIGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xufVxuXG5mdW5jdGlvbiBsZWZ0cGFuZWxNZWRpdW0oKSB7XG4gICAgZDMuc2VsZWN0KFwiI2xlZnRwYW5lbFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbn1cblxuLy8gZnVuY3Rpb24gdG8gY29udmVydCBjb2xvciBjb2Rlc1xuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleCkge1xuICAgIHZhciBoID0gaGV4LnJlcGxhY2UoJyMnLCAnJyk7XG5cbiAgICB2YXIgYmlnaW50ID0gcGFyc2VJbnQoaCwgMTYpO1xuICAgIHZhciByID0gKGJpZ2ludCA+PiAxNikgJiAyNTU7XG4gICAgdmFyIGcgPSAoYmlnaW50ID4+IDgpICYgMjU1O1xuICAgIHZhciBiID0gYmlnaW50ICYgMjU1O1xuICAgIHZhciBhID0gJzAuNSc7XG5cbiAgICByZXR1cm4gXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLFwiICsgYSArIFwiKVwiO1xufVxuXG4vLyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgYW5kIGEgY29sb3IgYW5kIHVwZGF0ZXMgenBhcmFtc1xuZnVuY3Rpb24gc2V0Q29sb3JzKG4sIGMpIHtcblxuICAgIGlmIChuLnN0cm9rZVdpZHRoID09ICcxJykgeyAvLyBhZGRpbmcgdGltZSwgY3MsIGR2LCBub20gdG8gYSBub2RlIHdpdGggbm8gc3Ryb2tlXG4gICAgICAgIG4uc3Ryb2tlV2lkdGggPSAnNCc7XG4gICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICBuLm5vZGVDb2wgPSB0YWdnZWRDb2xvcjtcbiAgICAgICAgaWYgKGR2Q29sb3IgPT0gYykge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgYXJyYXksIGlmIG5vdCwgbWFrZSBpdCBhbiBhcnJheVxuICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh6cGFyYW1zLnpkdikpO1xuICAgICAgICAgICAgenBhcmFtcy56ZHYgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoenBhcmFtcy56ZHYpID09IFwiW29iamVjdCBBcnJheV1cIiA/IHpwYXJhbXMuemR2IDogW107XG4gICAgICAgICAgICB6cGFyYW1zLnpkdi5wdXNoKG4ubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3NDb2xvciA9PSBjKSB7XG4gICAgICAgICAgICB6cGFyYW1zLnpjcm9zcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh6cGFyYW1zLnpjcm9zcykgPT0gXCJbb2JqZWN0IEFycmF5XVwiID8genBhcmFtcy56Y3Jvc3MgOiBbXTtcbiAgICAgICAgICAgIHpwYXJhbXMuemNyb3NzLnB1c2gobi5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgenBhcmFtcy56dGltZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh6cGFyYW1zLnp0aW1lKSA9PSBcIltvYmplY3QgQXJyYXldXCIgPyB6cGFyYW1zLnp0aW1lIDogW107XG4gICAgICAgICAgICB6cGFyYW1zLnp0aW1lLnB1c2gobi5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChub21Db2xvciA9PSBjKSB7XG4gICAgICAgICAgICB6cGFyYW1zLnpub20gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoenBhcmFtcy56bm9tKSA9PSBcIltvYmplY3QgQXJyYXldXCIgPyB6cGFyYW1zLnpub20gOiBbXTtcbiAgICAgICAgICAgIHpwYXJhbXMuem5vbS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG4ubmFtZSldLm5hdHVyZSA9IFwibm9taW5hbFwiO1xuICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpLnNlbGVjdChcInAjXCIuY29uY2F0KG4ubmFtZSkpXG4gICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoYykpO1xuICAgIH0gZWxzZSBpZiAobi5zdHJva2VXaWR0aCA9PSAnNCcpIHtcbiAgICAgICAgaWYgKGMgPT0gbi5zdHJva2VDb2xvcikgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbVxuICAgICAgICAgICAgbi5zdHJva2VXaWR0aCA9ICcxJztcbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBzZWxWYXJDb2xvcjtcbiAgICAgICAgICAgIG4ubm9kZUNvbCA9IGNvbG9ycyhuLmlkKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpLnNlbGVjdChcInAjXCIuY29uY2F0KG4ubmFtZSkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSk7XG5cbiAgICAgICAgICAgIGlmIChkdkNvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHZJbmRleCA9IHpwYXJhbXMuemR2LmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZHZJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNzQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgICAgIHZhciBjc0luZGV4ID0genBhcmFtcy56Y3Jvc3MuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjc0luZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Y3Jvc3Muc3BsaWNlKGNzSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZUNvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZUluZGV4ID0genBhcmFtcy56dGltZS5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuenRpbWUuc3BsaWNlKHRpbWVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub21Db2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobm9tSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpub20uc3BsaWNlKG5vbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5uYXR1cmUgPSBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG4ubmFtZSldLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbSBBTkQgY2hhbmdpbmcgaXQgdG8gdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIGlmIChkdkNvbG9yID09IG4uc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHZJbmRleCA9IHpwYXJhbXMuemR2LmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZHZJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNzQ29sb3IgPT0gbi5zdHJva2VDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBjc0luZGV4ID0genBhcmFtcy56Y3Jvc3MuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjc0luZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Y3Jvc3Muc3BsaWNlKGNzSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZUNvbG9yID09IG4uc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZUluZGV4ID0genBhcmFtcy56dGltZS5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuenRpbWUuc3BsaWNlKHRpbWVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub21Db2xvciA9PSBuLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobm9tSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpub20uc3BsaWNlKG5vbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5uYXR1cmUgPSBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG4ubmFtZSldLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IGM7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3QoXCJwI1wiLmNvbmNhdChuLm5hbWUpKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShjKSk7XG5cbiAgICAgICAgICAgIGlmIChkdkNvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNzQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuemNyb3NzLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZUNvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnp0aW1lLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9tQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuem5vbS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5uYXR1cmUgPSBcIm5vbWluYWxcIjtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBib3JkZXJTdGF0ZSgpIHtcbiAgICBpZiAoenBhcmFtcy56ZHYubGVuZ3RoID4gMCkge1xuICAgICAgICAkKCcjZHZCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZHZDb2xvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCgnI2R2QnV0dG9uJykuY3NzKCdib3JkZXItY29sb3InLCAnI2NjYycpO1xuICAgIH1cbiAgICBpZiAoenBhcmFtcy56Y3Jvc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAkKCcjY3NCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgY3NDb2xvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCgnI2NzQnV0dG9uJykuY3NzKCdib3JkZXItY29sb3InLCAnI2NjYycpO1xuICAgIH1cbiAgICBpZiAoenBhcmFtcy56dGltZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICQoJyN0aW1lQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIHRpbWVDb2xvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCgnI3RpbWVCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgfVxuICAgIGlmICh6cGFyYW1zLnpub20ubGVuZ3RoID4gMCkge1xuICAgICAgICAkKCcjbm9tQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIG5vbUNvbG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAkKCcjbm9tQnV0dG9uJykuY3NzKCdib3JkZXItY29sb3InLCAnI2NjYycpO1xuICAgIH1cbn1cblxuLy8gc21hbGwgYXBwZWFyYW5jZSByZXNldHMsIGJ1dCBwZXJoYXBzIHRoaXMgd2lsbCBiZWNvbWUgYSBoYXJkIHJlc2V0IGJhY2sgdG8gYWxsIG9yaWdpbmFsIGFsbE5vZGUgdmFsdWVzP1xuZnVuY3Rpb24gbm9kZVJlc2V0KG4pIHtcbiAgICBuLnN0cm9rZUNvbG9yID0gc2VsVmFyQ29sb3I7XG4gICAgbi5zdHJva2VXaWR0aCA9IFwiMVwiO1xuICAgIG4ubm9kZUNvbCA9IG4uYmFzZUNvbDtcbn1cblxuZnVuY3Rpb24gc3Vic2V0U2VsZWN0KGJ0bikge1xuICAgIGlmIChkYXRhdXJsKSB7XG4gICAgICAgIHpwYXJhbXMuemRhdGF1cmwgPSBkYXRhdXJsO1xuICAgIH1cblxuICAgIGlmIChwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PSBcIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHpwYXJhbXMuenZhcnMgPSBbXTtcbiAgICB6cGFyYW1zLnpwbG90ID0gW107XG5cbiAgICB2YXIgc3Vic2V0RW1wdHkgPSB0cnVlO1xuXG4gICAgLy8gaXMgdGhpcyB0aGUgc2FtZSBhcyB6UG9wKCk/XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHp2YXJzIGFuZCB6c3Vic2V0IGFycmF5c1xuICAgICAgICB6cGFyYW1zLnp2YXJzLnB1c2gobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIHZhciB0ZW1wID0gbm9kZXNbal0uaWQ7XG4gICAgICAgIHpwYXJhbXMuenN1YnNldFtqXSA9IGFsbE5vZGVzW3RlbXBdLnN1YnNldHJhbmdlO1xuICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMF0gIT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVswXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzFdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgenBhcmFtcy56cGxvdC5wdXNoKGFsbE5vZGVzW3RlbXBdLnBsb3R0eXBlKTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKSB7XG4gICAgICAgICAgICBzdWJzZXRFbXB0eSA9IGZhbHNlO1xuICAgICAgICB9IC8vb25seSBuZWVkIHRvIGNoZWNrIG9uZVxuICAgIH1cblxuICAgIGlmIChzdWJzZXRFbXB0eSA9PSB0cnVlKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogTm8gbmV3IHN1YnNldCBzZWxlY3RlZC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3V0dHlwZXMgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG91dHR5cGVzLnB1c2goe1xuICAgICAgICAgICAgdmFybmFtZXNUeXBlczogYWxsTm9kZXNbal0ubmFtZSxcbiAgICAgICAgICAgIG5hdHVyZTogYWxsTm9kZXNbal0ubmF0dXJlLFxuICAgICAgICAgICAgbnVtY2hhcjogYWxsTm9kZXNbal0ubnVtY2hhcixcbiAgICAgICAgICAgIGJpbmFyeTogYWxsTm9kZXNbal0uYmluYXJ5LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGFsbE5vZGVzW2pdLmludGVydmFsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBzdWJzZXRzdHVmZiA9IHtcbiAgICAgICAgemRhdGF1cmw6IHpwYXJhbXMuemRhdGF1cmwsXG4gICAgICAgIHp2YXJzOiB6cGFyYW1zLnp2YXJzLFxuICAgICAgICB6c3Vic2V0OiB6cGFyYW1zLnpzdWJzZXQsXG4gICAgICAgIHpzZXNzaW9uaWQ6IHpwYXJhbXMuenNlc3Npb25pZCxcbiAgICAgICAgenBsb3Q6IHpwYXJhbXMuenBsb3QsXG4gICAgICAgIGNhbGxIaXN0b3J5OiBjYWxsSGlzdG9yeSxcbiAgICAgICAgdHlwZVN0dWZmOiBvdXR0eXBlc1xuICAgIH07XG5cbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHN1YnNldHN0dWZmKTtcbiAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcInN1YnNldGFwcFwiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICBjb25zb2xlLmxvZyhcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuXG4gICAgZnVuY3Rpb24gc3Vic2V0U2VsZWN0U3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgICAgc2VsZWN0TGFkZGEuc3RvcCgpOyAvLyBzdG9wIG1vdGlvblxuICAgICAgICAkKFwiI2J0blZhcmlhYmxlc1wiKS50cmlnZ2VyKFwiY2xpY2tcIik7IC8vIHByb2dyYW1tYXRpYyBjbGlja3NcbiAgICAgICAgJChcIiNidG5Nb2RlbHNcIikudHJpZ2dlcihcImNsaWNrXCIpO1xuXG4gICAgICAgIHZhciBncmF5T3V0cyA9IFtdO1xuXG4gICAgICAgIHZhciByQ2FsbCA9IFtdO1xuICAgICAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcblxuICAgICAgICAvLyBzdG9yZSBjb250ZW50cyBvZiB0aGUgcHJlLXN1YnNldCBzcGFjZVxuICAgICAgICB6UG9wKCk7XG4gICAgICAgIHZhciBteU5vZGVzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgYWxsTm9kZXMpO1xuICAgICAgICB2YXIgbXlQYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCB6cGFyYW1zKTtcbiAgICAgICAgdmFyIG15VHJhbnMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB0cmFucyk7XG4gICAgICAgIHZhciBteUZvcmNlID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgZm9yY2V0b2dnbGUpO1xuICAgICAgICB2YXIgbXlQcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgcHJlcHJvY2Vzcyk7XG4gICAgICAgIHZhciBteUxvZyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGxvZ0FycmF5KTtcbiAgICAgICAgdmFyIG15SGlzdG9yeSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGNhbGxIaXN0b3J5KTtcblxuICAgICAgICBzcGFjZXNbbXlzcGFjZV0gPSB7XG4gICAgICAgICAgICBcImFsbE5vZGVzXCI6IG15Tm9kZXMsXG4gICAgICAgICAgICBcInpwYXJhbXNcIjogbXlQYXJhbXMsXG4gICAgICAgICAgICBcInRyYW5zXCI6IG15VHJhbnMsXG4gICAgICAgICAgICBcImZvcmNlXCI6IG15Rm9yY2UsXG4gICAgICAgICAgICBcInByZXByb2Nlc3NcIjogbXlQcmVwcm9jZXNzLFxuICAgICAgICAgICAgXCJsb2dBcnJheVwiOiBteUxvZyxcbiAgICAgICAgICAgIFwiY2FsbEhpc3RvcnlcIjogbXlIaXN0b3J5XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIHByZS1zdWJzZXQgc3ZnXG4gICAgICAgIHZhciBzZWxlY3RNZSA9IFwiI21cIi5jb25jYXQobXlzcGFjZSk7XG4gICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuYXR0cignY2xhc3MnLCAnaXRlbScpO1xuICAgICAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkucmVtb3ZlKCk7XG5cbiAgICAgICAgbXlzcGFjZSA9IHNwYWNlcy5sZW5ndGg7XG4gICAgICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgZnVuYzogXCJzdWJzZXRcIixcbiAgICAgICAgICAgIHp2YXJzOiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnp2YXJzKSxcbiAgICAgICAgICAgIHpzdWJzZXQ6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenN1YnNldCksXG4gICAgICAgICAgICB6cGxvdDogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56cGxvdClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIHRvIGdyYXkgb3V0IGFuZCByZW1vdmUgbGlzdGVuZXJzIGZvciB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gc3Vic2V0dGVkIG91dCBvZiB0aGUgZGF0YVxuICAgICAgICBmdW5jdGlvbiB2YXJPdXQodikge1xuICAgICAgICAgICAgLy8gaWYgaW4gbm9kZXMsIHJlbW92ZVxuICAgICAgICAgICAgLy8gZ3JheSBvdXQgaW4gbGVmdCBwYW5lbFxuICAgICAgICAgICAgLy8gbWFrZSB1bmNsaWNrYWJsZSBpbiBsZWZ0IHBhbmVsXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB2W2ldLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZWN0TWUpLnN0eWxlLmNvbG9yID0gaGV4VG9SZ2JhKGdyYXlDb2xvcik7XG4gICAgICAgICAgICAgICAgc2VsZWN0TWUgPSBcInAjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9nQXJyYXkucHVzaChcInN1YnNldDogXCIuY29uY2F0KHJDYWxsWzBdKSk7XG4gICAgICAgIHNob3dMb2coKTtcbiAgICAgICAgcmVXcml0ZUxvZygpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNpbm5lcmNhcm91c2VsXCIpXG4gICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0gYWN0aXZlJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm1cIi5jb25jYXQobXlzcGFjZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3doaXRlc3BhY2UnKTtcbiAgICAgICAgc3ZnID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIik7XG5cbiAgICAgICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlJbmRleCA9IGZpbmROb2RlSW5kZXgoa2V5KTtcblxuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R2YWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHR5cGUgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBhbGxOb2Rlc1tteUluZGV4XSwganNvbmRhdGFba2V5XSk7XG5cbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc3Vic2V0cmFuZ2UgPSBbXCJcIiwgXCJcIl07XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zZXR4dmFscyA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tteUluZGV4XS52YWxpZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXlPdXRzLnB1c2goYWxsTm9kZXNbbXlJbmRleF0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLmdyYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVQbG90KCk7XG4gICAgICAgICAgICBwb3B1bGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgIGxheW91dCh2ID0gXCJhZGRcIik7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyT3V0KGdyYXlPdXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJzZXRTZWxlY3RGYWlsKGJ0bikge1xuICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7IC8vc3RvcCBtb3Rpb25cbiAgICB9XG5cbiAgICBzZWxlY3RMYWRkYS5zdGFydCgpOyAvL3N0YXJ0IGJ1dHRvbiBtb3Rpb25cbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgYnRuLCBzdWJzZXRTZWxlY3RTdWNjZXNzLCBzdWJzZXRTZWxlY3RGYWlsLCBzb2xhanNvbm91dCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQcmVwcm9jZXNzKHVybCwgcCwgdiwgY2FsbGJhY2spIHtcbiAgICBjb25zb2xlLmxvZyh1cmwpO1xuICAgIGQzLmpzb24odXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW5zaWRlIHJlYWRQcmVwcm9jZXNzIGZ1bmN0aW9uXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhqc29uZGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGpzb25kYXRhW1widmFyaWFibGVzXCJdKTtcblxuICAgICAgICBpZiAoanNvbmRhdGEuZGF0YXNldC5wcml2KSB7XG4gICAgICAgICAgICBwcml2ID0ganNvbmRhdGFbXCJkYXRhc2V0XCJdW1wicHJpdlwiXTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL2NvcHlpbmcgdGhlIG9iamVjdFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGFbXCJ2YXJpYWJsZXNcIl0pIHtcbiAgICAgICAgICAgIHBba2V5XSA9IGpzb25kYXRhW1widmFyaWFibGVzXCJdW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWJvdXQoKSB7XG4gICAgJCgnI2Fib3V0Jykuc2hvdygpO1xufVxuXG5mdW5jdGlvbiBjbG9zZWFib3V0KCkge1xuICAgICQoJyNhYm91dCcpLmhpZGUoKTtcbn1cblxuZnVuY3Rpb24gb3BlbmNpdGUoKSB7XG4gICAgJCgnI2NpdGUnKS5zaG93KCk7XG59XG5cbmZ1bmN0aW9uIGNsb3NlY2l0ZSh0b2dnbGUpIHtcbiAgICBpZiAodG9nZ2xlID09IGZhbHNlKSB7XG4gICAgICAgICQoJyNjaXRlJykuaGlkZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2xpY2tjaXRlKHRvZ2dsZSkge1xuICAgIGlmICh0b2dnbGUgPT0gZmFsc2UpIHtcbiAgICAgICAgJCgnI2NpdGUnKS5zaG93KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyNjaXRlJykuaGlkZSgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBmdW5jdGlvbiB0byByZW1vdmUgYWxsIHRoZSBjaGlsZHJlbiBzdmdzIGluc2lkZSBzdWJzZXQgYW5kIHNldHggZGl2c1xuZnVuY3Rpb24gcmVQbG90KCkge1xuICAgIGQzLnNlbGVjdChcIiN0YWIyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgZDMuc2VsZWN0KFwiI3NldHhcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAvLyBtYWtlIHRoaXMgc21hcnRlclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWxsTm9kZXNbaV0uc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgYWxsTm9kZXNbaV0uc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hvd0xvZygpIHtcbiAgICBpZiAobG9nQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nZGl2Jykuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5OmJsb2NrXCIpO1xuICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgLmRhdGEobG9nQXJyYXkpXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2dkaXYnKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6bm9uZVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlV3JpdGVMb2coKSB7XG4gICAgZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLnJlbW92ZSgpO1xuICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKGxvZ0FycmF5KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG59XG5cbi8vIGFjdHMgYXMgaWYgdGhlIHVzZXIgY2xpY2tlZCBpbiB3aGl0ZXNwYWNlLiB1c2VmdWwgd2hlbiByZXN0YXJ0KCkgaXMgb3V0c2lkZSBvZiBzY29wZVxuZnVuY3Rpb24gZmFrZUNsaWNrKCkge1xuICAgIHZhciBteXdzID0gXCIjd2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAvLyBkMyBhbmQgcHJvZ3JhbW1hdGljIGV2ZW50cyBkb24ndCBtZXNoIHdlbGwsIGhlcmUncyBhIFNPIHdvcmthcm91bmQgdGhhdCBsb29rcyBnb29kIGJ1dCB1c2VzIGpxdWVyeS4uLlxuICAgIGpRdWVyeS5mbi5kM0NsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpLCBlKSB7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcIm1vdXNlZG93blwiLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblxuICAgICAgICAgICAgZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgJChteXdzKS5kM0NsaWNrKCk7XG5cbiAgICBkMy5zZWxlY3QobXl3cylcbiAgICAgICAgLmNsYXNzZWQoJ2FjdGl2ZScsIGZhbHNlKTsgLy8gcmVtb3ZlIGFjdGl2ZSBjbGFzc1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hcHBfZGRpLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFTQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBTkE7QUFPQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFHQTtBQUdBO0FBRUE7QUFHQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFDQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBV0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBU0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./Ladda/dist/ladda-themeless.min.css ***!
  \********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3M/MWY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!*****************!*\
  !*** ./app.css ***!
  \*****************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC5jc3M/N2YyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./bootstrap/css/bootstrap-theme.min.css ***!
  \***********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3M/OTBiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./~/mithril/mithril.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n\"use strict\"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== \"object\") return Vnode(\"#\", undefined, undefined, node === false ? \"\" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + \" \" + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\tif (typeof selector === \"string\") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== \"object\" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === \"string\") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode(\"[\", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error(\"Promise must be called with `new`\")\n\tif (typeof executor !== \"function\") throw new TypeError(\"executor must be a function\")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === \"object\" || typeof value === \"function\") && typeof (then = value.then) === \"function\") {\n\t\t\t\t\tif (value === self) throw new TypeError(\"Promise can't be resolved w/ itself\")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error(\"Possible unhandled promise rejection:\", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== \"function\") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === \"function\" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === \"object\" || typeof list[i] === \"function\") && typeof list[i].then === \"function\") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== \"undefined\") {\n\tif (typeof window.Promise === \"undefined\") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== \"undefined\") {\n\tif (typeof global.Promise === \"undefined\") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join(\"&\")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp(\"^file://\", \"i\")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === \"function\") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === \"string\") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = \"GET\"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === \"GET\" || args.method === \"TRACE\") ? false : (typeof args.useBody === \"boolean\" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== \"function\") args.serialize = typeof FormData !== \"undefined\" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== \"function\") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== \"function\") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === \"boolean\" ? args.async : true, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === \"function\") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || \"_mithril_\" + Math.round(Math.random() * 1e16) + \"_\" + callbackCount++\n\t\t\tvar script = $window.document.createElement(\"script\")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error(\"JSONP request failed\"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || \"callback\"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== \"\") {\n\t\t\tvar prefix = url.indexOf(\"?\") < 0 ? \"?\" : \"&\"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== \"\" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === \"function\") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase \"<\": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase \"[\": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}[match1[1]] || \"div\"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tswitch (vnode.tag) {\n\t\t\tcase \"svg\": ns = \"http://www.w3.org/2000/svg\"; break\n\t\t\tcase \"math\": ns = \"http://www.w3.org/1998/Math/MathML\"; break\n\t\t}\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== \"\") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, undefined, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tswitch (vnode.tag) {\n\t\t\tcase \"svg\": ns = \"http://www.w3.org/2000/svg\"; break\n\t\t\tcase \"math\": ns = \"http://www.w3.org/1998/Math/MathML\"; break\n\t\t}\n\t\tif (vnode.tag === \"textarea\") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== \"\") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === \"string\") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onremove === \"function\") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === \"key\" || key2 === \"is\" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== \"object\" || typeof value === \"undefined\" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(\":\")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === \"xlink\") {\n\t\t\telement.setAttributeNS(\"http://www.w3.org/1999/xlink\", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === \"o\" && key2[1] === \"n\" && typeof value === \"function\") updateEvent(vnode, key2, value)\n\t\telse if (key2 === \"style\") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\tif (vnode.tag === \"input\" && key2 === \"value\" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return\n\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\tif (vnode.tag === \"select\" && key2 === \"value\" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return\n\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\tif (vnode.tag === \"option\" && key2 === \"value\" && vnode.dom.value == value) return\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === \"input\" && key2 === \"type\") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tconsole.log(element, key2);\n\t\t\t\tif (value) element.setAttribute(key2, \"\")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === \"className\" ? \"class\" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === \"select\" && attrs2 != null) {\n\t\t\tif (\"value\" in attrs2) setAttr(vnode, \"value\", null, attrs2.value, undefined)\n\t\t\tif (\"selectedIndex\" in attrs2) setAttr(vnode, \"selectedIndex\", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === \"className\") key2 = \"class\"\n\t\t\t\t\tif (key2[0] === \"o\" && key2[1] === \"n\" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== \"key\") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === \"href\" || attr === \"list\" || attr === \"form\" || attr === \"width\" || attr === \"height\"// || attr === \"type\"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf(\"-\") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = \"\", old = null\n\t\tif (style == null) element.style.cssText = \"\"\n\t\telse if (typeof style === \"string\") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === \"string\") element.style.cssText = \"\"\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== \"string\") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== \"function\" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === \"function\" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeupdate === \"function\") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw !== false) redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== \"function\") throw new Error(\"m.mount(element, component) expects a component, not a vnode\")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\tvar entries = string.split(\"&\"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : \"\"\n\t\tif (value === \"true\") value = true\n\t\telse if (value === \"false\") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === \"function\"\n\tvar callAsync0 = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === \"pathname\" && data[0] !== \"/\") data = \"/\" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf(\"?\")\n\t\tvar hashIndex = path.indexOf(\"#\")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: \"#!\"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase \"#\": return normalize1(\"hash\").slice(router.prefix.length)\n\t\t\tcase \"?\": return normalize1(\"search\").slice(router.prefix.length) + normalize1(\"hash\")\n\t\t\tdefault: return normalize1(\"pathname\").slice(router.prefix.length) + normalize1(\"search\") + normalize1(\"hash\")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += \"?\" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += \"#\" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp(\"^\" + route0.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, \"\")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === \"#\") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error(\"Ensure the DOM element that was passed to `m.route` is not undefined\")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error(\"Could not resolve default route \" + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === \"function\") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, \"div\")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) options = {replace: true}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute(\"href\", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute(\"href\")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== \"undefined\" && typeof key3 !== \"undefined\") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = \"1.1.1\"\nm.vnode = Vnode\nif (true) module[\"exports\"] = m\nelse window.m = m\n}());\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../timers-browserify/main.js */ 9).setImmediate, __webpack_require__(/*! ./../webpack/buildin/global.js */ 0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWl0aHJpbC9taXRocmlsLmpzP2JkNDIiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIHVuZGVmaW5lZCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coZWxlbWVudCwga2V5Mik7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHQvLyBGaXJzdCB0aW1lMCByZW5kZXJpbmcgaW50byBhIG5vZGUgY2xlYXJzIGl0IG91dFxuXHRcdGlmIChkb20udm5vZGVzID09IG51bGwpIGRvbS50ZXh0Q29udGVudCA9IFwiXCJcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodm5vZGVzKSkgdm5vZGVzID0gW3Zub2Rlc11cblx0XHR1cGRhdGVOb2Rlcyhkb20sIGRvbS52bm9kZXMsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlcyksIGZhbHNlLCBob29rcywgbnVsbCwgdW5kZWZpbmVkKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgIT09IGZhbHNlKSByZWRyYXcoKVxuXHR9KVxuXHR2YXIgY2FsbGJhY2tzID0gW11cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKGtleTEsIGNhbGxiYWNrKSB7XG5cdFx0dW5zdWJzY3JpYmUoa2V5MSlcblx0XHRjYWxsYmFja3MucHVzaChrZXkxLCB0aHJvdHRsZShjYWxsYmFjaykpXG5cdH1cblx0ZnVuY3Rpb24gdW5zdWJzY3JpYmUoa2V5MSkge1xuXHRcdHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGtleTEpXG5cdFx0aWYgKGluZGV4ID4gLTEpIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDIpXG5cdH1cblx0ZnVuY3Rpb24gcmVkcmF3KCkge1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRjYWxsYmFja3NbaV0oKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4ge3N1YnNjcmliZTogc3Vic2NyaWJlLCB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUsIHJlZHJhdzogcmVkcmF3LCByZW5kZXI6IHJlbmRlclNlcnZpY2UucmVuZGVyfVxufVxudmFyIHJlZHJhd1NlcnZpY2UgPSBfMTEod2luZG93KVxucmVxdWVzdFNlcnZpY2Uuc2V0Q29tcGxldGlvbkNhbGxiYWNrKHJlZHJhd1NlcnZpY2UucmVkcmF3KVxudmFyIF8xNiA9IGZ1bmN0aW9uKHJlZHJhd1NlcnZpY2UwKSB7XG5cdHJldHVybiBmdW5jdGlvbihyb290LCBjb21wb25lbnQpIHtcblx0XHRpZiAoY29tcG9uZW50ID09PSBudWxsKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgW10pXG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC51bnN1YnNjcmliZShyb290KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChjb21wb25lbnQudmlldyA9PSBudWxsICYmIHR5cGVvZiBjb21wb25lbnQgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwibS5tb3VudChlbGVtZW50LCBjb21wb25lbnQpIGV4cGVjdHMgYSBjb21wb25lbnQsIG5vdCBhIHZub2RlXCIpXG5cdFx0XG5cdFx0dmFyIHJ1bjAgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBWbm9kZShjb21wb25lbnQpKVxuXHRcdH1cblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMClcblx0XHRyZWRyYXdTZXJ2aWNlMC5yZWRyYXcoKVxuXHR9XG59XG5tLm1vdW50ID0gXzE2KHJlZHJhd1NlcnZpY2UpXG52YXIgUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxudmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0aWYgKHN0cmluZyA9PT0gXCJcIiB8fCBzdHJpbmcgPT0gbnVsbCkgcmV0dXJuIHt9XG5cdGlmIChzdHJpbmcuY2hhckF0KDApID09PSBcIj9cIikgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDEpXG5cdHZhciBlbnRyaWVzID0gc3RyaW5nLnNwbGl0KFwiJlwiKSwgZGF0YTAgPSB7fSwgY291bnRlcnMgPSB7fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZW50cnkgPSBlbnRyaWVzW2ldLnNwbGl0KFwiPVwiKVxuXHRcdHZhciBrZXk1ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzBdKVxuXHRcdHZhciB2YWx1ZSA9IGVudHJ5Lmxlbmd0aCA9PT0gMiA/IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVsxXSkgOiBcIlwiXG5cdFx0aWYgKHZhbHVlID09PSBcInRydWVcIikgdmFsdWUgPSB0cnVlXG5cdFx0ZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikgdmFsdWUgPSBmYWxzZVxuXHRcdHZhciBsZXZlbHMgPSBrZXk1LnNwbGl0KC9cXF1cXFs/fFxcWy8pXG5cdFx0dmFyIGN1cnNvciA9IGRhdGEwXG5cdFx0aWYgKGtleTUuaW5kZXhPZihcIltcIikgPiAtMSkgbGV2ZWxzLnBvcCgpXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1tqXSwgbmV4dExldmVsID0gbGV2ZWxzW2ogKyAxXVxuXHRcdFx0dmFyIGlzTnVtYmVyID0gbmV4dExldmVsID09IFwiXCIgfHwgIWlzTmFOKHBhcnNlSW50KG5leHRMZXZlbCwgMTApKVxuXHRcdFx0dmFyIGlzVmFsdWUgPSBqID09PSBsZXZlbHMubGVuZ3RoIC0gMVxuXHRcdFx0aWYgKGxldmVsID09PSBcIlwiKSB7XG5cdFx0XHRcdHZhciBrZXk1ID0gbGV2ZWxzLnNsaWNlKDAsIGopLmpvaW4oKVxuXHRcdFx0XHRpZiAoY291bnRlcnNba2V5NV0gPT0gbnVsbCkgY291bnRlcnNba2V5NV0gPSAwXG5cdFx0XHRcdGxldmVsID0gY291bnRlcnNba2V5NV0rK1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnNvcltsZXZlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRjdXJzb3JbbGV2ZWxdID0gaXNWYWx1ZSA/IHZhbHVlIDogaXNOdW1iZXIgPyBbXSA6IHt9XG5cdFx0XHR9XG5cdFx0XHRjdXJzb3IgPSBjdXJzb3JbbGV2ZWxdXG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhMFxufVxudmFyIGNvcmVSb3V0ZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IHR5cGVvZiAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID09PSBcImZ1bmN0aW9uXCJcblx0dmFyIGNhbGxBc3luYzAgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZTEoZnJhZ21lbnQwKSB7XG5cdFx0dmFyIGRhdGEgPSAkd2luZG93LmxvY2F0aW9uW2ZyYWdtZW50MF0ucmVwbGFjZSgvKD86JVthLWY4OV1bYS1mMC05XSkrL2dpbSwgZGVjb2RlVVJJQ29tcG9uZW50KVxuXHRcdGlmIChmcmFnbWVudDAgPT09IFwicGF0aG5hbWVcIiAmJiBkYXRhWzBdICE9PSBcIi9cIikgZGF0YSA9IFwiL1wiICsgZGF0YVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0dmFyIGFzeW5jSWRcblx0ZnVuY3Rpb24gZGVib3VuY2VBc3luYyhjYWxsYmFjazApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoYXN5bmNJZCAhPSBudWxsKSByZXR1cm5cblx0XHRcdGFzeW5jSWQgPSBjYWxsQXN5bmMwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhc3luY0lkID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjazAoKVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpIHtcblx0XHR2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIilcblx0XHR2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKVxuXHRcdHZhciBwYXRoRW5kID0gcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgcXVlcnlFbmQgPSBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0XHR2YXIgcXVlcnlQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEsIHF1ZXJ5RW5kKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gcXVlcnlQYXJhbXMpIHF1ZXJ5RGF0YVtrZXk0XSA9IHF1ZXJ5UGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdGlmIChoYXNoSW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIGhhc2hQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UoaGFzaEluZGV4ICsgMSkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGhhc2hQYXJhbXMpIGhhc2hEYXRhW2tleTRdID0gaGFzaFBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aC5zbGljZSgwLCBwYXRoRW5kKVxuXHR9XG5cdHZhciByb3V0ZXIgPSB7cHJlZml4OiBcIiMhXCJ9XG5cdHJvdXRlci5nZXRQYXRoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR5cGUyID0gcm91dGVyLnByZWZpeC5jaGFyQXQoMClcblx0XHRzd2l0Y2ggKHR5cGUyKSB7XG5cdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gbm9ybWFsaXplMShcImhhc2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRjYXNlIFwiP1wiOiByZXR1cm4gbm9ybWFsaXplMShcInNlYXJjaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIG5vcm1hbGl6ZTEoXCJwYXRobmFtZVwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwic2VhcmNoXCIpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHR9XG5cdH1cblx0cm91dGVyLnNldFBhdGggPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0dmFyIHF1ZXJ5RGF0YSA9IHt9LCBoYXNoRGF0YSA9IHt9XG5cdFx0cGF0aCA9IHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKVxuXHRcdGlmIChkYXRhICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTQgaW4gZGF0YSkgcXVlcnlEYXRhW2tleTRdID0gZGF0YVtrZXk0XVxuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvOihbXlxcL10rKS9nLCBmdW5jdGlvbihtYXRjaDIsIHRva2VuKSB7XG5cdFx0XHRcdGRlbGV0ZSBxdWVyeURhdGFbdG9rZW5dXG5cdFx0XHRcdHJldHVybiBkYXRhW3Rva2VuXVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0dmFyIHF1ZXJ5ID0gYnVpbGRRdWVyeVN0cmluZyhxdWVyeURhdGEpXG5cdFx0aWYgKHF1ZXJ5KSBwYXRoICs9IFwiP1wiICsgcXVlcnlcblx0XHR2YXIgaGFzaCA9IGJ1aWxkUXVlcnlTdHJpbmcoaGFzaERhdGEpXG5cdFx0aWYgKGhhc2gpIHBhdGggKz0gXCIjXCIgKyBoYXNoXG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBvcHRpb25zID8gb3B0aW9ucy5zdGF0ZSA6IG51bGxcblx0XHRcdHZhciB0aXRsZSA9IG9wdGlvbnMgPyBvcHRpb25zLnRpdGxlIDogbnVsbFxuXHRcdFx0JHdpbmRvdy5vbnBvcHN0YXRlKClcblx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkgJHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdFx0ZWxzZSAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0fVxuXHRcdGVsc2UgJHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcm91dGVyLnByZWZpeCArIHBhdGhcblx0fVxuXHRyb3V0ZXIuZGVmaW5lUm91dGVzID0gZnVuY3Rpb24ocm91dGVzLCByZXNvbHZlLCByZWplY3QpIHtcblx0XHRmdW5jdGlvbiByZXNvbHZlUm91dGUoKSB7XG5cdFx0XHR2YXIgcGF0aCA9IHJvdXRlci5nZXRQYXRoKClcblx0XHRcdHZhciBwYXJhbXMgPSB7fVxuXHRcdFx0dmFyIHBhdGhuYW1lID0gcGFyc2VQYXRoKHBhdGgsIHBhcmFtcywgcGFyYW1zKVxuXHRcdFx0dmFyIHN0YXRlID0gJHdpbmRvdy5oaXN0b3J5LnN0YXRlXG5cdFx0XHRpZiAoc3RhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBrIGluIHN0YXRlKSBwYXJhbXNba10gPSBzdGF0ZVtrXVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgcm91dGUwIGluIHJvdXRlcykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoXCJeXCIgKyByb3V0ZTAucmVwbGFjZSgvOlteXFwvXSs/XFwuezN9L2csIFwiKC4qPylcIikucmVwbGFjZSgvOlteXFwvXSsvZywgXCIoW15cXFxcL10rKVwiKSArIFwiXFwvPyRcIilcblx0XHRcdFx0aWYgKG1hdGNoZXIudGVzdChwYXRobmFtZSkpIHtcblx0XHRcdFx0XHRwYXRobmFtZS5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGtleXMgPSByb3V0ZTAubWF0Y2goLzpbXlxcL10rL2cpIHx8IFtdXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEsIC0yKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHBhcmFtc1trZXlzW2ldLnJlcGxhY2UoLzp8XFwuL2csIFwiXCIpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaV0pXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJvdXRlc1tyb3V0ZTBdLCBwYXJhbXMsIHBhdGgsIHJvdXRlMClcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWplY3QocGF0aCwgcGFyYW1zKVxuXHRcdH1cblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpICR3aW5kb3cub25wb3BzdGF0ZSA9IGRlYm91bmNlQXN5bmMocmVzb2x2ZVJvdXRlKVxuXHRcdGVsc2UgaWYgKHJvdXRlci5wcmVmaXguY2hhckF0KDApID09PSBcIiNcIikgJHdpbmRvdy5vbmhhc2hjaGFuZ2UgPSByZXNvbHZlUm91dGVcblx0XHRyZXNvbHZlUm91dGUoKVxuXHR9XG5cdHJldHVybiByb3V0ZXJcbn1cbnZhciBfMjAgPSBmdW5jdGlvbigkd2luZG93LCByZWRyYXdTZXJ2aWNlMCkge1xuXHR2YXIgcm91dGVTZXJ2aWNlID0gY29yZVJvdXRlcigkd2luZG93KVxuXHR2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbih2KSB7cmV0dXJuIHZ9XG5cdHZhciByZW5kZXIxLCBjb21wb25lbnQsIGF0dHJzMywgY3VycmVudFBhdGgsIGxhc3RVcGRhdGVcblx0dmFyIHJvdXRlID0gZnVuY3Rpb24ocm9vdCwgZGVmYXVsdFJvdXRlLCByb3V0ZXMpIHtcblx0XHRpZiAocm9vdCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCB0byBgbS5yb3V0ZWAgaXMgbm90IHVuZGVmaW5lZFwiKVxuXHRcdHZhciBydW4xID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAocmVuZGVyMSAhPSBudWxsKSByZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgcmVuZGVyMShWbm9kZShjb21wb25lbnQsIGF0dHJzMy5rZXksIGF0dHJzMykpKVxuXHRcdH1cblx0XHR2YXIgYmFpbCA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdGlmIChwYXRoICE9PSBkZWZhdWx0Um91dGUpIHJvdXRlU2VydmljZS5zZXRQYXRoKGRlZmF1bHRSb3V0ZSwgbnVsbCwge3JlcGxhY2U6IHRydWV9KVxuXHRcdFx0ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBkZWZhdWx0IHJvdXRlIFwiICsgZGVmYXVsdFJvdXRlKVxuXHRcdH1cblx0XHRyb3V0ZVNlcnZpY2UuZGVmaW5lUm91dGVzKHJvdXRlcywgZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBwYXRoKSB7XG5cdFx0XHR2YXIgdXBkYXRlID0gbGFzdFVwZGF0ZSA9IGZ1bmN0aW9uKHJvdXRlUmVzb2x2ZXIsIGNvbXApIHtcblx0XHRcdFx0aWYgKHVwZGF0ZSAhPT0gbGFzdFVwZGF0ZSkgcmV0dXJuXG5cdFx0XHRcdGNvbXBvbmVudCA9IGNvbXAgIT0gbnVsbCAmJiAodHlwZW9mIGNvbXAudmlldyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBjb21wID09PSBcImZ1bmN0aW9uXCIpPyBjb21wIDogXCJkaXZcIlxuXHRcdFx0XHRhdHRyczMgPSBwYXJhbXMsIGN1cnJlbnRQYXRoID0gcGF0aCwgbGFzdFVwZGF0ZSA9IG51bGxcblx0XHRcdFx0cmVuZGVyMSA9IChyb3V0ZVJlc29sdmVyLnJlbmRlciB8fCBpZGVudGl0eSkuYmluZChyb3V0ZVJlc29sdmVyKVxuXHRcdFx0XHRydW4xKClcblx0XHRcdH1cblx0XHRcdGlmIChwYXlsb2FkLnZpZXcgfHwgdHlwZW9mIHBheWxvYWQgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlKHt9LCBwYXlsb2FkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChwYXlsb2FkLm9ubWF0Y2gpIHtcblx0XHRcdFx0XHRQcm9taXNlLnJlc29sdmUocGF5bG9hZC5vbm1hdGNoKHBhcmFtcywgcGF0aCkpLnRoZW4oZnVuY3Rpb24ocmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZShwYXlsb2FkLCByZXNvbHZlZClcblx0XHRcdFx0XHR9LCBiYWlsKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdXBkYXRlKHBheWxvYWQsIFwiZGl2XCIpXG5cdFx0XHR9XG5cdFx0fSwgYmFpbClcblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMSlcblx0fVxuXHRyb3V0ZS5zZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0aWYgKGxhc3RVcGRhdGUgIT0gbnVsbCkgb3B0aW9ucyA9IHtyZXBsYWNlOiB0cnVlfVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4xXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9taXRocmlsL21pdGhyaWwuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../bootstrap/css/bootstrap-theme.min.css */ 4);\n\n__webpack_require__(/*! ../app.css */ 3);\n\n__webpack_require__(/*! ../Ladda/dist/ladda-themeless.min.css */ 2);\n\nvar _mithril = __webpack_require__(/*! mithril */ 5);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app_ddi = __webpack_require__(/*! ./app_ddi.js */ 1);\n\nvar _app_ddi2 = _interopRequireDefault(_app_ddi);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction leftpanel() {\n    return (0, _mithril2.default)(\".sidepanel.container.clearfix[id='leftpanel']\", [(0, _mithril2.default)(\".panelbar[id='toggleLpanelicon']\", (0, _mithril2.default)(\"span\", [_mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\")])), (0, _mithril2.default)(\".panel-heading.text-center[id='leftpaneltitle']\", (0, _mithril2.default)(\"h3.panel-title\", \"Data Selection\")), (0, _mithril2.default)(\".btn-toolbar[role='toolbar']\", {\n        style: {\n            \"margin-left\": \".5em\",\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\".btn-group\", {\n        style: {\n            \"margin-left\": \"0\"\n        }\n    }, [(0, _mithril2.default)(\"button.btn.active[id='btnVariables'][onclick='tabLeft(\\'tab1\\');'][title='Click variable name to add or remove the variable pebble from the modeling space.'][type='button']\", \"Variables\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnSubset'][onclick='tabLeft(\\'tab2\\');'][type='button']\", \"Subset\")]), (0, _mithril2.default)(\"button.btn.btn-default.ladda-button[data-spinner-color='#000000'][data-style='zoom-in'][id='btnSelect'][onclick='subsetSelect(\\'btnSelect\\');'][title='Subset data by the intersection of all selected values.'][type='button']\", {\n        style: {\n            \"display\": \"none\",\n            \"float\": \"right\",\n            \"margin-right\": \"10px\"\n        }\n    }, (0, _mithril2.default)(\"span.ladda-label\", {\n        style: {\n            \"pointer-events\": \"none\"\n        }\n    }, \"Select\"))]), (0, _mithril2.default)(\".row-fluid\", (0, _mithril2.default)(\"[id='leftpanelcontent']\", (0, _mithril2.default)(\"[id='leftContentArea']\", {\n        style: {\n            \"overflow\": \"scroll\",\n            \"height\": \"488px\"\n        }\n    }, [(0, _mithril2.default)(\"[id='tab1']\", {\n        style: {\n            \"display\": \"block\",\n            \"padding\": \"6px 12px\",\n            \"text-align\": \"center\"\n        }\n    }), (0, _mithril2.default)(\"[id='tab2']\", {\n        style: {\n            \"display\": \"none\",\n            \"margin-top\": \".5em\"\n        }\n    }), (0, _mithril2.default)(\"[id='tab3']\", (0, _mithril2.default)(\"p\", {\n        style: {\n            \"padding\": \".5em 1em\"\n        }\n    }, \"Select a variable from within the visualization in the center panel to view its summary statistics.\"))])))]);\n}\n\nfunction rightpanel() {\n    return (0, _mithril2.default)(\".sidepanel.container.clearfix[id='rightpanel']\", [(0, _mithril2.default)(\".panelbar[id='toggleRpanelicon']\", (0, _mithril2.default)(\"span\", [_mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\")])), (0, _mithril2.default)(\".panel-heading.text-center[id='rightpaneltitle']\", (0, _mithril2.default)(\"h3.panel-title\", \"Model Selection\")), (0, _mithril2.default)(\".btn-group.btn-group-justified[aria-label='...'][role='group']\", {\n        style: {\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\"button.btn.active[id='btnModels'][onclick='tabRight(\\'btnModels\\');'][type='button']\", {\n        style: {\n            \"width\": \"33%\"\n        }\n    }, \"Models\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnSetx'][onclick='tabRight(\\'btnSetx\\');'][type='button']\", {\n        style: {\n            \"width\": \"34%\"\n        }\n    }, \"Set Covar.\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnResults'][onclick='tabRight(\\'btnResults\\');'][type='button']\", {\n        style: {\n            \"width\": \"33%\"\n        }\n    }, \"Results\")]), (0, _mithril2.default)(\".row-fluid\", (0, _mithril2.default)(\"[id='rightpanelcontent']\", (0, _mithril2.default)(\"[id='rightContentArea']\", {\n        style: {\n            \"overflow\": \"scroll\",\n            \"height\": \"488px\"\n        }\n    }, [(0, _mithril2.default)(\"[id='results']\", {\n        style: {\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\".container[id='resultsView']\", {\n        style: {\n            \"width\": \"80%\",\n            \"background-color\": \"white\",\n            \"display\": \"none\",\n            \"float\": \"right\",\n            \"overflow\": \"auto\",\n            \"white-space\": \"nowrap\"\n        }\n    }), (0, _mithril2.default)(\"[id='modelView']\", {\n        style: {\n            \"width\": \"20%\",\n            \"background-color\": \"white\",\n            \"display\": \"none\",\n            \"float\": \"left\"\n        }\n    }), (0, _mithril2.default)(\"p[id='resultsHolder']\", {\n        style: {\n            \"padding\": \".5em 1em\"\n        }\n    })]), (0, _mithril2.default)(\"[id='setx']\", {\n        style: {\n            \"display\": \"none\"\n        }\n    }), (0, _mithril2.default)(\"[id='models']\", {\n        style: {\n            \"display\": \"block\",\n            \"padding\": \"6px 12px\",\n            \"text-align\": \"center\"\n        }\n    })])))]);\n}\n\nvar fileid = \"\";\nvar hostname = \"\";\nvar apikey = \"\";\nvar ddiurl = \"\";\nvar dataurl = \"\";\n\nvar Body = function () {\n    function Body() {\n        _classCallCheck(this, Body);\n    }\n\n    _createClass(Body, [{\n        key: 'oncreate',\n        value: function oncreate() {\n            $('#leftpanel span').click(function () {\n                if (!$('#leftpanel').hasClass('forceclosepanel')) {\n                    $('#leftpanel').removeClass('expandpanel');\n                    $('#leftpanel > div.row-fluid').toggleClass('closepanel');\n                    $('#leftpanel').toggleClass('closepanel');\n                    $('#main').toggleClass('svg-leftpanel');\n                    $('#btnSelect').css('display', 'none');\n                }\n            });\n            $('#rightpanel span').click(function () {\n                if (!$('#leftpanel').hasClass('forceclosepanel')) {\n                    $('#rightpanel').removeClass('expandpanel');\n                    $('#rightpanel > div.row-fluid').toggleClass('closepanel');\n                    $('#rightpanel').toggleClass('closepanel');\n                    $('#main').toggleClass('svg-rightpanel');\n                }\n            });\n\n            var myurl = window.location.toString();\n            var cindex = 0;\n            if (myurl.indexOf(\"dfId=\") > 0) {\n                fileid = myurl.substring(myurl.indexOf(\"dfId=\") + 5);\n                cindex = fileid.indexOf(\"&\");\n                if (cindex > 0) {\n                    fileid = fileid.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"host=\") > 0) {\n                hostname = myurl.substring(myurl.indexOf(\"host=\") + 5);\n                cindex = hostname.indexOf(\"&\");\n                if (cindex > 0) {\n                    hostname = hostname.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"key=\") > 0) {\n                apikey = myurl.substring(myurl.indexOf(\"key=\") + 4);\n                cindex = apikey.indexOf(\"&\");\n                if (cindex > 0) {\n                    apikey = apikey.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"ddiurl=\") > 0) {\n                ddiurl = myurl.substring(myurl.indexOf(\"ddiurl=\") + 7);\n                ddiurl = ddiurl.replace(/%25/g, \"%\");\n                ddiurl = ddiurl.replace(/%3A/g, \":\");\n                ddiurl = ddiurl.replace(/%2F/g, \"/\");\n                cindex = ddiurl.indexOf(\"&\");\n                if (cindex > 0) {\n                    ddiurl = ddiurl.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"dataurl=\") > 0) {\n                dataurl = myurl.substring(myurl.indexOf(\"dataurl=\") + 8);\n                dataurl = dataurl.replace(/%25/g, \"%\");\n                dataurl = dataurl.replace(/%3A/g, \":\");\n                dataurl = dataurl.replace(/%2F/g, \"/\");\n                cindex = dataurl.indexOf(\"&\");\n                if (cindex > 0) {\n                    dataurl = dataurl.substring(0, cindex);\n                };\n            };\n\n            console.log(\"fileid: \" + fileid);\n            console.log(\"hostname: \" + hostname);\n            console.log(\"apikey: \" + apikey);\n            console.log(\"ddiurl: \" + ddiurl);\n            console.log(\"dataurl: \" + dataurl);\n\n            (0, _app_ddi2.default)(fileid, hostname, ddiurl, dataurl);\n        }\n    }, {\n        key: 'view',\n        value: function view() {\n            return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav.navbar.navbar-default[id='option'][role='navigation']\", (0, _mithril2.default)(\"div\", [(0, _mithril2.default)(\".navbar-header[id='navbarheader']\", [(0, _mithril2.default)(\"img[alt='TwoRavens'][onmouseout='closeabout();'][onmouseover='about();'][src='images/TwoRavens.png'][width='100']\", {\n                style: {\n                    \"margin-left\": \"2em\",\n                    \"margin-top\": \"-0.5em\"\n                }\n            }), (0, _mithril2.default)(\".panel.panel-default[id='about']\", {\n                style: {\n                    \"position\": \"absolute\",\n                    \"left\": \"140px\",\n                    \"width\": \"380px\",\n                    \"display\": \"none\",\n                    \"z-index\": \"50\"\n                }\n            }, (0, _mithril2.default)(\".panel-body\"))]), (0, _mithril2.default)(\".field[id='dataField']\", {\n                style: {\n                    \"text-align\": \"center\",\n                    \"margin-top\": \"0.5em\"\n                }\n            }, [(0, _mithril2.default)(\"h4[id='dataName'][onclick='citetoggle=clickcite(citetoggle);'][onmouseout='closecite(citetoggle);'][onmouseover='opencite();']\", {\n                style: {\n                    \"display\": \"inline\"\n                }\n            }, \"Dataset Name\"), (0, _mithril2.default)(\".panel.panel-default[id='cite']\", {\n                style: {\n                    \"position\": \"absolute\",\n                    \"right\": \"50%\",\n                    \"width\": \"380px\",\n                    \"display\": \"none\",\n                    \"z-index\": \"50\",\n                    \"text-align\": \"left\"\n                }\n            }, (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)(\"button.btn.btn-default.ladda-button.navbar-right[data-spinner-color='#000000'][data-style='zoom-in'][id='btnEstimate'][onclick='estimate(\\'btnEstimate\\')']\", {\n                style: {\n                    \"margin-left\": \"2em\",\n                    \"margin-right\": \"1em\"\n                }\n            }, (0, _mithril2.default)(\"span.ladda-label\", \"Estimate\")), (0, _mithril2.default)(\"button.btn.btn-default.navbar-right[id='btnReset'][onclick='reset()'][title='Reset']\", {\n                style: {\n                    \"margin-left\": \"2.0em\"\n                }\n            }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-repeat\", {\n                style: {\n                    \"font-size\": \"1em\",\n                    \"color\": \"#818181\",\n                    \"pointer-events\": \"none\"\n                }\n            })), (0, _mithril2.default)(\".transformTool[id='transformations'][title='Construct transformations of existing variables using valid R syntax. For example, assuming a variable named d, you could enter \\'log(d)\\' or \\'d^2\\'.']\")])])), (0, _mithril2.default)(\".left.svg-leftpanel.svg-rightpanel.carousel.slide[id='main']\", [(0, _mithril2.default)(\".carousel-inner\"), (0, _mithril2.default)(\".spaceTool[id='spacetools']\", {\n                style: {\n                    \"z-index\": \"16\"\n                }\n            }, [(0, _mithril2.default)(\"button.btn.btn-default[id='btnForce'][onclick='forceSwitch()'][title='Pin the variable pebbles to the page.']\", (0, _mithril2.default)(\"span.glyphicon.glyphicon-pushpin\")), (0, _mithril2.default)(\"button.btn.btn-default[id='btnEraser'][onclick='erase()'][title='Wipe all variables from the modeling space.']\", (0, _mithril2.default)(\"span.glyphicon.glyphicon-magnet\"))]), (0, _mithril2.default)(\".legendary.panel.panel-default[id='legend']\", {\n                style: {\n                    \"display\": \"none\"\n                }\n            }, [(0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", [\"Legend  \", (0, _mithril2.default)(\"span.glyphicon.glyphicon-large.glyphicon-chevron-down.pull-right[data-target='#collapseLegend'][data-toggle='collapse'][href='#collapseLegend'][onclick='$(this).toggleClass(\\'glyphicon-chevron-up\\').toggleClass(\\'glyphicon-chevron-down\\');']\", {\n                style: _defineProperty({\n                    \"cursor\": \"pointer\"\n                }, 'cursor', \"hand\")\n            })])), (0, _mithril2.default)(\".panel-collapse.collapse.in[id='collapseLegend']\", (0, _mithril2.default)(\".panel-body\", [(0, _mithril2.default)(\".clearfix.hide[id='timeButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Time\")]), (0, _mithril2.default)(\".clearfix.hide[id='csButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Cross Sec\")]), (0, _mithril2.default)(\".clearfix.hide[id='dvButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Dep Var\")]), (0, _mithril2.default)(\".clearfix.hide[id='nomButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Nom Var\")])]))]), (0, _mithril2.default)(\".logbox.panel.panel-default[id='logdiv']\", {\n                style: {\n                    \"display\": \"none\"\n                }\n            }, [(0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", [\"History \", (0, _mithril2.default)(\"span.glyphicon.glyphicon-large.glyphicon-chevron-down.pull-right[data-target='#collapseLog'][data-toggle='collapse'][href='#collapseLog'][id='logicon'][onclick='$(this).toggleClass(\\'glyphicon-chevron-down\\').toggleClass(\\'glyphicon-chevron-up\\');']\", {\n                style: _defineProperty({\n                    \"cursor\": \"pointer\"\n                }, 'cursor', \"hand\")\n            })])), (0, _mithril2.default)(\".panel-collapse.collapse.in[id='collapseLog']\", (0, _mithril2.default)(\".panel-body\"))]), (0, _mithril2.default)(\"[id='ticker']\", {\n                style: {\n                    \"position\": \"fixed\",\n                    \"height\": \"50px\",\n                    \"width\": \"100%\",\n                    \"background\": \"#F9F9F9\",\n                    \"bottom\": \"0\"\n                }\n            }, (0, _mithril2.default)(\"a[href='somelink'][id='logID'][target='_blank']\", \"Replication\")), leftpanel(), rightpanel()]));\n        }\n    }]);\n\n    return Body;\n}();\n\n_mithril2.default.mount(document.body, Body);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi9hcHAuY3NzJztcbmltcG9ydCAnLi4vTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzcyc7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgbWFpbiBmcm9tICcuL2FwcF9kZGkuanMnO1xuXG5mdW5jdGlvbiBsZWZ0cGFuZWwoKSB7XG4gICAgcmV0dXJuIG0oXCIuc2lkZXBhbmVsLmNvbnRhaW5lci5jbGVhcmZpeFtpZD0nbGVmdHBhbmVsJ11cIiwgW1xuICAgICAgICBtKFwiLnBhbmVsYmFyW2lkPSd0b2dnbGVMcGFuZWxpY29uJ11cIixcbiAgICAgICAgICAgIG0oXCJzcGFuXCIsIFtcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKSxcbiAgICAgICAgICAgICAgICBtKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIiksXG4gICAgICAgICAgICAgICAgbShcImJyXCIpLFxuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpLFxuICAgICAgICAgICAgICAgIG0oXCJiclwiKSxcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgKSxcbiAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nLnRleHQtY2VudGVyW2lkPSdsZWZ0cGFuZWx0aXRsZSddXCIsXG4gICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICBcIkRhdGEgU2VsZWN0aW9uXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgbShcIi5idG4tdG9vbGJhcltyb2xlPSd0b29sYmFyJ11cIiwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiLjVlbVwiLFxuICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcFwiOiBcIi41ZW1cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBtKFwiLmJ0bi1ncm91cFwiLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjBcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5hY3RpdmVbaWQ9J2J0blZhcmlhYmxlcyddW29uY2xpY2s9J3RhYkxlZnQoXFwndGFiMVxcJyk7J11bdGl0bGU9J0NsaWNrIHZhcmlhYmxlIG5hbWUgdG8gYWRkIG9yIHJlbW92ZSB0aGUgdmFyaWFibGUgcGViYmxlIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlLiddW3R5cGU9J2J1dHRvbiddXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVmFyaWFibGVzXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0W2lkPSdidG5TdWJzZXQnXVtvbmNsaWNrPSd0YWJMZWZ0KFxcJ3RhYjJcXCcpOyddW3R5cGU9J2J1dHRvbiddXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiU3Vic2V0XCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbltkYXRhLXNwaW5uZXItY29sb3I9JyMwMDAwMDAnXVtkYXRhLXN0eWxlPSd6b29tLWluJ11baWQ9J2J0blNlbGVjdCddW29uY2xpY2s9J3N1YnNldFNlbGVjdChcXCdidG5TZWxlY3RcXCcpOyddW3RpdGxlPSdTdWJzZXQgZGF0YSBieSB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCBzZWxlY3RlZCB2YWx1ZXMuJ11bdHlwZT0nYnV0dG9uJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmbG9hdFwiOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIjEwcHhcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtKFwic3Bhbi5sYWRkYS1sYWJlbFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJTZWxlY3RcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgXSksXG4gICAgICAgIG0oXCIucm93LWZsdWlkXCIsXG4gICAgICAgICAgICBtKFwiW2lkPSdsZWZ0cGFuZWxjb250ZW50J11cIixcbiAgICAgICAgICAgICAgICBtKFwiW2lkPSdsZWZ0Q29udGVudEFyZWEnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJmbG93XCI6IFwic2Nyb2xsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjQ4OHB4XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcIltpZD0ndGFiMSddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmdcIjogXCI2cHggMTJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dC1hbGlnblwiOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSd0YWIyJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiLjVlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sICksXG4gICAgICAgICAgICAgICAgICAgIG0oXCJbaWQ9J3RhYjMnXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcInBcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nXCI6IFwiLjVlbSAxZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNlbGVjdCBhIHZhcmlhYmxlIGZyb20gd2l0aGluIHRoZSB2aXN1YWxpemF0aW9uIGluIHRoZSBjZW50ZXIgcGFuZWwgdG8gdmlldyBpdHMgc3VtbWFyeSBzdGF0aXN0aWNzLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIHJpZ2h0cGFuZWwoKSB7XG4gICAgcmV0dXJuIG0oXCIuc2lkZXBhbmVsLmNvbnRhaW5lci5jbGVhcmZpeFtpZD0ncmlnaHRwYW5lbCddXCIsIFtcbiAgICAgICAgbShcIi5wYW5lbGJhcltpZD0ndG9nZ2xlUnBhbmVsaWNvbiddXCIsXG4gICAgICAgICAgICBtKFwic3BhblwiLCBbXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIiksXG4gICAgICAgICAgICAgICAgbShcImJyXCIpLFxuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpLFxuICAgICAgICAgICAgICAgIG0oXCJiclwiKSxcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKSxcbiAgICAgICAgICAgICAgICBtKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICksXG4gICAgICAgIG0oXCIucGFuZWwtaGVhZGluZy50ZXh0LWNlbnRlcltpZD0ncmlnaHRwYW5lbHRpdGxlJ11cIixcbiAgICAgICAgICAgIG0oXCJoMy5wYW5lbC10aXRsZVwiLFxuICAgICAgICAgICAgICAgIFwiTW9kZWwgU2VsZWN0aW9uXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgbShcIi5idG4tZ3JvdXAuYnRuLWdyb3VwLWp1c3RpZmllZFthcmlhLWxhYmVsPScuLi4nXVtyb2xlPSdncm91cCddXCIsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiLjVlbVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmFjdGl2ZVtpZD0nYnRuTW9kZWxzJ11bb25jbGljaz0ndGFiUmlnaHQoXFwnYnRuTW9kZWxzXFwnKTsnXVt0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMzMlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJNb2RlbHNcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0W2lkPSdidG5TZXR4J11bb25jbGljaz0ndGFiUmlnaHQoXFwnYnRuU2V0eFxcJyk7J11bdHlwZT0nYnV0dG9uJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjM0JVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiU2V0IENvdmFyLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHRbaWQ9J2J0blJlc3VsdHMnXVtvbmNsaWNrPSd0YWJSaWdodChcXCdidG5SZXN1bHRzXFwnKTsnXVt0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMzMlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJSZXN1bHRzXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgXSksXG4gICAgICAgIG0oXCIucm93LWZsdWlkXCIsXG4gICAgICAgICAgICBtKFwiW2lkPSdyaWdodHBhbmVsY29udGVudCddXCIsXG4gICAgICAgICAgICAgICAgbShcIltpZD0ncmlnaHRDb250ZW50QXJlYSddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiNDg4cHhcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSdyZXN1bHRzJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIuNWVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5jb250YWluZXJbaWQ9J3Jlc3VsdHNWaWV3J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCI4MCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsb2F0XCI6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyZmxvd1wiOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSdtb2RlbFZpZXcnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjIwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxvYXRcIjogXCJsZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJwW2lkPSdyZXN1bHRzSG9sZGVyJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZ1wiOiBcIi41ZW0gMWVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgbShcIltpZD0nc2V0eCddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSdtb2RlbHMnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nXCI6IFwiNnB4IDEycHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICBdKTtcbn1cblxubGV0IGZpbGVpZCA9IFwiXCI7XG5sZXQgaG9zdG5hbWUgPSBcIlwiO1xubGV0IGFwaWtleSA9IFwiXCI7XG5sZXQgZGRpdXJsID0gXCJcIjtcbmxldCBkYXRhdXJsID0gXCJcIjtcblxuY2xhc3MgQm9keSB7XG4gICAgb25jcmVhdGUoKSB7XG4gICAgICAgICQoJyNsZWZ0cGFuZWwgc3BhbicpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCEkKCcjbGVmdHBhbmVsJykuaGFzQ2xhc3MoJ2ZvcmNlY2xvc2VwYW5lbCcpKSB7XG4gICAgICAgICAgICAgICAgJCgnI2xlZnRwYW5lbCcpLnJlbW92ZUNsYXNzKCdleHBhbmRwYW5lbCcpO1xuICAgICAgICAgICAgICAgICQoJyNsZWZ0cGFuZWwgPiBkaXYucm93LWZsdWlkJykudG9nZ2xlQ2xhc3MoJ2Nsb3NlcGFuZWwnKTtcbiAgICAgICAgICAgICAgICAkKCcjbGVmdHBhbmVsJykudG9nZ2xlQ2xhc3MoJ2Nsb3NlcGFuZWwnKTtcbiAgICAgICAgICAgICAgICAkKCcjbWFpbicpLnRvZ2dsZUNsYXNzKCdzdmctbGVmdHBhbmVsJyk7XG4gICAgICAgICAgICAgICAgJCgnI2J0blNlbGVjdCcpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkKCcjcmlnaHRwYW5lbCBzcGFuJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoISQoJyNsZWZ0cGFuZWwnKS5oYXNDbGFzcygnZm9yY2VjbG9zZXBhbmVsJykpIHtcbiAgICAgICAgICAgICAgICAkKCcjcmlnaHRwYW5lbCcpLnJlbW92ZUNsYXNzKCdleHBhbmRwYW5lbCcpO1xuICAgICAgICAgICAgICAgICQoJyNyaWdodHBhbmVsID4gZGl2LnJvdy1mbHVpZCcpLnRvZ2dsZUNsYXNzKCdjbG9zZXBhbmVsJyk7XG4gICAgICAgICAgICAgICAgJCgnI3JpZ2h0cGFuZWwnKS50b2dnbGVDbGFzcygnY2xvc2VwYW5lbCcpO1xuICAgICAgICAgICAgICAgICQoJyNtYWluJykudG9nZ2xlQ2xhc3MoJ3N2Zy1yaWdodHBhbmVsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBteXVybCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2luZGV4ID0gMDtcbiAgICAgICAgaWYgKG15dXJsLmluZGV4T2YoXCJkZklkPVwiKSA+IDApIHtcbiAgICAgICAgICAgIGZpbGVpZCA9IG15dXJsLnN1YnN0cmluZyhteXVybC5pbmRleE9mKFwiZGZJZD1cIikgKyA1KTtcbiAgICAgICAgICAgIGNpbmRleCA9IGZpbGVpZC5pbmRleE9mKFwiJlwiKTtcbiAgICAgICAgICAgIGlmIChjaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlsZWlkID0gZmlsZWlkLnN1YnN0cmluZygwLCBjaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG15dXJsLmluZGV4T2YoXCJob3N0PVwiKSA+IDApIHtcbiAgICAgICAgICAgIGhvc3RuYW1lID0gbXl1cmwuc3Vic3RyaW5nKG15dXJsLmluZGV4T2YoXCJob3N0PVwiKSArIDUpO1xuICAgICAgICAgICAgY2luZGV4ID0gaG9zdG5hbWUuaW5kZXhPZihcIiZcIik7XG4gICAgICAgICAgICBpZiAoY2luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGhvc3RuYW1lID0gaG9zdG5hbWUuc3Vic3RyaW5nKDAsIGNpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAobXl1cmwuaW5kZXhPZihcImtleT1cIikgPiAwKSB7XG4gICAgICAgICAgICBhcGlrZXkgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImtleT1cIikgKyA0KTtcbiAgICAgICAgICAgIGNpbmRleCA9IGFwaWtleS5pbmRleE9mKFwiJlwiKTtcbiAgICAgICAgICAgIGlmIChjaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgYXBpa2V5ID0gYXBpa2V5LnN1YnN0cmluZygwLCBjaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcdFx0XG4gICAgICAgIGlmIChteXVybC5pbmRleE9mKFwiZGRpdXJsPVwiKSA+IDApIHtcbiAgICAgICAgICAgIGRkaXVybCA9IG15dXJsLnN1YnN0cmluZyhteXVybC5pbmRleE9mKFwiZGRpdXJsPVwiKSArIDcpO1xuICAgICAgICAgICAgZGRpdXJsID0gZGRpdXJsLnJlcGxhY2UoLyUyNS9nLCBcIiVcIik7XG4gICAgICAgICAgICBkZGl1cmwgPSBkZGl1cmwucmVwbGFjZSgvJTNBL2csIFwiOlwiKTtcbiAgICAgICAgICAgIGRkaXVybCA9IGRkaXVybC5yZXBsYWNlKC8lMkYvZywgXCIvXCIpO1xuICAgICAgICAgICAgY2luZGV4ID0gZGRpdXJsLmluZGV4T2YoXCImXCIpO1xuICAgICAgICAgICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBkZGl1cmwgPSBkZGl1cmwuc3Vic3RyaW5nKDAsIGNpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1x0XHRcbiAgICAgICAgaWYgKG15dXJsLmluZGV4T2YoXCJkYXRhdXJsPVwiKSA+IDApIHtcbiAgICAgICAgICAgIGRhdGF1cmwgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImRhdGF1cmw9XCIpICsgOCk7XG4gICAgICAgICAgICBkYXRhdXJsID0gZGF0YXVybC5yZXBsYWNlKC8lMjUvZywgXCIlXCIpO1xuICAgICAgICAgICAgZGF0YXVybCA9IGRhdGF1cmwucmVwbGFjZSgvJTNBL2csIFwiOlwiKTtcbiAgICAgICAgICAgIGRhdGF1cmwgPSBkYXRhdXJsLnJlcGxhY2UoLyUyRi9nLCBcIi9cIik7XG4gICAgICAgICAgICBjaW5kZXggPSBkYXRhdXJsLmluZGV4T2YoXCImXCIpO1xuICAgICAgICAgICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhdXJsID0gZGF0YXVybC5zdWJzdHJpbmcoMCwgY2luZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJmaWxlaWQ6IFwiICsgZmlsZWlkKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJob3N0bmFtZTogXCIgKyBob3N0bmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYXBpa2V5OiBcIiArIGFwaWtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZGRpdXJsOiBcIiArIGRkaXVybCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZGF0YXVybDogXCIgKyBkYXRhdXJsKTtcbiAgICBcblx0XHRtYWluKGZpbGVpZCwgaG9zdG5hbWUsIGRkaXVybCwgZGF0YXVybCk7XHRcblx0fVxuXG4gICAgdmlldygpIHtcbiAgICAgICAgcmV0dXJuIG0oJ21haW4nLFxuICAgICAgICAgICAgbShcIm5hdi5uYXZiYXIubmF2YmFyLWRlZmF1bHRbaWQ9J29wdGlvbiddW3JvbGU9J25hdmlnYXRpb24nXVwiLFxuICAgICAgICAgICAgICAgIG0oXCJkaXZcIiwgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiLm5hdmJhci1oZWFkZXJbaWQ9J25hdmJhcmhlYWRlciddXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJpbWdbYWx0PSdUd29SYXZlbnMnXVtvbm1vdXNlb3V0PSdjbG9zZWFib3V0KCk7J11bb25tb3VzZW92ZXI9J2Fib3V0KCk7J11bc3JjPSdpbWFnZXMvVHdvUmF2ZW5zLnBuZyddW3dpZHRoPScxMDAnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCItMC41ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC5wYW5lbC1kZWZhdWx0W2lkPSdhYm91dCddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCI6IFwiMTQwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIzODBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ6LWluZGV4XCI6IFwiNTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgbShcIi5maWVsZFtpZD0nZGF0YUZpZWxkJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIwLjVlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJoNFtpZD0nZGF0YU5hbWUnXVtvbmNsaWNrPSdjaXRldG9nZ2xlPWNsaWNrY2l0ZShjaXRldG9nZ2xlKTsnXVtvbm1vdXNlb3V0PSdjbG9zZWNpdGUoY2l0ZXRvZ2dsZSk7J11bb25tb3VzZW92ZXI9J29wZW5jaXRlKCk7J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiaW5saW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEYXRhc2V0IE5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwucGFuZWwtZGVmYXVsdFtpZD0nY2l0ZSddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyaWdodFwiOiBcIjUwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjM4MHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInotaW5kZXhcIjogXCI1MFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwibGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtYm9keVwiLCApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uLm5hdmJhci1yaWdodFtkYXRhLXNwaW5uZXItY29sb3I9JyMwMDAwMDAnXVtkYXRhLXN0eWxlPSd6b29tLWluJ11baWQ9J2J0bkVzdGltYXRlJ11bb25jbGljaz0nZXN0aW1hdGUoXFwnYnRuRXN0aW1hdGVcXCcpJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tcmlnaHRcIjogXCIxZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5sYWRkYS1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVzdGltYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQubmF2YmFyLXJpZ2h0W2lkPSdidG5SZXNldCddW29uY2xpY2s9J3Jlc2V0KCknXVt0aXRsZT0nUmVzZXQnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiMi4wZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLXJlcGVhdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjFlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcIiM4MTgxODFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi50cmFuc2Zvcm1Ub29sW2lkPSd0cmFuc2Zvcm1hdGlvbnMnXVt0aXRsZT0nQ29uc3RydWN0IHRyYW5zZm9ybWF0aW9ucyBvZiBleGlzdGluZyB2YXJpYWJsZXMgdXNpbmcgdmFsaWQgUiBzeW50YXguIEZvciBleGFtcGxlLCBhc3N1bWluZyBhIHZhcmlhYmxlIG5hbWVkIGQsIHlvdSBjb3VsZCBlbnRlciBcXCdsb2coZClcXCcgb3IgXFwnZF4yXFwnLiddXCIsIClcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG0oXCIubGVmdC5zdmctbGVmdHBhbmVsLnN2Zy1yaWdodHBhbmVsLmNhcm91c2VsLnNsaWRlW2lkPSdtYWluJ11cIiwgW1xuICAgICAgICAgICAgICAgIG0oXCIuY2Fyb3VzZWwtaW5uZXJcIiwgKSxcbiAgICAgICAgICAgICAgICBtKFwiLnNwYWNlVG9vbFtpZD0nc3BhY2V0b29scyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiei1pbmRleFwiOiBcIjE2XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHRbaWQ9J2J0bkZvcmNlJ11bb25jbGljaz0nZm9yY2VTd2l0Y2goKSddW3RpdGxlPSdQaW4gdGhlIHZhcmlhYmxlIHBlYmJsZXMgdG8gdGhlIHBhZ2UuJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tcHVzaHBpblwiKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdFtpZD0nYnRuRXJhc2VyJ11bb25jbGljaz0nZXJhc2UoKSddW3RpdGxlPSdXaXBlIGFsbCB2YXJpYWJsZXMgZnJvbSB0aGUgbW9kZWxpbmcgc3BhY2UuJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tbWFnbmV0XCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBtKFwiLmxlZ2VuZGFyeS5wYW5lbC5wYW5lbC1kZWZhdWx0W2lkPSdsZWdlbmQnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTGVnZW5kICBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLWxhcmdlLmdseXBoaWNvbi1jaGV2cm9uLWRvd24ucHVsbC1yaWdodFtkYXRhLXRhcmdldD0nI2NvbGxhcHNlTGVnZW5kJ11bZGF0YS10b2dnbGU9J2NvbGxhcHNlJ11baHJlZj0nI2NvbGxhcHNlTGVnZW5kJ11bb25jbGljaz0nJCh0aGlzKS50b2dnbGVDbGFzcyhcXCdnbHlwaGljb24tY2hldnJvbi11cFxcJykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tZG93blxcJyk7J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJzb3JcIjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImN1cnNvclwiOiBcImhhbmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtY29sbGFwc2UuY29sbGFwc2UuaW5baWQ9J2NvbGxhcHNlTGVnZW5kJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtYm9keVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5jbGVhcmZpeC5oaWRlW2lkPSd0aW1lQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGltZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLmNsZWFyZml4LmhpZGVbaWQ9J2NzQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ3Jvc3MgU2VjXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY2xlYXJmaXguaGlkZVtpZD0nZHZCdXR0b24nXVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdENvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3ZnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIyMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjIwcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiY2lyY2xlW2N4PScxMCddW2N5PScxMCddW2ZpbGw9J3doaXRlJ11bcj0nOSddW3N0cm9rZT0nYmxhY2snXVtzdHJva2Utd2lkdGg9JzInXVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RMYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEZXAgVmFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY2xlYXJmaXguaGlkZVtpZD0nbm9tQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTm9tIFZhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIG0oXCIubG9nYm94LnBhbmVsLnBhbmVsLWRlZmF1bHRbaWQ9J2xvZ2RpdiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWhlYWRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJoMy5wYW5lbC10aXRsZVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJIaXN0b3J5IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tbGFyZ2UuZ2x5cGhpY29uLWNoZXZyb24tZG93bi5wdWxsLXJpZ2h0W2RhdGEtdGFyZ2V0PScjY29sbGFwc2VMb2cnXVtkYXRhLXRvZ2dsZT0nY29sbGFwc2UnXVtocmVmPScjY29sbGFwc2VMb2cnXVtpZD0nbG9naWNvbiddW29uY2xpY2s9JyQodGhpcykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tZG93blxcJykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tdXBcXCcpOyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY3Vyc29yXCI6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJzb3JcIjogXCJoYW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWNvbGxhcHNlLmNvbGxhcHNlLmluW2lkPSdjb2xsYXBzZUxvZyddXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgbShcIltpZD0ndGlja2VyJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiZml4ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjUwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiBcIiNGOUY5RjlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJvdHRvbVwiOiBcIjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtKFwiYVtocmVmPSdzb21lbGluayddW2lkPSdsb2dJRCddW3RhcmdldD0nX2JsYW5rJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVwbGljYXRpb25cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsZWZ0cGFuZWwoKSxcbiAgICAgICAgICAgICAgICByaWdodHBhbmVsKClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5tLm1vdW50KGRvY3VtZW50LmJvZHksIEJvZHkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFEQTtBQURBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBUUE7QUFDQTtBQURBO0FBREE7QUFZQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBUUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQURBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFrQkE7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBREE7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQURBO0FBUUE7QUFDQTtBQURBO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQVNBO0FBQ0E7QUFEQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBREE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBV0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFlQTtBQUNBO0FBREE7QUFEQTtBQWFBO0FBQ0E7QUFEQTtBQURBO0FBU0E7QUFDQTtBQURBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBZ0JBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFnQkE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQWdCQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBaUJBO0FBQ0E7QUFEQTtBQURBO0FBU0E7QUFDQTtBQURBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQURBO0FBaUJBOzs7Ozs7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!******************************!*\
  !*** ./~/process/browser.js ***!
  \******************************/
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzPzgyZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./~/setimmediate/setImmediate.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 0), __webpack_require__(/*! ./../process/browser.js */ 7)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz80YTgwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./~/timers-browserify/main.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ 8);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz9iMDg4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);