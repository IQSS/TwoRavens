/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/* no static exports found */
/* all exports used */
/*!************************!*\
  !*** ./src/app_ddi.js ***!
  \************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.main = main;\nexports.tabLeft = tabLeft;\n\nvar _plots = __webpack_require__(/*! ./plots.js */ 7);\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an\n// argument (for ex., gui.html?dfId=17), but hostname isn't.\n// Edit it to suit your installation.\n// (NOTE that if the file id isn't supplied, the app will default to the\n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and\n// the tab-delimited data file; the parameters are ddiurl and dataurl.\n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls\n// for both the data and metadata, if the file id is supplied; or the\n// local files if nothing is supplied.\n\nvar production = false;\nvar rappURL = (production ? 'https://beta.dataverse.org/' : 'http://0.0.0.0:8000/') + '/custom/';\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called \"nodeCol\" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\nvar csColor = '#419641';\nvar dvColor = '#28a4c9';\nvar grayColor = '#c0c0c0';\nvar nomColor = '#ff6600';\nvar selVarColor = '#fa8072'; //d3.rgb(\"salmon\");\nvar taggedColor = '#f5f5f5'; //d3.rgb(\"whitesmoke\");\nvar timeColor = '#2d6ca2';\nvar varColor = '#f0f8ff'; //d3.rgb(\"aliceblue\");\n\nvar lefttab = \"tab1\"; // current tab in left panel\nvar righttab = \"btnModels\"; // current tab in right panel\n\n// transformation toolbar options\nvar transformList = 'log(d) exp(d) d^2 sqrt(d) interact(d,e)'.split();\nvar transformVar = '';\n\n// Radius of circle\nvar allR = 40;\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = [\"true\"];\nvar priv = false;\n\nvar zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: \"\",\n    zvars: [],\n    zdv: [],\n    zdataurl: \"\",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: \"\",\n    zdatacite: \"\"\n};\n\nvar modelCount = 0;\nvar summaryHold = false;\n\nvar valueKey = [];\nvar allNodes = [];\nvar nodes = [];\nvar links = [];\nvar mods = {};\nvar rightClickLast = false;\nvar selInteract = false;\nvar callHistory = []; // unique to the space. saves transform and subset calls.\n\nvar svg, width, height, div, obj, estimateLadda, selectLadda;\nvar arc3, arc4;\n\nfunction byId(id) {\n    return document.getElementById(id);\n}\n\nvar dataurl;\nfunction main(fileid, hostname, ddiurl, dataurl) {\n    dataurl = dataurl;\n    if (production && fileid == \"\") {\n        alert(\"Error: No fileid has been provided.\");\n        throw new Error(\"Error: No fileid has been provided.\");\n    }\n\n    var dataverseurl = \"\";\n    if (hostname) {\n        dataverseurl = \"https://\" + hostname;\n    } else if (production) {\n        dataverseurl = \"%PRODUCTION_DATAVERSE_URL%\";\n    } else {\n        dataverseurl = \"http://localhost:8080\";\n    }\n\n    if (fileid && !dataurl) {\n        // file id supplied; assume we are dealing with dataverse and cook a standard dataverse data access url\n        // with the fileid supplied and the hostname we have supplied or configured\n        dataurl = dataverseurl + \"/api/access/datafile/\" + fileid;\n        dataurl = dataurl + \"?key=\" + apikey;\n    }\n\n    svg = d3.select(\"#main.left div.carousel-inner\").attr('id', 'innercarousel').append('div').attr('class', 'item active').attr('id', 'm0').append('svg').attr('id', 'whitespace');\n\n    var logArray = [];\n\n    var tempWidth = d3.select(\"#main.left\").style(\"width\");\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // Hard coding for header and footer and bottom margin.\n\n    var estimated = false;\n    estimateLadda = Ladda.create(byId(\"btnEstimate\"));\n    selectLadda = Ladda.create(byId(\"btnSelect\"));\n\n    var colorTime = false;\n    var colorCS = false;\n\n    var depVar = false;\n    var subsetdiv = false;\n    var setxdiv = false;\n\n    //Width and height for histgrams\n    var barwidth = 1.3 * allR;\n    var barheight = 0.5 * allR;\n    var barPadding = 0.35;\n    var barnumber = 7;\n\n    var arc0 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(0).endAngle(3.2);\n    var arc1 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(0).endAngle(1);\n    var arc2 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(1.1).endAngle(2.2);\n    arc3 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(2.3).endAngle(3.3);\n    arc4 = d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(4.3).endAngle(5.3);\n\n    // From .csv\n    var dataset2 = [];\n    var lablArray = [];\n    var hold = [];\n    var allResults = [];\n    var subsetNodes = [];\n    var citetoggle = false;\n\n    var spaces = [];\n    var trans = []; // var list for each space contain variables in original data plus trans in that space\n\n    // collapsable user log\n    $('#collapseLog').on('shown.bs.collapse', function () {\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n    });\n    $('#collapseLog').on('hidden.bs.collapse', function () {\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    });\n\n    $('#about div.panel-body').text('TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed.  In the Norse, their names were \"Thought\" and \"Memory\".  In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.');\n\n    // read DDI metadata with d3\n    var metadataurl = \"\";\n    if (ddiurl) {\n        metadataurl = ddiurl;\n    } else if (fileid) {\n        // file id supplied; we're going to cook a standard dataverse\n        // metadata url, with the file id provided and the hostname\n        // supplied or configured\n        metadataurl = dataverseurl + \"/api/meta/datafile/\" + fileid;\n    } else {\n        // neither a full ddi url, nor file id supplied\n        metadataurl = \"data/PUMS5small-ddi.xml\"; // California PUMS subset\n    }\n\n    // read pre-processed metadata and data\n    var pURL = dataurl ? dataurl + \"&format=prep\" : \"data/preprocessPUMS5small.json\"; // California PUMS subset\n\n    var preprocess = {};\n\n    // loads all external data: metadata (DVN's ddi), preprocessed (for plotting distributions), and zeligmodels (produced by Zelig) and initiates the data download to the server\n    var url, p, v, _callback;\n    readPreprocess(url = pURL, p = preprocess, v = null, _callback = function callback() {\n        d3.xml(metadataurl, \"application/xml\", function (xml) {\n            var vars = xml.documentElement.getElementsByTagName(\"var\");\n            var temp = xml.documentElement.getElementsByTagName(\"fileName\");\n            zparams.zdata = temp[0].childNodes[0].nodeValue;\n\n            // clean the citation so that the POST is valid json\n            function cleanstring(s) {\n                s = s.replace(/\\&/g, \"and\");\n                s = s.replace(/\\;/g, \",\");\n                s = s.replace(/\\%/g, \"-\");\n                return s;\n            }\n\n            var cite = xml.documentElement.getElementsByTagName(\"biblCit\");\n            zparams.zdatacite = cite[0].childNodes[0].nodeValue;\n            zparams.zdatacite = cleanstring(zparams.zdatacite);\n            // dataset name trimmed to 12 chars\n            var dataname = zparams.zdata.replace(/\\.(.*)/, \"\"); // drop any file extension\n            d3.select(\"#dataName\").html(dataname);\n            $('#cite div.panel-body').text(zparams.zdatacite);\n\n            // Put dataset name, from meta-data, into page title\n            d3.select(\"title\").html(\"TwoRavens \" + dataname\n            // temporary values for hold that correspond to histogram bins\n            );hold = [.6, .2, .9, .8, .1, .3, .4];\n            for (var i = 0; i < vars.length; i++) {\n                valueKey[i] = vars[i].attributes.name.nodeValue;\n                lablArray[i] = vars[i].getElementsByTagName(\"labl\").length == 0 ? \"no label\" : vars[i].getElementsByTagName(\"labl\")[0].childNodes[0].nodeValue;\n                var datasetcount = d3.layout.histogram().bins(barnumber).frequency(false)([0, 0, 0, 0, 0]);\n                // creates an object to be pushed to allNodes\n                // contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable, such as setx values (if the user has selected them) and pebble coordinates\n                var obj1 = {\n                    id: i,\n                    reflexive: false,\n                    \"name\": valueKey[i],\n                    \"labl\": lablArray[i],\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: hold,\n                    \"nodeCol\": colors(i),\n                    \"baseCol\": colors(i),\n                    \"strokeColor\": selVarColor,\n                    \"strokeWidth\": \"1\",\n                    \"subsetplot\": false,\n                    \"subsetrange\": [\"\", \"\"],\n                    \"setxplot\": false,\n                    \"setxvals\": [\"\", \"\"],\n                    \"grayout\": false\n                };\n                jQuery.extend(true, obj1, preprocess[valueKey[i]]);\n                allNodes.push(obj1);\n            };\n\n            // read the zelig models and populate model list in right panel\n            d3.json(\"data/zelig5models.json\", function (err, data) {\n                if (err) return console.warn(err);\n                console.log(\"zelig models json: \", data);\n                for (var key in data.zelig5models) {\n                    if (data.zelig5models.hasOwnProperty(key)) mods[data.zelig5models[key].name[0]] = data.zelig5models[key].description[0];\n                }\n                d3.json(\"data/zelig5choicemodels.json\", function (err, data) {\n                    if (err) return console.warn(err);\n                    console.log(\"zelig choice models json: \", data);\n                    for (var _key in data.zelig5choicemodels) {\n                        if (data.zelig5choicemodels.hasOwnProperty(_key)) mods[data.zelig5choicemodels[_key].name[0]] = data.zelig5choicemodels[_key].description[0];\n                    }\n                    scaffolding(_callback = layout);\n                    dataDownload();\n                });\n            });\n        });\n    });\n}\n\n// scaffolding is called after all external data are guaranteed to have been read to completion. this populates the left panel with variable names, the right panel with model names, the transformation tool, an the associated mouseovers. its callback is layout(), which initializes the modeling space\nfunction scaffolding(callback) {\n    var _this = this;\n\n    // establishing the transformation element\n    d3.select(\"#transformations\").append(\"input\").attr(\"id\", \"tInput\").attr(\"class\", \"form-control\").attr(\"type\", \"text\").attr(\"value\", \"Variable transformation\");\n\n    // variable dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transSel\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data([\"a\", \"b\"] //set to variables in model space as they're added\n    ).enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    // function dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transList\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data(transformList).enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    $('#tInput').click(function () {\n        var t = byId('transSel').style.display;\n        if (t !== \"none\") {\n            // if variable list is displayed when input is clicked...\n            $('#transSel').fadeOut(100);\n            return false;\n        }\n        var t1 = byId('transList').style.display;\n        if (t1 !== \"none\") {\n            // if function list is displayed when input is clicked...\n            $('#transList').fadeOut(100);\n            return false;\n        }\n\n        // highlight the text\n        $(_this).select();\n        var pos = $('#tInput').offset();\n        pos.top += $('#tInput').width();\n        $('#transSel').fadeIn(100);\n        return false;\n    });\n\n    var n, typeTransform;\n\n    $('#tInput').keyup(function (event) {\n        var t = byId('transSel').style.display;\n        var t1 = byId('transList').style.display;\n\n        if (t !== \"none\") {\n            $('#transSel').fadeOut(100);\n        } else if (t1 !== \"none\") {\n            $('#transList').fadeOut(100);\n        }\n\n        if (event.keyCode == 13) {\n            // keyup on Enter\n            n = $('#tInput').val();\n            var t = transParse(n = n);\n            if (t === null) return;\n            transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n        }\n    });\n\n    var t;\n    $('#transList li').click(function (event) {\n        // if interact is selected, show variable list again\n        if ($(_this).text() === \"interact(d,e)\") {\n            $('#tInput').val(tvar.concat('*'));\n            selInteract = true;\n            $(_this).parent().fandeOut(100);\n            $('#transSel').fadeIn(100);\n            event.stopPropagation();\n            return;\n        }\n\n        var tvar = $('#tInput').val();\n        var tfunc = $(_this).text().replace(\"d\", \"_transvar0\");\n        var tcall = $(_this).text().replace(\"d\", tvar);\n        $('#tInput').val(tcall);\n        $(_this).parent().fadeOut(100);\n        event.stopPropagation();\n        transform(n = tvar, t = tfunc, typeTransform = false);\n    });\n\n    // populating the variable list in the left panel\n    d3.select(\"#tab1\").selectAll(\"p\").data(valueKey).enter().append(\"p\"\n    // replace non-alphanumerics for selection purposes\n    // perhaps ensure this id is unique by adding '_' to the front?\n    ).attr(\"id\", function (d) {\n        return d.replace(/\\W/g, \"_\");\n    }).text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        return findNodeIndex(d) > 2 ? varColor : hexToRgba(selVarColor);\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"right\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Summary Statistics\");\n\n    d3.select(\"#models\").style('height', 2000).style('overfill', 'scroll');\n\n    d3.select(\"#models\").selectAll(\"p\").data(Object.keys(mods)).enter().append(\"p\").attr(\"id\", \"_model_\".concat).text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        return varColor;\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"top\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Model Description\").attr(\"data-content\", function (d) {\n        return mods[d];\n    });\n\n    // call layout() because at this point all scaffolding is up and ready\n    if (typeof callback === \"function\") callback();\n}\n\nfunction layout(v) {\n    var _this2 = this;\n\n    var myValues = [];\n    nodes = [];\n    links = [];\n\n    if (v === \"add\" | v === \"move\") {\n        d3.select(\"#tab1\").selectAll(\"p\").style('background-color', varColor);\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue;\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, \"_\");\n            selectMe = \"#\".concat(selectMe);\n            d3.select(selectMe).style('background-color', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (allNodes.length > 2) {\n            nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            nodes = [allNodes[0], allNodes[1]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            nodes = [allNodes[0]];\n        } else {\n            alert(\"There are zero variables in the metadata.\");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and setx panels\n    populatePopover(); // pipes in the summary stats shown on mouseovers\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on('tick', tick);\n\n    // define arrow markers for graph links\n    svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').style('fill', '#000');\n\n    svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').style('fill', '#000');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');\n\n    // handles to link and node element groups\n    var path = svg.append('svg:g').selectAll('path'),\n        circle = svg.append('svg:g').selectAll('g');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        // draw directed edges with proper padding from node centers\n        path.attr('d', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? allR + 5 : allR,\n                targetPadding = d.right ? allR + 5 : allR,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n        });\n        circle.attr('transform', function (d) {\n            return 'translate(' + d.x + ',' + d.y + ')';\n        });\n    }\n\n    //  add listeners to leftpanel.left.  every time a variable is clicked, nodes updates and background color changes.  mouseover shows summary stats or model description.\n    d3.select(\"#tab1\").selectAll(\"p\").on(\"mouseover\", function (d) {\n        $(\"body div.popover\").addClass(\"variables\");\n        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n    }).on(\"click\", function varClick() {\n        if (allNodes[findNodeIndex(this.id)].grayout) return null;\n        d3.select(this).style('background-color', function (d) {\n            var myText = d3.select(this).text();\n            var myColor = d3.select(this).style('background-color');\n            var mySC = allNodes[findNodeIndex(myText)].strokeColor;\n\n            zparams.zvars = []; //empty the zvars array\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                // we are adding a var\n                if (nodes.length == 0) {\n                    nodes.push(findNode(myText));\n                    nodes[0].reflexive = true;\n                } else {\n                    nodes.push(findNode(myText));\n                }\n                return hexToRgba(selVarColor);\n            } else {\n                // dropping a variable\n                nodes.splice(findNode(myText)[\"index\"], 1);\n                spliceLinksForNode(findNode(myText));\n\n                if (mySC == dvColor) {\n                    var dvIndex = zparams.zdv.indexOf(myText);\n                    if (dvIndex > -1) {\n                        zparams.zdv.splice(dvIndex, 1);\n                    }\n                } else if (mySC == csColor) {\n                    var csIndex = zparams.zcross.indexOf(myText);\n                    if (csIndex > -1) {\n                        zparams.zcross.splice(csIndex, 1);\n                    }\n                } else if (mySC == timeColor) {\n                    var timeIndex = zparams.ztime.indexOf(myText);\n                    if (timeIndex > -1) {\n                        zparams.ztime.splice(timeIndex, 1);\n                    }\n                } else if (mySC == nomColor) {\n                    var nomIndex = zparams.znom.indexOf(myText);\n                    if (nomIndex > -1) {\n                        zparams.znom.splice(dvIndex, 1);\n                    }\n                }\n\n                nodeReset(allNodes[findNodeIndex(myText)]);\n                borderState();\n                legend();\n                return varColor;\n            }\n        });\n        panelPlots();\n        restart();\n    });\n\n    d3.select(\"#models\").selectAll(\"p\" // models tab\n    //  d3.select(\"#Display_content\")\n    ).on(\"click\", function () {\n        var myColor = d3.select(_this2).style('background-color');\n        d3.select(\"#models\").selectAll(\"p\").style('background-color', varColor);\n        d3.select(_this2).style('background-color', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(selVarColor);\n            } else {\n                zparams.zmodel = \"\";\n                return varColor;\n            }\n        });\n        restart();\n    });\n\n    // update graph (called when needed)\n    function restart() {\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] === \"true\") {\n            force.gravity(0.1);\n            force.charge(-800);\n            force.linkStrength(1);\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are \"selected\". this is disabled for now\n        path.classed('selected', function (d) {\n            return;\n        } //return d === selected_link; })\n        ).style('marker-start', function (d) {\n            return d.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (d) {\n            return d.right ? 'url(#end-arrow)' : '';\n        });\n\n        // add new links\n        path.enter().append('svg:path').attr('class', 'link').classed('selected', function (d) {\n            return;\n        } //return d === selected_link; })\n        ).style('marker-start', function (d) {\n            return d.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (d) {\n            return d.right ? 'url(#end-arrow)' : '';\n        }).on('mousedown', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj1 = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj1 === JSON.stringify(links[j])) {\n                    links.splice(j, 1);\n                }\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (d) {\n            return d.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        //d3.rgb is the function adjusting the color here.\n        circle.selectAll('circle').classed('reflexive', function (d) {\n            return d.reflexive;\n        }).style('fill', function (d) {\n            return d3.rgb(d.nodeCol);\n        }).style('stroke', function (d) {\n            return d3.rgb(d.strokeColor);\n        }).style('stroke-width', function (d) {\n            return d.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append('svg:g').attr(\"id\", function (d) {\n            var myname = d.name + \"biggroup\";\n            return myname;\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype === \"continuous\") {\n                (0, _plots.densityNode)(d, obj = this);\n            } else if (d.plottype === \"bar\") {\n                (0, _plots.barsNode)(d, obj = this);\n            }\n        });\n\n        g.append(\"path\").attr(\"id\", function (d) {\n            return \"dvArc\".concat(d.id);\n        }).attr(\"d\", arc3).style(\"fill\", dvColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            d3.select(this).transition().attr(\"fill-opacity\", .3).delay(0).duration(100);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", .9).delay(0).duration(100);\n        }).on('mouseout', function (d) {\n            d3.select(this).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        }).on('click', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            restart();\n        });\n        g.append(\"text\").attr(\"id\", function (d) {\n            return \"dvText\".concat(d.id);\n        }).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", function (d) {\n            return \"#dvArc\".concat(d.id);\n        }).text(\"Dep Var\");\n\n        g.append(\"path\").attr(\"id\", function (d) {\n            return \"nomArc\".concat(d.id);\n        }).attr(\"d\", arc4).style(\"fill\", nomColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            d3.select(this).transition().attr(\"fill-opacity\", .3).delay(0).duration(100);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", .9).delay(0).duration(100);\n        }).on('mouseout', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            d3.select(this).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        }).on('click', function (d) {\n            if (d.defaultNumchar == \"character\") {\n                return;\n            }\n            setColors(d, nomColor);\n            legend(nomColor);\n            restart();\n        });\n        g.append(\"text\").attr(\"id\", function (d) {\n            return \"nomText\".concat(d.id);\n        }).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", function (d) {\n            return \"#nomArc\".concat(d.id);\n        }).text(\"Nominal\");\n\n        g.append('svg:circle').attr('class', 'node').attr('r', allR).style('pointer-events', 'inherit').style('fill', function (d) {\n            return d.nodeCol;\n        }).style('opacity', \"0.5\").style('stroke', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed('reflexive', function (d) {\n            return d.reflexive;\n        }).on('dblclick', function (d) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            summaryHold = true;\n        }).on('contextmenu', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation(); // stop right click from bubbling\n            rightClickLast = true;\n\n            mousedown_node = d;\n            if (mousedown_node === selected_node) selected_node = null;else selected_node = mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n            svg.on('mousemove', mousemove);\n            restart();\n        }).on('mouseup', function (d) {\n            d3.event.stopPropagation(); // stop mouseup from bubbling\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed('hidden', true).style('marker-end', '');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr('transform', '');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = 'right';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = 'left';\n            }\n\n            var link;\n            link = links.filter(function (l) {\n                return l.source === source && l.target === target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on('mousemove', null);\n\n            resetMouseVars();\n            restart();\n        });\n\n        // show node Names\n        g.append('svg:text').attr('x', 0).attr('y', 15).attr('class', 'id').text(function (d) {\n            return d.name;\n        }\n\n        // show summary stats on mouseover\n        // SVG doesn't support text wrapping, use html instead\n        );g.selectAll(\"circle.node\").on(\"mouseover\", function (d) {\n            tabLeft(\"tab3\");\n            varSummary(d);\n            byId('transformations').setAttribute(\"style\", \"display:block\");\n            var select = byId(\"transSel\");\n            select.selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            d3.select(\"#dvArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            if (d.defaultNumchar == \"numeric\") {\n                d3.select(\"#nomArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n                d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            }\n            d3.select(\"#csArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#csText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n            d3.select(\"#timeArc\".concat(d.id)).transition().attr(\"fill-opacity\", .1).delay(0).duration(100);\n            d3.select(\"#timeText\".concat(d.id)).transition().attr(\"fill-opacity\", .5).delay(0).duration(100);\n        }).on(\"mouseout\", function (d) {\n            if (summaryHold === false) {\n                tabLeft(lefttab);\n            }\n\n            d3.select(\"#csArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#csText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#timeArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#timeText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#dvText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomArc\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n            d3.select(\"#nomText\".concat(d.id)).transition().attr(\"fill-opacity\", 0).delay(100).duration(500);\n        });\n\n        // populating transformation dropdown\n        var t = [];\n        for (var j = 0; j < nodes.length; j++) {\n            t.push(nodes[j].name);\n        }\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select(\"#transSel\").selectAll('li').remove();\n\n        d3.select(\"#transSel\").selectAll('li').data(t //set to variables in model space as they're added\n        ).enter().append(\"li\").text(function (d) {\n            return d;\n        });\n\n        $('#transSel li').click(function (event) {\n            // if 'interaction' is the selected function, don't show the function list again\n            if (selInteract === true) {\n                var n = $('#tInput').val().concat($(this).text());\n                $('#tInput').val(n);\n                event.stopPropagation();\n                var t = transParse(n = n);\n                if (t === null) {\n                    return;\n                }\n                $(this).parent().fadeOut(100);\n                transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                return;\n            }\n\n            $('#tInput').val($(this).text());\n            $(this).parent().fadeOut(100);\n            $('#transList').fadeIn(100);\n            event.stopPropagation();\n        });\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n    }\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed('active', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) {\n            return;\n        }\n        restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n\n        // update drag line\n        drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed('hidden', true).style('marker-end', '');\n        }\n        // because :active only works in WebKit?\n        svg.classed('active', false);\n\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr('id', function () {\n        return \"whitespace\".concat(myspace);\n    }).attr('height', height).on('mousedown', function () {\n        mousedown(this);\n    }).on('mouseup', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on('click', function () {\n        //NOTE: all clicks will bubble here unless event.stopPropagation()\n        $('#transList').fadeOut(100);\n        $('#transSel').fadeOut(100);\n    });\n\n    restart(); // this is the call the restart that initializes the force.layout()\n    fakeClick();\n} // end layout\n\n// returns id\nvar findNodeIndex = function findNodeIndex(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i][\"name\"] === nodeName) {\n            return allNodes[i][\"id\"];\n        }\n    };\n};\n\nvar nodeIndex = function nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i][\"name\"] === nodeName) {\n            return i;\n        }\n    }\n};\n\nvar findNode = function findNode(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i][\"name\"] === nodeName) return allNodes[i];\n    };\n};\n\n// function called by force button\nfunction forceSwitch() {\n    if (forcetoggle[0] === \"true\") {\n        forcetoggle = [\"false\"];\n    } else {\n        forcetoggle = [\"true\"];\n    }\n\n    if (forcetoggle[0] === \"false\") {\n        byId('btnForce').setAttribute(\"class\", \"btn active\");\n    } else {\n        byId('btnForce').setAttribute(\"class\", \"btn btn-default\");\n        fakeClick();\n    }\n}\n\nfunction spliceLinksForNode(node) {\n    var toSplice = links.filter(function (l) {\n        return l.source === node || l.target === node;\n    });\n    toSplice.map(function (l) {\n        links.splice(links.indexOf(l), 1);\n    });\n}\n\nfunction zPop() {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n\n    for (var j = 0; j < links.length; j++) {\n        //populate zedges array\n        var srctgt = [];\n        //correct the source target ordering for Zelig\n        if (links[j].left === false) {\n            srctgt = [links[j].source.name, links[j].target.name];\n        } else {\n            srctgt = [links[j].target.name, links[j].source.name];\n        }\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction estimate(btn) {\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    zPop();\n    // write links to file & run R CMD\n    // package the output as JSON\n    // add call history and package the zparams object as JSON\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    var urlcall = rappURL + \"zeligapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    zparams.allVars = valueKey.slice(10, 25); // because the URL is too long...\n    var jsonout = JSON.stringify(zparams);\n    var selectorurlcall = rappURL + \"selectorapp\";\n\n    function estimateSuccess(btn, json) {\n        estimateLadda.stop(); // stop spinner\n        allResults.push(json);\n        console.log(allResults);\n        console.log(\"json in: \", json);\n\n        var myparent = byId(\"results\");\n        if (estimated == false) {\n            myparent.removeChild(byId(\"resultsHolder\"));\n        }\n\n        estimated = true;\n        d3.select(\"#results\").style(\"display\", \"block\");\n\n        d3.select(\"#resultsView\").style(\"display\", \"block\");\n\n        d3.select(\"#modelView\").style(\"display\", \"block\");\n\n        // programmatic click on Results button\n        $(\"#btnResults\").trigger(\"click\");\n\n        modelCount = modelCount + 1;\n        var model = \"Model\".concat(modelCount);\n\n        function modCol() {\n            d3.select(\"#modelView\").selectAll(\"p\").style('background-color', hexToRgba(varColor));\n        }\n        modCol();\n\n        d3.select(\"#modelView\").insert(\"p\", \":first-child\" // top stack for results\n        ).attr(\"id\", model).text(model).style('background-color', hexToRgba(selVarColor)).on(\"click\", function () {\n            var a = this.style.backgroundColor.replace(/\\s*/g, \"\");\n            var b = hexToRgba(selVarColor).replace(/\\s*/g, \"\");\n            if (a.substr(0, 17) === b.substr(0, 17)) {\n                return; // escapes the function early if the displayed model is clicked\n            }\n            modCol();\n            d3.select(this).style('background-color', hexToRgba(selVarColor));\n            viz(this.id);\n        });\n\n        var rCall = [];\n        rCall[0] = json.call;\n        logArray.push(\"estimate: \".concat(rCall[0]));\n        showLog();\n\n        viz(model);\n    }\n\n    function estimateFail(btn) {\n        estimateLadda.stop(); // stop spinner\n        estimated = true;\n    }\n\n    function selectorSuccess(btn, json) {\n        d3.select(\"#ticker\").text(\"Suggested variables and percent improvement on RMSE: \" + json.vars);\n        console.log(\"selectorSuccess: \", json);\n    }\n\n    function selectorFail(btn) {\n        alert(\"Selector Fail\");\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, estimateSuccess, estimateFail, solajsonout);\n}\n\nfunction dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    var jsonout = JSON.stringify(zparams);\n    var btn = \"nobutton\";\n\n    var urlcall = rappURL + \"dataapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function downloadSuccess(btn, json) {\n        console.log(\"dataDownload json in: \", json);\n        zparams.zsessionid = json.sessionid[0];\n\n        // set the link URL\n        if (production) {\n            var logURL = rappURL + \"log_dir/log_\" + zparams.zsessionid + \".txt\";\n            byId(\"logID\").href = logURL;\n        } else {\n            var logURL = \"rook/log_\" + zparams.zsessionid + \".txt\";\n            byId(\"logID\").href = logURL;\n        }\n    }\n\n    function downloadFail(btn) {\n        console.log(\"Data have not been downloaded\");\n    }\n\n    makeCorsRequest(urlcall, btn, downloadSuccess, downloadFail, solajsonout);\n}\n\nfunction viz(m) {\n    var mym = +m.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    var myparent = byId(\"resultsView\");\n    removeKids(myparent);\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement(\"img\");\n        zfig.setAttribute(\"src\", json.images[i]);\n        zfig.setAttribute('width', 200);\n        zfig.setAttribute('height', 200);\n        byId(\"resultsView\").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \"colnames\") {\n            continue;\n        }\n\n        obj = json.sumInfo[key];\n        resultsArray.push(obj);\n        /* SO says this is important check, but I don't see how it helps here...\n         for (var prop in obj) {\n         // important check that this is objects own property\n         // not from prototype prop inherited\n         if(obj.hasOwnProperty(prop)){\n         alert(prop + \" = \" + obj[prop]);\n         }\n         }  */\n    }\n\n    var table = d3.select(\"#resultsView\").append(\"p\").append(\"table\");\n\n    var thead = table.append(\"thead\");\n    thead.append(\"tr\").selectAll(\"th\").data(json.sumInfo.colnames).enter().append(\"th\").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append(\"tbody\");\n    tbody.selectAll(\"tr\").data(resultsArray).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) {\n            return d;\n        }\n        return myNum.toPrecision(3);\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    } // for no discernable reason\n    ).on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n\n    d3.select(\"#resultsView\").append(\"p\").html(function () {\n        return \"<b>Formula: </b>\".concat(json.call[0]);\n    });\n}\n\n// parses the transformation input. variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = \"_transvar\".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n=\"wars+2\", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 !== null) {\n            out2.push(m2[0]);\n        }\n\n        var re = new RegExp(valueKey[i], \"g\");\n        var s = n.search(re);\n        if (s != -1) {\n            indexed.push({\n                from: s,\n                to: s + valueKey[i].length\n            });\n        }\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don't affect the splice\n    console.log(\"indexed \", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) {\n                continue;\n            }\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                console.log(i, \" is nested in \", j);\n                out2.splice(i, 1);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that'll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = \"_transvar\".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        console.log(\"new out \", out2);\n        return out2;\n    } else {\n        alert(\"No variable name found. Perhaps check your spelling?\");\n        return null;\n    }\n}\n\nfunction transform(n, t, typeTransform) {\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    if (!typeTransform) {\n        t = t.replace(\"+\", \"_plus_\"); // can't send the plus operator\n    }\n\n    console.log(n);\n    console.log(t);\n\n    var btn = byId('btnEstimate');\n\n    var myn = allNodes[findNodeIndex(n[0])];\n    if (typeof myn === \"undefined\") {\n        var myn = allNodes[findNodeIndex(n)];\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    console.log(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == \"nominal\" & typeof myn.plotvalues !== \"undefined\") {\n            myn.plottype = \"bar\";\n            (0, _plots.barsNode)(myn);\n            populatePopover();\n            panelPlots();\n            return;\n        } else if (myn.nature != \"nominal\" & typeof myn.plotx !== \"undefined\") {\n            myn.plottype = \"continuous\";\n            (0, _plots.densityNode)(myn);\n            populatePopover();\n            panelPlots();\n            return;\n        }\n    }\n\n    //package the output as JSON\n    var transformstuff = {\n        zdataurl: dataurl,\n        zvars: n,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes\n    };\n    var jsonout = JSON.stringify(transformstuff);\n    var urlcall = rappURL + \"transformapp\";\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function transformSuccess(btn, json) {\n        estimateLadda.stop();\n        console.log(\"json in: \", json);\n        if (json.typeTransform[0]) {\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n                    if (allNodes[myIndex].plottype === \"continuous\") (0, _plots.densityNode)(allNodes[myIndex]);else if (allNodes[myIndex].plottype === \"bar\") (0, _plots.barsNode)(allNodes[myIndex]);\n                }\n                fakeClick();\n                populatePopover();\n                panelPlots();\n                console.log(allNodes[myIndex]);\n            });\n        } else {\n            callHistory.push({\n                func: \"transform\",\n                zvars: n,\n                transform: t\n            });\n\n            var subseted = false;\n            var rCall = [];\n            rCall[0] = json.call;\n            var newVar = rCall[0][0];\n            trans.push(newVar);\n\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    if (typeof myIndex !== \"undefined\") {\n                        alert(\"Invalid transformation: this variable name already exists.\");\n                        return;\n                    }\n                    // add transformed variable to the current space\n                    var i = allNodes.length;\n                    var obj1 = {\n                        id: i,\n                        reflexive: false,\n                        \"name\": key,\n                        \"labl\": \"transformlabel\",\n                        data: [5, 15, 20, 0, 5, 15, 20],\n                        count: [.6, .2, .9, .8, .1, .3, .4],\n                        \"nodeCol\": colors(i),\n                        \"baseCol\": colors(i),\n                        \"strokeColor\": selVarColor,\n                        \"strokeWidth\": \"1\",\n                        \"subsetplot\": false,\n                        \"subsetrange\": [\"\", \"\"],\n                        \"setxplot\": false,\n                        \"setxvals\": [\"\", \"\"],\n                        \"grayout\": false,\n                        \"defaultInterval\": jsondata[key][\"interval\"],\n                        \"defaultNumchar\": jsondata[key][\"numchar\"],\n                        \"defaultNature\": jsondata[key][\"nature\"],\n                        \"defaultBinary\": jsondata[key][\"binary\"]\n                    };\n\n                    jQuery.extend(true, obj1, jsondata[key]);\n                    allNodes.push(obj1);\n\n                    scaffoldingPush(rCall[0]);\n                    valueKey.push(newVar);\n                    nodes.push(allNodes[i]);\n                    fakeClick();\n                    panelPlots();\n\n                    if (allNodes[i].plottype === \"continuous\") {\n                        (0, _plots.densityNode)(allNodes[i]);\n                    } else if (allNodes[i].plottype === \"bar\") {\n                        (0, _plots.barsNode)(allNodes[i]);\n                    }\n                } //for\n\n            });\n\n            // update the log\n            logArray.push(\"transform: \".concat(rCall[0]));\n            showLog();\n        }\n    }\n\n    function transformFail(btn) {\n        alert(\"transform fail\");\n        estimateLadda.stop();\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, transformSuccess, transformFail, solajsonout);\n}\n\nfunction scaffoldingPush(v) {\n    // adding a variable to the variable list after a transformation\n    d3.select(\"#tab1\").data(v).append(\"p\").attr(\"id\", function () {\n        return v[0].replace(/\\W/g, \"_\");\n    }).text(v[0]).style('background-color', hexToRgba(selVarColor)).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"right\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Summary Statistics\").on(\"click\", function varClick() {\n        // we've added a new variable, so we need to add the listener\n        d3.select(this).style('background-color', function (d) {\n            var myText = d3.select(this).text();\n            var myColor = d3.select(this).style('background-color');\n            var mySC = allNodes[findNodeIndex(myText)].strokeColor;\n\n            zparams.zvars = []; //empty the zvars array\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                // we are adding a var\n                if (nodes.length == 0) {\n                    nodes.push(findNode(myText));\n                    nodes[0].reflexive = true;\n                } else {\n                    nodes.push(findNode(myText));\n                }\n                return hexToRgba(selVarColor);\n            } else {\n                // dropping a variable\n\n                nodes.splice(findNode(myText)[\"index\"], 1);\n                spliceLinksForNode(findNode(myText));\n\n                if (mySC == dvColor) {\n                    var dvIndex = zparams.zdv.indexOf(myText);\n                    if (dvIndex > -1) {\n                        zparams.zdv.splice(dvIndex, 1);\n                    }\n                } else if (mySC == csColor) {\n                    var csIndex = zparams.zcross.indexOf(myText);\n                    if (csIndex > -1) {\n                        zparams.zcross.splice(csIndex, 1);\n                    }\n                } else if (mySC == timeColor) {\n                    var timeIndex = zparams.ztime.indexOf(myText);\n                    if (timeIndex > -1) {\n                        zparams.ztime.splice(dvIndex, 1);\n                    }\n                } else if (mySC == nomColor) {\n                    var nomIndex = zparams.znom.indexOf(myText);\n                    if (nomIndex > -1) {\n                        zparams.znom.splice(dvIndex, 1);\n                    }\n                }\n\n                nodeReset(allNodes[findNodeIndex(myText)]);\n                borderState();\n                return varColor;\n            }\n        });\n        fakeClick();\n        panelPlots();\n    });\n    populatePopover(); // pipes in the summary stats\n\n    // drop down menu for tranformation toolbar\n    d3.select(\"#transSel\").data(v).append(\"option\").text(function (d) {\n        return d;\n    });\n}\n\n// below from http://www.html5rocks.com/en/tutorials/cors/ for cross-origin resource sharing\n// Create the XHR object.\nfunction createCORSRequest(method, url, callback) {\n    var xhr = new XMLHttpRequest();\n    if (\"withCredentials\" in xhr) {\n        // XHR for Chrome/Firefox/Opera/Safari.\n        xhr.open(method, url, true);\n    } else if (typeof XDomainRequest != \"undefined\") {\n        // XDomainRequest for IE.\n        xhr = new XDomainRequest();\n        xhr.open(method, url);\n    } else {\n        // CORS not supported.\n        xhr = null;\n    }\n    // xhr.setRequestHeader('Content-Type', 'text/plain');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    return xhr;\n}\n\n// Make the actual CORS request.\nfunction makeCorsRequest(url, btn, callback, warningcallback, jsonstring) {\n    var xhr = createCORSRequest('POST', url);\n    if (!xhr) {\n        alert('CORS not supported');\n        return;\n    }\n    // Response handlers for asynchronous load\n    // onload or onreadystatechange?\n\n    xhr.onload = function () {\n        var text = xhr.responseText;\n        console.log(\"text \", text);\n\n        try {\n            var json = JSON.parse(text); // should wrap in try / catch\n            var names = Object.keys(json);\n        } catch (err) {\n            estimateLadda.stop();\n            selectLadda.stop();\n            console.log(err);\n            alert('Error: Could not parse incoming JSON.');\n        }\n\n        if (names[0] == \"warning\") {\n            warningcallback(btn);\n            alert(\"Warning: \" + json.warning);\n        } else {\n            callback(btn, json);\n        }\n    };\n    xhr.onerror = function () {\n        // note: xhr.readystate should be 4, and status should be 200.  a status of 0 occurs when the url becomes too large\n        if (xhr.status == 0) {\n            alert('There was an error making the request. xmlhttprequest status is 0.');\n        } else if (xhr.readyState != 4) {\n            alert('There was an error making the request. xmlhttprequest readystate is not 4.');\n        } else {\n            alert('Woops, there was an error making the request.');\n        }\n        console.log(xhr);\n        estimateLadda.stop();\n        selectLadda.stop();\n    };\n    xhr.send(jsonstring);\n}\n\nfunction legend(c) {\n    if (zparams.ztime.length != 0 | zparams.zcross.length != 0 | zparams.zdv.length != 0 | zparams.znom.length != 0) {\n        byId(\"legend\").setAttribute(\"style\", \"display:block\");\n    } else {\n        byId(\"legend\").setAttribute(\"style\", \"display:none\");\n    }\n    if (zparams.ztime.length == 0) {\n        byId(\"timeButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        byId(\"timeButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.zcross.length == 0) {\n        byId(\"csButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        byId(\"csButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.zdv.length == 0) {\n        byId(\"dvButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        byId(\"dvButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    if (zparams.znom.length == 0) {\n        byId(\"nomButton\").setAttribute(\"class\", \"clearfix hide\");\n    } else {\n        byId(\"nomButton\").setAttribute(\"class\", \"clearfix show\");\n    }\n    borderState();\n}\n\nfunction reset() {\n    location.reload();\n}\n\n// programmatically deselecting every selected variable...\nfunction erase() {\n    var _this3 = this;\n\n    leftpanelMedium();\n    rightpanelMedium();\n    byId(\"legend\").setAttribute(\"style\", \"display:none\");\n    tabLeft('tab1');\n    jQuery.fn.d3Click = function () {\n        _this3.children().each(function (i, e) {\n            var mycol = d3.rgb(_this3.style.backgroundColor);\n            if (mycol.toString() === varColor.toString()) return;\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(\"#tab1\").d3Click();\n}\n\nfunction deselect(d) {\n    console.log(d);\n}\n\n// http://www.tutorials2learn.com/tutorials/scripts/javascript/xml-parser-javascript.html\nfunction loadXMLDoc(XMLname) {\n    var xmlDoc;\n    if (window.XMLHttpRequest) {\n        xmlDoc = new window.XMLHttpRequest();\n        xmlDoc.open(\"GET\", XMLname, false);\n        xmlDoc.send(\"\");\n        return xmlDoc.responseXML;\n    }\n    // IE 5 and IE 6\n    else if (ActiveXObject(\"Microsoft.XMLDOM\")) {\n            xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = false;\n            xmlDoc.load(XMLname);\n            return xmlDoc;\n        }\n    alert(\"Error loading document!\");\n    return null;\n}\n\nfunction tabLeft(tab) {\n    if (tab != \"tab3\") {\n        lefttab = tab;\n    }\n    var tabi = tab.substring(3);\n    byId('tab1').style.display = 'none';\n    byId('tab2').style.display = 'none';\n    byId('tab3').style.display = 'none';\n    if (tab === \"tab1\") {\n        summaryHold = false;\n        byId('btnSubset').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnVariables').setAttribute(\"class\", \"btn active\");\n        byId(\"btnSelect\").style.display = 'none';\n        d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    } else if (tab === \"tab2\") {\n        summaryHold = false;\n        byId('btnVariables').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnSubset').setAttribute(\"class\", \"btn active\");\n        d3.select(\"#leftpanel\").attr(\"class\", function (d) {\n            if (this.getAttribute(\"class\") === \"sidepanel container clearfix expandpanel\") {\n                byId(\"btnSelect\").style.display = 'none';\n                return \"sidepanel container clearfix\";\n            } else {\n                byId(\"btnSelect\").style.display = 'block';\n                return \"sidepanel container clearfix expandpanel\";\n            }\n        });\n    } else {\n        byId('btnSubset').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnVariables').setAttribute(\"class\", \"btn btn-default\");\n        d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    }\n    byId(tab).style.display = 'block';\n}\n\nfunction tabRight(tabid) {\n    byId('models').style.display = 'none';\n    byId('setx').style.display = 'none';\n    byId('results').style.display = 'none';\n    if (tabid == \"btnModels\") {\n        byId('btnSetx').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnResults').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnModels').setAttribute(\"class\", \"btn active\");\n        byId('models').style.display = 'block';\n        d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n    } else if (tabid == \"btnSetx\") {\n        byId('btnModels').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnResults').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnSetx').setAttribute(\"class\", \"btn active\");\n        byId('setx').style.display = 'block';\n        if (righttab == \"btnSetx\" | d3.select(\"#rightpanel\").attr(\"class\") == \"sidepanel container clearfix\") {\n            toggleR();\n        };\n    } else if (tabid == \"btnResults\") {\n        byId('btnModels').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnSetx').setAttribute(\"class\", \"btn btn-default\");\n        byId('btnResults').setAttribute(\"class\", \"btn active\");\n        byId('results').style.display = 'block';\n        if (estimated === false) {\n            d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n        } else if (righttab == \"btnResults\" | d3.select(\"#rightpanel\").attr(\"class\") == \"sidepanel container clearfix\") {\n            toggleR();\n        };\n    }\n\n    righttab = tabid;\n\n    function toggleR() {\n        var _this4 = this;\n\n        d3.select(\"#rightpanel\").attr(\"class\", function (d) {\n            if (_this4.getAttribute(\"class\") === \"sidepanel container clearfix expandpanel\") return \"sidepanel container clearfix\";\n            return \"sidepanel container clearfix expandpanel\";\n        });\n    }\n}\n\nfunction varSummary(d) {\n    var _this5 = this;\n\n    var rint = d3.format(\"r\");\n    var summarydata = [],\n        tmpDataset = [],\n        t1 = [\"Mean:\", \"Median:\", \"Most Freq:\", \"Occurrences:\", \"Median Freq:\", \"Occurrences:\", \"Least Freq:\", \"Occurrences:\", \"Stand.Dev:\", \"Minimum:\", \"Maximum:\", \"Invalid:\", \"Valid:\", \"Uniques:\", \"Herfindahl:\"],\n        t2 = [(+d.mean).toPrecision(4).toString(), (+d.median).toPrecision(4).toString(), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), (+d.sd).toPrecision(4).toString(), (+d.min).toPrecision(4).toString(), (+d.max).toPrecision(4).toString(), rint(d.invalid), rint(d.valid), rint(d.uniques), (+d.herfindahl).toPrecision(4).toString()],\n        i,\n        j;\n    if (priv) {\n        if (d.meanCI) {\n            t1 = [\"Mean:\", \"Median:\", \"Most Freq:\", \"Occurrences:\", \"Median Freq:\", \"Occurrences:\", \"Least Freq:\", \"Occurrences:\", \"Stand.Dev:\", \"Minimum:\", \"Maximum:\", \"Invalid:\", \"Valid:\", \"Uniques:\", \"Herfindahl:\"], t2 = [(+d.mean).toPrecision(2).toString() + \" (\" + (+d.meanCI.lowerBound).toPrecision(2).toString() + \" - \" + (+d.meanCI.upperBound).toPrecision(2).toString() + \")\", (+d.median).toPrecision(4).toString(), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), (+d.sd).toPrecision(4).toString(), (+d.min).toPrecision(4).toString(), (+d.max).toPrecision(4).toString(), rint(d.invalid), rint(d.valid), rint(d.uniques), (+d.herfindahl).toPrecision(4).toString()], i, j;\n        }\n    }\n\n    for (i = 0; i < t1.length; i++) {\n        if (t2[i].indexOf(\"NaN\") > -1 | t2[i] == \"NA\" | t2[i] == \"\") continue;\n        tmpDataset = [];\n        tmpDataset.push(t1[i]);\n        tmpDataset.push(t2[i]);\n        summarydata.push(tmpDataset);\n    };\n\n    d3.select(\"#tab3\" // tab when you mouseover a pebble\n    ).select(\"p\").html(\"<center><b>\" + d.name + \"</b><br><i>\" + d.labl + \"</i></center>\").append(\"table\").selectAll(\"tr\").data(summarydata).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        return d;\n    }).on(\"mouseover\", function () {\n        return d3.select(_this5).style(\"background-color\", \"aliceblue\");\n    }).on(\"mouseout\", function () {\n        return d3.select(_this5).style(\"background-color\", \"#F9F9F9\");\n    });\n\n    var plotsvg = d3.select(\"#tab3\").selectAll(\"svg\").remove();\n\n    if (typeof d.plottype === \"undefined\") // .properties is undefined for some vars\n        return;else if (d.plottype === \"continuous\") (0, _plots.density)(d, div = \"varSummary\", priv);else if (d.plottype === \"bar\") (0, _plots.bars)(d, div = \"varSummary\", priv);else {\n        var plotsvg = d3.select(\"#tab3\" // no graph to draw, but still need to remove previous graph\n        ).selectAll(\"svg\").remove();\n    };\n}\n\nfunction populatePopover() {\n    d3.select(\"#tab1\").selectAll(\"p\").attr(\"data-content\", function (d) {\n        return popoverContent(allNodes[findNodeIndex(d)]);\n    });\n}\n\nfunction popoverContent(d) {\n    var rint = d3.format(\"r\");\n    var outtext = \"\";\n    if (d.labl != \"\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Label</label><div class='col-sm-6'><p class='form-control-static'><i>\" + d.labl + \"</i></p></div></div>\";\n    }\n    if (d.mean != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\";\n        if (priv && d.meanCI) {\n            outtext += (+d.mean).toPrecision(2).toString() + \" (\" + (+d.meanCI.lowerBound).toPrecision(2).toString() + \" - \" + (+d.meanCI.upperBound).toPrecision(2).toString() + \")\";\n        } else {\n            outtext += (+d.mean).toPrecision(4).toString();\n        }\n        outtext += \"</p></div></div>\";\n    }\n    if (d.median != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.median).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n    if (d.mode != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Most Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\";\n    }\n    if (d.freqmode != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqmode) + \"</p></div></div>\";\n    }\n    if (d.mid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Median Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mid + \"</p></div></div>\";\n    }\n    if (d.freqmid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqmid) + \"</p></div></div>\";\n    }\n    if (d.fewest != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Least Freq</label><div class='col-sm-6'><p class='form-control-static'>\" + d.fewest + \"</p></div></div>\";\n    }\n    if (d.freqfewest != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Occurrences</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.freqfewest) + \"</p></div></div>\";\n    }\n    if (d.sd != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.sd).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n    if (d.max != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.max).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n    if (d.min != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.min).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n    if (d.invalid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\";\n    }\n    if (d.valid != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\";\n    }\n    if (d.uniques != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Uniques</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.uniques) + \"</p></div></div>\";\n    }\n    if (d.herfindahl != \"NA\") {\n        outtext = outtext + \"<div class='form-group'><label class='col-sm-4 control-label'>Herfindahl</label><div class='col-sm-6'><p class='form-control-static'>\" + (+d.herfindahl).toPrecision(4).toString() + \"</p></div></div>\";\n    }\n    return outtext;\n}\n\nfunction popupX(d) {\n    var tsf = d3.format(\".4r\");\n    var rint = d3.format(\"r\");\n    //Create the tooltip label\n    d3.select(\"#tooltip\").style(\"left\", tempX + \"px\").style(\"top\", tempY + \"px\").select(\"#tooltiptext\").html(\"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.mean) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.median) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Mode</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.sd) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.max) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.min) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\");\n}\n\nfunction panelPlots() {\n    // build arrays from nodes in main\n    var vars = [];\n    var ids = [];\n    nodes.forEach(function (n) {\n        vars.push(n.name.replace(/\\(|\\)/g, ''));\n        ids.push(n.id);\n    });\n\n    //remove all plots, could be smarter here\n    d3.select('#setx').selectAll('svg').remove();\n    d3.select('#tab2').selectAll('svg').remove();\n    for (var i = 0; i < vars.length; i++) {\n        var node = allNodes[ids[i]];\n        node.setxplot = false;\n        node.subsetplot = false;\n        if (node.plottype === \"continuous\" & node.setxplot == false) {\n            node.setxplot = true;\n            console.log(priv);\n            (0, _plots.density)(node, div = \"setx\", priv);\n            node.subsetplot = true;\n            (0, _plots.density)(node, div = \"subset\", priv);\n        } else if (node.plottype === \"bar\" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.bars)(node, div = \"setx\", priv);\n            node.subsetplot = true;\n            (0, _plots.barsSubset)(node);\n        }\n    }\n\n    d3.select(\"#setx\").selectAll(\"svg\").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setx_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        var j = vars.indexOf(myname);\n        if (j == -1) {\n            allNodes[nodeid].setxplot = false;\n            var temp = \"#\".concat(myname, \"_setx_\", nodeid);\n            d3.select(temp).remove();\n            allNodes[nodeid].subsetplot = false;\n            var temp = \"#\".concat(myname, \"_tab2_\", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n// easy functions to collapse panels to base\nfunction rightpanelMedium() {\n    d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\nfunction leftpanelMedium() {\n    d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\n// function to convert color codes\nfunction hexToRgba(hex) {\n    var h = hex.replace('#', '');\n    var bigint = parseInt(h, 16);\n    var r = bigint >> 16 & 255;\n    var g = bigint >> 8 & 255;\n    var b = bigint & 255;\n    var a = '0.5';\n    return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\n}\n\n// function takes a node and a color and updates zparams\nfunction setColors(n, c) {\n    if (n.strokeWidth == '1') {\n        // adding time, cs, dv, nom to a node with no stroke\n        n.strokeWidth = '4';\n        n.strokeColor = c;\n        n.nodeCol = taggedColor;\n        if (dvColor == c) {\n            // check if array, if not, make it an array\n            //  console.log(Object.prototype.toString.call(zparams.zdv));\n            zparams.zdv = Object.prototype.toString.call(zparams.zdv) == \"[object Array]\" ? zparams.zdv : [];\n            zparams.zdv.push(n.name);\n        } else if (csColor == c) {\n            zparams.zcross = Object.prototype.toString.call(zparams.zcross) == \"[object Array]\" ? zparams.zcross : [];\n            zparams.zcross.push(n.name);\n        } else if (timeColor == c) {\n            zparams.ztime = Object.prototype.toString.call(zparams.ztime) == \"[object Array]\" ? zparams.ztime : [];\n            zparams.ztime.push(n.name);\n        } else if (nomColor == c) {\n            zparams.znom = Object.prototype.toString.call(zparams.znom) == \"[object Array]\" ? zparams.znom : [];\n            zparams.znom.push(n.name);\n            allNodes[findNodeIndex(n.name)].nature = \"nominal\";\n            transform(n.name, t = null, typeTransform = true);\n        }\n        d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(c));\n    } else if (n.strokeWidth == '4') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = '1';\n            n.strokeColor = selVarColor;\n            n.nodeCol = colors(n.id);\n            d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(selVarColor));\n\n            if (dvColor == c) {\n                var dvIndex = zparams.zdv.indexOf(n.name);\n                if (dvIndex > -1) zparams.zdv.splice(dvIndex, 1);\n            } else if (csColor == c) {\n                var csIndex = zparams.zcross.indexOf(n.name);\n                if (csIndex > -1) zparams.zcross.splice(csIndex, 1);\n            } else if (timeColor == c) {\n                var timeIndex = zparams.ztime.indexOf(n.name);\n                if (timeIndex > -1) zparams.ztime.splice(timeIndex, 1);\n            } else if (nomColor == c) {\n                var nomIndex = zparams.znom.indexOf(n.name);\n                if (nomIndex > -1) {\n                    zparams.znom.splice(nomIndex, 1);\n                    allNodes[findNodeIndex(n.name)].nature = allNodes[findNodeIndex(n.name)].defaultNature;\n                    transform(n.name, t = null, typeTransform = true);\n                }\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            if (dvColor == n.strokeColor) {\n                var dvIndex = zparams.zdv.indexOf(n.name);\n                if (dvIndex > -1) zparams.zdv.splice(dvIndex, 1);\n            } else if (csColor == n.strokeColor) {\n                var csIndex = zparams.zcross.indexOf(n.name);\n                if (csIndex > -1) zparams.zcross.splice(csIndex, 1);\n            } else if (timeColor == n.strokeColor) {\n                var timeIndex = zparams.ztime.indexOf(n.name);\n                if (timeIndex > -1) zparams.ztime.splice(timeIndex, 1);\n            } else if (nomColor == n.strokeColor) {\n                var nomIndex = zparams.znom.indexOf(n.name);\n                if (nomIndex > -1) {\n                    zparams.znom.splice(nomIndex, 1);\n                    allNodes[findNodeIndex(n.name)].nature = allNodes[findNodeIndex(n.name)].defaultNature;\n                    transform(n.name, t = null, typeTransform = true);\n                }\n            }\n            n.strokeColor = c;\n            d3.select(\"#tab1\").select(\"p#\".concat(n.name)).style('background-color', hexToRgba(c));\n\n            if (dvColor == c) zparams.zdv.push(n.name);else if (csColor == c) zparams.zcross.push(n.name);else if (timeColor == c) zparams.ztime.push(n.name);else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                allNodes[findNodeIndex(n.name)].nature = \"nominal\";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\nfunction borderState() {\n    zparams.zdv.length > 0 ? $('#dvButton .rectColor svg circle').attr('stroke', dvColor) : $('#dvButton').css('border-color', '#ccc');\n    zparams.zcross.length > 0 ? $('#csButton .rectColor svg circle').attr('stroke', csColor) : $('#csButton').css('border-color', '#ccc');\n    zparams.ztime.length > 0 ? $('#timeButton .rectColor svg circle').attr('stroke', timeColor) : $('#timeButton').css('border-color', '#ccc');\n    zparams.znom.length > 0 ? $('#nomButton .rectColor svg circle').attr('stroke', nomColor) : $('#nomButton').css('border-color', '#ccc');\n}\n\n// small appearance resets, but perhaps this will become a hard reset back to all original allNode values?\nfunction nodeReset(n) {\n    n.strokeColor = selVarColor;\n    n.strokeWidth = \"1\";\n    n.nodeCol = n.baseCol;\n}\n\nfunction subsetSelect(btn) {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n    zparams.zvars = [];\n    zparams.zplot = [];\n    var subsetEmpty = true;\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        // populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != \"\") {\n                zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            }\n            if (zparams.zsubset[j][1] != \"\") {\n                zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n            }\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != \"\") {\n            subsetEmpty = false;\n        } // only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert(\"Warning: No new subset selected.\");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    var subsetstuff = {\n        zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes\n    };\n\n    var jsonout = JSON.stringify(subsetstuff);\n    var urlcall = rappURL + \"subsetapp\";\n    var solajsonout = \"solaJSON=\" + jsonout;\n    console.log(\"urlcall out: \", urlcall);\n    console.log(\"POST out: \", solajsonout);\n\n    function subsetSelectSuccess(btn, json) {\n        selectLadda.stop(); // stop motion\n        $(\"#btnVariables\").trigger(\"click\"); // programmatic clicks\n        $(\"#btnModels\").trigger(\"click\");\n\n        var grayOuts = [];\n        var rCall = [];\n        rCall[0] = json.call;\n\n        // store contents of the pre-subset space\n        zPop();\n        var myNodes = jQuery.extend(true, [], allNodes);\n        var myParams = jQuery.extend(true, {}, zparams);\n        var myTrans = jQuery.extend(true, [], trans);\n        var myForce = jQuery.extend(true, [], forcetoggle);\n        var myPreprocess = jQuery.extend(true, {}, preprocess);\n        var myLog = jQuery.extend(true, [], logArray);\n        var myHistory = jQuery.extend(true, [], callHistory);\n\n        spaces[myspace] = {\n            \"allNodes\": myNodes,\n            \"zparams\": myParams,\n            \"trans\": myTrans,\n            \"force\": myForce,\n            \"preprocess\": myPreprocess,\n            \"logArray\": myLog,\n            \"callHistory\": myHistory\n        };\n\n        // remove pre-subset svg\n        var selectMe = \"#m\".concat(myspace);\n        d3.select(selectMe).attr('class', 'item');\n        selectMe = \"#whitespace\".concat(myspace);\n        d3.select(selectMe).remove();\n\n        myspace = spaces.length;\n        callHistory.push({\n            func: \"subset\",\n            zvars: jQuery.extend(true, [], zparams.zvars),\n            zsubset: jQuery.extend(true, [], zparams.zsubset),\n            zplot: jQuery.extend(true, [], zparams.zplot)\n        });\n\n        // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n        function varOut(v) {\n            // if in nodes, remove gray out in left panel\n            // make unclickable in left panel\n            for (var i = 0; i < v.length; i++) {\n                var selectMe = v[i].replace(/\\W/g, \"_\");\n                byId(selectMe).style.color = hexToRgba(grayColor);\n                selectMe = \"p#\".concat(selectMe);\n                d3.select(selectMe).on(\"click\", null);\n            }\n        }\n\n        logArray.push(\"subset: \".concat(rCall[0]));\n        showLog();\n        reWriteLog();\n\n        d3.select(\"#innercarousel\").append('div').attr('class', 'item active').attr('id', function () {\n            return \"m\".concat(myspace.toString());\n        }).append('svg').attr('id', 'whitespace');\n        svg = d3.select(\"#whitespace\");\n\n        d3.json(json.url, function (error, json) {\n            if (error) return console.warn(error);\n            var jsondata = json;\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n                allNodes[myIndex].plotx = undefined;\n                allNodes[myIndex].ploty = undefined;\n                allNodes[myIndex].plotvalues = undefined;\n                allNodes[myIndex].plottype = \"\";\n\n                jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n                allNodes[myIndex].subsetplot = false;\n                allNodes[myIndex].subsetrange = [\"\", \"\"];\n                allNodes[myIndex].setxplot = false;\n                allNodes[myIndex].setxvals = [\"\", \"\"];\n\n                if (allNodes[myIndex].valid == 0) {\n                    grayOuts.push(allNodes[myIndex].name);\n                    allNodes[myIndex].grayout = true;\n                }\n            }\n\n            rePlot();\n            populatePopover();\n            layout(v = \"add\");\n        });\n\n        varOut(grayOuts);\n    }\n\n    function subsetSelectFail(btn) {\n        selectLadda.stop(); //stop motion\n    }\n\n    selectLadda.start(); //start button motion\n    makeCorsRequest(urlcall, btn, subsetSelectSuccess, subsetSelectFail, solajsonout);\n}\n\nfunction readPreprocess(url, p, v, callback) {\n    console.log(url);\n    d3.json(url, function (error, json) {\n        if (error) return console.warn(error);\n        var jsondata = json;\n\n        console.log(\"inside readPreprocess function\");\n        console.log(jsondata);\n        console.log(jsondata[\"variables\"]);\n\n        if (jsondata.dataset.priv) {\n            priv = jsondata[\"dataset\"][\"priv\"];\n        };\n\n        //copying the object\n        for (var key in jsondata[\"variables\"]) {\n            p[key] = jsondata[\"variables\"][key];\n        }\n\n        if (typeof callback === \"function\") {\n            callback();\n        }\n    });\n}\n\nfunction about() {\n    $('#about').show();\n}\n\nfunction closeabout() {\n    $('#about').hide();\n}\n\nfunction opencite() {\n    $('#cite').show();\n}\n\nfunction closecite(toggle) {\n    if (toggle == false) $('#cite').hide();\n}\n\nfunction clickcite(toggle) {\n    if (toggle == false) {\n        $('#cite').show();\n        return true;\n    }\n    $('#cite').hide();\n    return false;\n}\n\n// removes all the children svgs inside subset and setx divs\nfunction rePlot() {\n    d3.select('#tab2').selectAll('svg').remove();\n    d3.select('#setx').selectAll('svg').remove();\n    allNodes.forEach(function (n) {\n        n.setxplot = false;\n        n.subsetplot = false;\n    });\n}\n\nfunction showLog() {\n    if (logArray.length > 0) {\n        byId('logdiv').setAttribute(\"style\", \"display:block\");\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n        return;\n    }\n    byId('logdiv').setAttribute(\"style\", \"display:none\");\n}\n\nfunction reWriteLog() {\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n        return d;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nfunction fakeClick() {\n    var myws = \"#whitespace\".concat(myspace);\n    // d3 and programmatic events don't mesh well, here's a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(myws).d3Click();\n    d3.select(myws).classed('active', false);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwX2RkaS5qcz9mYzU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YmFycywgYmFyc05vZGUsIGJhcnNTdWJzZXQsIGRlbnNpdHksIGRlbnNpdHlOb2RlfSBmcm9tICcuL3Bsb3RzLmpzJztcblxuLy8gaG9zdG5hbWUgZGVmYXVsdCAtIHRoZSBhcHAgd2lsbCB1c2UgaXQgdG8gb2J0YWluIHRoZSB2YXJpYWJsZSBtZXRhZGF0YVxuLy8gKGRkaSkgYW5kIHByZS1wcm9jZXNzZWQgZGF0YSBpbmZvIGlmIHRoZSBmaWxlIGlkIGlzIHN1cHBsaWVkIGFzIGFuXG4vLyBhcmd1bWVudCAoZm9yIGV4LiwgZ3VpLmh0bWw/ZGZJZD0xNyksIGJ1dCBob3N0bmFtZSBpc24ndC5cbi8vIEVkaXQgaXQgdG8gc3VpdCB5b3VyIGluc3RhbGxhdGlvbi5cbi8vIChOT1RFIHRoYXQgaWYgdGhlIGZpbGUgaWQgaXNuJ3Qgc3VwcGxpZWQsIHRoZSBhcHAgd2lsbCBkZWZhdWx0IHRvIHRoZVxuLy8gbG9jYWwgZmlsZXMgc3BlY2lmaWVkIGJlbG93ISlcbi8vIE5FVzogaXQgaXMgYWxzbyBwb3NzaWJsZSBub3cgdG8gc3VwcGx5IGNvbXBsZXRlIHVybHMgZm9yIHRoZSBkZGkgYW5kXG4vLyB0aGUgdGFiLWRlbGltaXRlZCBkYXRhIGZpbGU7IHRoZSBwYXJhbWV0ZXJzIGFyZSBkZGl1cmwgYW5kIGRhdGF1cmwuXG4vLyBUaGVzZSBuZXcgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIElmIHRoZXkgYXJlIG5vdCBzdXBwbGllZCwgdGhlIGFwcFxuLy8gd2lsbCBnbyB0aGUgb2xkIHJvdXRlIC0gd2lsbCB0cnkgdG8gY29vayBzdGFuZGFyZCBkYXRhdmVyc2UgdXJsc1xuLy8gZm9yIGJvdGggdGhlIGRhdGEgYW5kIG1ldGFkYXRhLCBpZiB0aGUgZmlsZSBpZCBpcyBzdXBwbGllZDsgb3IgdGhlXG4vLyBsb2NhbCBmaWxlcyBpZiBub3RoaW5nIGlzIHN1cHBsaWVkLlxuXG52YXIgcHJvZHVjdGlvbiA9IGZhbHNlO1xudmFyIHJhcHBVUkwgPSAocHJvZHVjdGlvbiA/ICdodHRwczovL2JldGEuZGF0YXZlcnNlLm9yZy8nIDogJ2h0dHA6Ly8wLjAuMC4wOjgwMDAvJykgKyAnL2N1c3RvbS8nO1xuXG4vLyBpbml0aWFsIGNvbG9yIHNjYWxlIHVzZWQgdG8gZXN0YWJsaXNoIHRoZSBpbml0aWFsIGNvbG9ycyBvZiBub2Rlc1xuLy8gYWxsTm9kZXMucHVzaCgpIGJlbG93IGVzdGFibGlzaGVzIGEgZmllbGQgZm9yIHRoZSBtYXN0ZXIgbm9kZSBhcnJheSBhbGxOb2RlcyBjYWxsZWQgXCJub2RlQ29sXCIgYW5kIGFzc2lnbnMgYSBjb2xvciBmcm9tIHRoaXMgc2NhbGUgdG8gdGhhdCBmaWVsZFxuLy8gZXZlcnl0aGluZyB0aGVyZSBhZnRlciBzaG91bGQgcmVmZXIgdG8gdGhlIG5vZGVDb2wgYW5kIG5vdCB0aGUgY29sb3Igc2NhbGUsIHRoaXMgZW5hYmxlcyB1cyB0byB1cGRhdGUgY29sb3JzIGFuZCBwYXNzIHRoZSB2YXJpYWJsZSB0eXBlIHRvIFIgYmFzZWQgb24gaXRzIGNvbG9yaW5nXG52YXIgY29sb3JzID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpO1xudmFyIGNzQ29sb3IgPSAnIzQxOTY0MSc7XG52YXIgZHZDb2xvciA9ICcjMjhhNGM5JztcbnZhciBncmF5Q29sb3IgPSAnI2MwYzBjMCc7XG52YXIgbm9tQ29sb3IgPSAnI2ZmNjYwMCc7XG52YXIgc2VsVmFyQ29sb3IgPSAnI2ZhODA3Mic7IC8vZDMucmdiKFwic2FsbW9uXCIpO1xudmFyIHRhZ2dlZENvbG9yID0gJyNmNWY1ZjUnOyAvL2QzLnJnYihcIndoaXRlc21va2VcIik7XG52YXIgdGltZUNvbG9yID0gJyMyZDZjYTInO1xudmFyIHZhckNvbG9yID0gJyNmMGY4ZmYnOyAvL2QzLnJnYihcImFsaWNlYmx1ZVwiKTtcblxudmFyIGxlZnR0YWIgPSBcInRhYjFcIjsgLy8gY3VycmVudCB0YWIgaW4gbGVmdCBwYW5lbFxudmFyIHJpZ2h0dGFiID0gXCJidG5Nb2RlbHNcIjsgLy8gY3VycmVudCB0YWIgaW4gcmlnaHQgcGFuZWxcblxuLy8gdHJhbnNmb3JtYXRpb24gdG9vbGJhciBvcHRpb25zXG52YXIgdHJhbnNmb3JtTGlzdCA9ICdsb2coZCkgZXhwKGQpIGReMiBzcXJ0KGQpIGludGVyYWN0KGQsZSknLnNwbGl0KCk7XG52YXIgdHJhbnNmb3JtVmFyID0gJyc7XG5cbi8vIFJhZGl1cyBvZiBjaXJjbGVcbnZhciBhbGxSID0gNDA7XG5cbi8vIHNwYWNlIGluZGV4XG52YXIgbXlzcGFjZSA9IDA7XG5cbnZhciBmb3JjZXRvZ2dsZSA9IFtcInRydWVcIl07XG52YXIgcHJpdiA9IGZhbHNlO1xuXG52YXIgenBhcmFtcyA9IHtcbiAgICB6ZGF0YTogW10sXG4gICAgemVkZ2VzOiBbXSxcbiAgICB6dGltZTogW10sXG4gICAgem5vbTogW10sXG4gICAgemNyb3NzOiBbXSxcbiAgICB6bW9kZWw6IFwiXCIsXG4gICAgenZhcnM6IFtdLFxuICAgIHpkdjogW10sXG4gICAgemRhdGF1cmw6IFwiXCIsXG4gICAgenN1YnNldDogW10sXG4gICAgenNldHg6IFtdLFxuICAgIHptb2RlbGNvdW50OiAwLFxuICAgIHpwbG90OiBbXSxcbiAgICB6c2Vzc2lvbmlkOiBcIlwiLFxuICAgIHpkYXRhY2l0ZTogXCJcIlxufTtcblxudmFyIG1vZGVsQ291bnQgPSAwO1xudmFyIHN1bW1hcnlIb2xkID0gZmFsc2U7XG5cbnZhciB2YWx1ZUtleSA9IFtdO1xudmFyIGFsbE5vZGVzID0gW107XG52YXIgbm9kZXMgPSBbXTtcbnZhciBsaW5rcyA9IFtdO1xudmFyIG1vZHMgPSB7fTtcbnZhciByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xudmFyIHNlbEludGVyYWN0ID0gZmFsc2U7XG52YXIgY2FsbEhpc3RvcnkgPSBbXTsgLy8gdW5pcXVlIHRvIHRoZSBzcGFjZS4gc2F2ZXMgdHJhbnNmb3JtIGFuZCBzdWJzZXQgY2FsbHMuXG5cbnZhciBzdmcsIHdpZHRoLCBoZWlnaHQsIGRpdiwgb2JqLCBlc3RpbWF0ZUxhZGRhLCBzZWxlY3RMYWRkYTtcbnZhciBhcmMzLCBhcmM0O1xuXG5mdW5jdGlvbiBieUlkKGlkKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbn1cblxudmFyIGRhdGF1cmw7XG5leHBvcnQgZnVuY3Rpb24gbWFpbihmaWxlaWQsIGhvc3RuYW1lLCBkZGl1cmwsIGRhdGF1cmwpIHtcbiAgICBkYXRhdXJsID0gZGF0YXVybDtcbiAgICBpZiAocHJvZHVjdGlvbiAmJiBmaWxlaWQgPT0gXCJcIikge1xuICAgICAgICBhbGVydChcIkVycm9yOiBObyBmaWxlaWQgaGFzIGJlZW4gcHJvdmlkZWQuXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvcjogTm8gZmlsZWlkIGhhcyBiZWVuIHByb3ZpZGVkLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YXZlcnNldXJsID0gXCJcIjtcbiAgICBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgZGF0YXZlcnNldXJsID0gXCJodHRwczovL1wiICsgaG9zdG5hbWU7XG4gICAgfSBlbHNlIGlmIChwcm9kdWN0aW9uKSB7XG4gICAgICAgIGRhdGF2ZXJzZXVybCA9IFwiJVBST0RVQ1RJT05fREFUQVZFUlNFX1VSTCVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhdmVyc2V1cmwgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MFwiO1xuICAgIH1cblxuICAgIGlmIChmaWxlaWQgJiYgIWRhdGF1cmwpIHtcbiAgICAgICAgLy8gZmlsZSBpZCBzdXBwbGllZDsgYXNzdW1lIHdlIGFyZSBkZWFsaW5nIHdpdGggZGF0YXZlcnNlIGFuZCBjb29rIGEgc3RhbmRhcmQgZGF0YXZlcnNlIGRhdGEgYWNjZXNzIHVybFxuICAgICAgICAvLyB3aXRoIHRoZSBmaWxlaWQgc3VwcGxpZWQgYW5kIHRoZSBob3N0bmFtZSB3ZSBoYXZlIHN1cHBsaWVkIG9yIGNvbmZpZ3VyZWRcbiAgICAgICAgZGF0YXVybCA9IGRhdGF2ZXJzZXVybCArIFwiL2FwaS9hY2Nlc3MvZGF0YWZpbGUvXCIgKyBmaWxlaWQ7XG4gICAgICAgIGRhdGF1cmwgPSBkYXRhdXJsICsgXCI/a2V5PVwiICsgYXBpa2V5O1xuICAgIH1cblxuICAgIHN2ZyA9IGQzLnNlbGVjdChcIiNtYWluLmxlZnQgZGl2LmNhcm91c2VsLWlubmVyXCIpLmF0dHIoJ2lkJywgJ2lubmVyY2Fyb3VzZWwnKVxuICAgICAgICAuYXBwZW5kKCdkaXYnKS5hdHRyKCdjbGFzcycsICdpdGVtIGFjdGl2ZScpLmF0dHIoJ2lkJywgJ20wJykuYXBwZW5kKCdzdmcnKS5hdHRyKCdpZCcsICd3aGl0ZXNwYWNlJyk7XG5cbiAgICB2YXIgbG9nQXJyYXkgPSBbXTtcblxuICAgIHZhciB0ZW1wV2lkdGggPSBkMy5zZWxlY3QoXCIjbWFpbi5sZWZ0XCIpLnN0eWxlKFwid2lkdGhcIik7XG4gICAgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsICh0ZW1wV2lkdGgubGVuZ3RoIC0gMikpO1xuICAgIGhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSAtIDEyMDsgLy8gSGFyZCBjb2RpbmcgZm9yIGhlYWRlciBhbmQgZm9vdGVyIGFuZCBib3R0b20gbWFyZ2luLlxuXG4gICAgdmFyIGVzdGltYXRlZCA9IGZhbHNlO1xuICAgIGVzdGltYXRlTGFkZGEgPSBMYWRkYS5jcmVhdGUoYnlJZChcImJ0bkVzdGltYXRlXCIpKTtcbiAgICBzZWxlY3RMYWRkYSA9IExhZGRhLmNyZWF0ZShieUlkKFwiYnRuU2VsZWN0XCIpKTtcblxuICAgIHZhciBjb2xvclRpbWUgPSBmYWxzZTtcbiAgICB2YXIgY29sb3JDUyA9IGZhbHNlO1xuXG4gICAgdmFyIGRlcFZhciA9IGZhbHNlO1xuICAgIHZhciBzdWJzZXRkaXYgPSBmYWxzZTtcbiAgICB2YXIgc2V0eGRpdiA9IGZhbHNlO1xuXG4gICAgLy9XaWR0aCBhbmQgaGVpZ2h0IGZvciBoaXN0Z3JhbXNcbiAgICB2YXIgYmFyd2lkdGggPSAxLjMgKiBhbGxSO1xuICAgIHZhciBiYXJoZWlnaHQgPSAwLjUgKiBhbGxSO1xuICAgIHZhciBiYXJQYWRkaW5nID0gMC4zNTtcbiAgICB2YXIgYmFybnVtYmVyID0gNztcblxuICAgIHZhciBhcmMwID0gZDMuc3ZnLmFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cyhhbGxSICsgNSlcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAyMClcbiAgICAgICAgLnN0YXJ0QW5nbGUoMClcbiAgICAgICAgLmVuZEFuZ2xlKDMuMik7XG4gICAgdmFyIGFyYzEgPSBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyA1KVxuICAgICAgICAub3V0ZXJSYWRpdXMoYWxsUiArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSgwKVxuICAgICAgICAuZW5kQW5nbGUoMSk7XG4gICAgdmFyIGFyYzIgPSBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyA1KVxuICAgICAgICAub3V0ZXJSYWRpdXMoYWxsUiArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSgxLjEpXG4gICAgICAgIC5lbmRBbmdsZSgyLjIpO1xuICAgIGFyYzMgPSBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyA1KVxuICAgICAgICAub3V0ZXJSYWRpdXMoYWxsUiArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSgyLjMpXG4gICAgICAgIC5lbmRBbmdsZSgzLjMpO1xuICAgIGFyYzQgPSBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyA1KVxuICAgICAgICAub3V0ZXJSYWRpdXMoYWxsUiArIDIwKVxuICAgICAgICAuc3RhcnRBbmdsZSg0LjMpXG4gICAgICAgIC5lbmRBbmdsZSg1LjMpO1xuXG4gICAgLy8gRnJvbSAuY3N2XG4gICAgdmFyIGRhdGFzZXQyID0gW107XG4gICAgdmFyIGxhYmxBcnJheSA9IFtdO1xuICAgIHZhciBob2xkID0gW107XG4gICAgdmFyIGFsbFJlc3VsdHMgPSBbXTtcbiAgICB2YXIgc3Vic2V0Tm9kZXMgPSBbXTtcbiAgICB2YXIgY2l0ZXRvZ2dsZSA9IGZhbHNlO1xuXG4gICAgdmFyIHNwYWNlcyA9IFtdO1xuICAgIHZhciB0cmFucyA9IFtdOyAvLyB2YXIgbGlzdCBmb3IgZWFjaCBzcGFjZSBjb250YWluIHZhcmlhYmxlcyBpbiBvcmlnaW5hbCBkYXRhIHBsdXMgdHJhbnMgaW4gdGhhdCBzcGFjZVxuXG4gICAgLy8gY29sbGFwc2FibGUgdXNlciBsb2dcbiAgICAkKCcjY29sbGFwc2VMb2cnKS5vbignc2hvd24uYnMuY29sbGFwc2UnLCAoKSA9PiB7XG4gICAgICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAuZGF0YShsb2dBcnJheSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcbiAgICB9KTtcbiAgICAkKCcjY29sbGFwc2VMb2cnKS5vbignaGlkZGVuLmJzLmNvbGxhcHNlJywgKCkgPT4ge1xuICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgIH0pO1xuXG4gICAgJCgnI2Fib3V0IGRpdi5wYW5lbC1ib2R5JykudGV4dCgnVHdvUmF2ZW5zIHYwLjEgXCJEYWxsYXNcIiAtLSBUaGUgTm9yc2UgZ29kIE9kaW4gaGFkIHR3byB0YWxraW5nIHJhdmVucyBhcyBhZHZpc29ycywgd2hvIHdvdWxkIGZseSBvdXQgaW50byB0aGUgd29ybGQgYW5kIHJlcG9ydCBiYWNrIGFsbCB0aGV5IG9ic2VydmVkLiAgSW4gdGhlIE5vcnNlLCB0aGVpciBuYW1lcyB3ZXJlIFwiVGhvdWdodFwiIGFuZCBcIk1lbW9yeVwiLiAgSW4gb3VyIGNvbWluZyByZWxlYXNlLCBvdXIgdGhvdWdodC1yYXZlbiBhdXRvbWF0aWNhbGx5IGFkdmlzZXMgb24gc3RhdGlzdGljYWwgbW9kZWwgc2VsZWN0aW9uLCB3aGlsZSBvdXIgbWVtb3J5LXJhdmVuIGFjY3VtdWxhdGVzIHByZXZpb3VzIHN0YXRpc3RpY2FsIG1vZGVscyBmcm9tIERhdGF2ZXJzZSwgdG8gcHJvdmlkZSBjdW1tdWxhdGl2ZSBndWlkYW5jZSBhbmQgbWV0YS1hbmFseXNpcy4nKTtcblxuICAgIC8vIHJlYWQgRERJIG1ldGFkYXRhIHdpdGggZDNcbiAgICB2YXIgbWV0YWRhdGF1cmwgPSBcIlwiO1xuICAgIGlmIChkZGl1cmwpIHtcbiAgICAgICAgbWV0YWRhdGF1cmwgPSBkZGl1cmw7XG4gICAgfSBlbHNlIGlmIChmaWxlaWQpIHtcbiAgICAgICAgLy8gZmlsZSBpZCBzdXBwbGllZDsgd2UncmUgZ29pbmcgdG8gY29vayBhIHN0YW5kYXJkIGRhdGF2ZXJzZVxuICAgICAgICAvLyBtZXRhZGF0YSB1cmwsIHdpdGggdGhlIGZpbGUgaWQgcHJvdmlkZWQgYW5kIHRoZSBob3N0bmFtZVxuICAgICAgICAvLyBzdXBwbGllZCBvciBjb25maWd1cmVkXG4gICAgICAgIG1ldGFkYXRhdXJsID0gZGF0YXZlcnNldXJsICsgXCIvYXBpL21ldGEvZGF0YWZpbGUvXCIgKyBmaWxlaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmVpdGhlciBhIGZ1bGwgZGRpIHVybCwgbm9yIGZpbGUgaWQgc3VwcGxpZWRcbiAgICAgICAgbWV0YWRhdGF1cmwgPSBcImRhdGEvUFVNUzVzbWFsbC1kZGkueG1sXCI7IC8vIENhbGlmb3JuaWEgUFVNUyBzdWJzZXRcbiAgICB9XG5cbiAgICAvLyByZWFkIHByZS1wcm9jZXNzZWQgbWV0YWRhdGEgYW5kIGRhdGFcbiAgICBsZXQgcFVSTCA9IGRhdGF1cmwgPyBkYXRhdXJsICsgXCImZm9ybWF0PXByZXBcIiBcbiAgICAgICAgOlwiZGF0YS9wcmVwcm9jZXNzUFVNUzVzbWFsbC5qc29uXCI7IC8vIENhbGlmb3JuaWEgUFVNUyBzdWJzZXRcblxuICAgIHZhciBwcmVwcm9jZXNzID0ge307XG5cbiAgICAvLyBsb2FkcyBhbGwgZXh0ZXJuYWwgZGF0YTogbWV0YWRhdGEgKERWTidzIGRkaSksIHByZXByb2Nlc3NlZCAoZm9yIHBsb3R0aW5nIGRpc3RyaWJ1dGlvbnMpLCBhbmQgemVsaWdtb2RlbHMgKHByb2R1Y2VkIGJ5IFplbGlnKSBhbmQgaW5pdGlhdGVzIHRoZSBkYXRhIGRvd25sb2FkIHRvIHRoZSBzZXJ2ZXJcbiAgICB2YXIgdXJsLCBwLCB2LCBjYWxsYmFjaztcbiAgICByZWFkUHJlcHJvY2Vzcyh1cmwgPSBwVVJMLCBwID0gcHJlcHJvY2VzcywgdiA9IG51bGwsIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzLnhtbChtZXRhZGF0YXVybCwgXCJhcHBsaWNhdGlvbi94bWxcIiwgeG1sID0+IHtcbiAgICAgICAgICAgIHZhciB2YXJzID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInZhclwiKTtcbiAgICAgICAgICAgIHZhciB0ZW1wID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZpbGVOYW1lXCIpO1xuICAgICAgICAgICAgenBhcmFtcy56ZGF0YSA9IHRlbXBbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIC8vIGNsZWFuIHRoZSBjaXRhdGlvbiBzbyB0aGF0IHRoZSBQT1NUIGlzIHZhbGlkIGpzb25cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsZWFuc3RyaW5nKHMpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKC9cXCYvZywgXCJhbmRcIik7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXFw7L2csIFwiLFwiKTtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKC9cXCUvZywgXCItXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2l0ZSA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiaWJsQ2l0XCIpO1xuICAgICAgICAgICAgenBhcmFtcy56ZGF0YWNpdGUgPSBjaXRlWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgenBhcmFtcy56ZGF0YWNpdGUgPSBjbGVhbnN0cmluZyh6cGFyYW1zLnpkYXRhY2l0ZSk7XG4gICAgICAgICAgICAvLyBkYXRhc2V0IG5hbWUgdHJpbW1lZCB0byAxMiBjaGFyc1xuICAgICAgICAgICAgdmFyIGRhdGFuYW1lID0genBhcmFtcy56ZGF0YS5yZXBsYWNlKC9cXC4oLiopLywgXCJcIik7IC8vIGRyb3AgYW55IGZpbGUgZXh0ZW5zaW9uXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjZGF0YU5hbWVcIilcbiAgICAgICAgICAgICAgICAuaHRtbChkYXRhbmFtZSk7XG4gICAgICAgICAgICAkKCcjY2l0ZSBkaXYucGFuZWwtYm9keScpLnRleHQoenBhcmFtcy56ZGF0YWNpdGUpO1xuXG4gICAgICAgICAgICAvLyBQdXQgZGF0YXNldCBuYW1lLCBmcm9tIG1ldGEtZGF0YSwgaW50byBwYWdlIHRpdGxlXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCJ0aXRsZVwiKS5odG1sKFwiVHdvUmF2ZW5zIFwiICsgZGF0YW5hbWUpXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFsdWVzIGZvciBob2xkIHRoYXQgY29ycmVzcG9uZCB0byBoaXN0b2dyYW0gYmluc1xuICAgICAgICAgICAgaG9sZCA9IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUtleVtpXSA9IHZhcnNbaV0uYXR0cmlidXRlcy5uYW1lLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICBsYWJsQXJyYXlbaV0gPSB2YXJzW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKS5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIFwibm8gbGFiZWxcIiA6XG4gICAgICAgICAgICAgICAgICAgIHZhcnNbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhc2V0Y291bnQgPSBkMy5sYXlvdXQuaGlzdG9ncmFtKClcbiAgICAgICAgICAgICAgICAgICAgLmJpbnMoYmFybnVtYmVyKS5mcmVxdWVuY3koZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIChbMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZXMgYW4gb2JqZWN0IHRvIGJlIHB1c2hlZCB0byBhbGxOb2Rlc1xuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIGFsbCB0aGUgcHJlcHJvY2Vzc2VkIGRhdGEgd2UgaGF2ZSBmb3IgdGhlIHZhcmlhYmxlLCBhcyB3ZWxsIGFzIFVJIGRhdGEgcGVydGluZW50IHRvIHRoYXQgdmFyaWFibGUsIHN1Y2ggYXMgc2V0eCB2YWx1ZXMgKGlmIHRoZSB1c2VyIGhhcyBzZWxlY3RlZCB0aGVtKSBhbmQgcGViYmxlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgdmFyIG9iajEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICByZWZsZXhpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogdmFsdWVLZXlbaV0sXG4gICAgICAgICAgICAgICAgICAgIFwibGFibFwiOiBsYWJsQXJyYXlbaV0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFs1LCAxNSwgMjAsIDAsIDUsIDE1LCAyMF0sXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBob2xkLFxuICAgICAgICAgICAgICAgICAgICBcIm5vZGVDb2xcIjogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICBcImJhc2VDb2xcIjogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICBcInN0cm9rZUNvbG9yXCI6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBcInN0cm9rZVdpZHRoXCI6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN1YnNldHBsb3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwic3Vic2V0cmFuZ2VcIjogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICBcInNldHhwbG90XCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcInNldHh2YWxzXCI6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgXCJncmF5b3V0XCI6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG9iajEsIHByZXByb2Nlc3NbdmFsdWVLZXlbaV1dKTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iajEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gcmVhZCB0aGUgemVsaWcgbW9kZWxzIGFuZCBwb3B1bGF0ZSBtb2RlbCBsaXN0IGluIHJpZ2h0IHBhbmVsXG4gICAgICAgICAgICBkMy5qc29uKFwiZGF0YS96ZWxpZzVtb2RlbHMuanNvblwiLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiemVsaWcgbW9kZWxzIGpzb246IFwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YS56ZWxpZzVtb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuemVsaWc1bW9kZWxzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RzW2RhdGEuemVsaWc1bW9kZWxzW2tleV0ubmFtZVswXV0gPSBkYXRhLnplbGlnNW1vZGVsc1trZXldLmRlc2NyaXB0aW9uWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkMy5qc29uKFwiZGF0YS96ZWxpZzVjaG9pY2Vtb2RlbHMuanNvblwiLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiemVsaWcgY2hvaWNlIG1vZGVscyBqc29uOiBcIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhLnplbGlnNWNob2ljZW1vZGVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kc1tkYXRhLnplbGlnNWNob2ljZW1vZGVsc1trZXldLm5hbWVbMF1dID0gZGF0YS56ZWxpZzVjaG9pY2Vtb2RlbHNba2V5XS5kZXNjcmlwdGlvblswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY2FmZm9sZGluZyhjYWxsYmFjayA9IGxheW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFEb3dubG9hZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vLyBzY2FmZm9sZGluZyBpcyBjYWxsZWQgYWZ0ZXIgYWxsIGV4dGVybmFsIGRhdGEgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSBiZWVuIHJlYWQgdG8gY29tcGxldGlvbi4gdGhpcyBwb3B1bGF0ZXMgdGhlIGxlZnQgcGFuZWwgd2l0aCB2YXJpYWJsZSBuYW1lcywgdGhlIHJpZ2h0IHBhbmVsIHdpdGggbW9kZWwgbmFtZXMsIHRoZSB0cmFuc2Zvcm1hdGlvbiB0b29sLCBhbiB0aGUgYXNzb2NpYXRlZCBtb3VzZW92ZXJzLiBpdHMgY2FsbGJhY2sgaXMgbGF5b3V0KCksIHdoaWNoIGluaXRpYWxpemVzIHRoZSBtb2RlbGluZyBzcGFjZVxuZnVuY3Rpb24gc2NhZmZvbGRpbmcoY2FsbGJhY2spIHtcbiAgICAvLyBlc3RhYmxpc2hpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIGVsZW1lbnRcbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gICAgICAgIC5hcHBlbmQoXCJpbnB1dFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwidElucHV0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJmb3JtLWNvbnRyb2xcIilcbiAgICAgICAgLmF0dHIoXCJ0eXBlXCIsIFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInZhbHVlXCIsIFwiVmFyaWFibGUgdHJhbnNmb3JtYXRpb25cIik7XG5cbiAgICAvLyB2YXJpYWJsZSBkcm9wZG93blxuICAgIGQzLnNlbGVjdChcIiN0cmFuc2Zvcm1hdGlvbnNcIilcbiAgICAgICAgLmFwcGVuZChcInVsXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJ0cmFuc1NlbFwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHZhckNvbG9yKVxuICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgIC5kYXRhKFtcImFcIiwgXCJiXCJdKSAvL3NldCB0byB2YXJpYWJsZXMgaW4gbW9kZWwgc3BhY2UgYXMgdGhleSdyZSBhZGRlZFxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgIC8vIGZ1bmN0aW9uIGRyb3Bkb3duXG4gICAgZDMuc2VsZWN0KFwiI3RyYW5zZm9ybWF0aW9uc1wiKVxuICAgICAgICAuYXBwZW5kKFwidWxcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInRyYW5zTGlzdFwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHZhckNvbG9yKVxuICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgIC5kYXRhKHRyYW5zZm9ybUxpc3QpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJsaVwiKVxuICAgICAgICAudGV4dChkID0+IGQpO1xuXG4gICAgJCgnI3RJbnB1dCcpLmNsaWNrKCgpID0+IHtcbiAgICAgICAgdmFyIHQgPSBieUlkKCd0cmFuc1NlbCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmICh0ICE9PSBcIm5vbmVcIikgeyAvLyBpZiB2YXJpYWJsZSBsaXN0IGlzIGRpc3BsYXllZCB3aGVuIGlucHV0IGlzIGNsaWNrZWQuLi5cbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdDEgPSBieUlkKCd0cmFuc0xpc3QnKS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICBpZiAodDEgIT09IFwibm9uZVwiKSB7IC8vIGlmIGZ1bmN0aW9uIGxpc3QgaXMgZGlzcGxheWVkIHdoZW4gaW5wdXQgaXMgY2xpY2tlZC4uLlxuICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhpZ2hsaWdodCB0aGUgdGV4dFxuICAgICAgICAkKHRoaXMpLnNlbGVjdCgpO1xuICAgICAgICB2YXIgcG9zID0gJCgnI3RJbnB1dCcpLm9mZnNldCgpO1xuICAgICAgICBwb3MudG9wICs9ICQoJyN0SW5wdXQnKS53aWR0aCgpO1xuICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgdmFyIG4sIHR5cGVUcmFuc2Zvcm07XG5cbiAgICAkKCcjdElucHV0Jykua2V5dXAoZXZlbnQgPT4ge1xuICAgICAgICB2YXIgdCA9IGJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgdmFyIHQxID0gYnlJZCgndHJhbnNMaXN0Jykuc3R5bGUuZGlzcGxheTtcblxuICAgICAgICBpZiAodCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgfSBlbHNlIGlmICh0MSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBrZXl1cCBvbiBFbnRlclxuICAgICAgICAgICAgbiA9ICQoJyN0SW5wdXQnKS52YWwoKTtcbiAgICAgICAgICAgIHZhciB0ID0gdHJhbnNQYXJzZShuID0gbik7XG4gICAgICAgICAgICBpZiAodCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmFuc2Zvcm0obiA9IHQuc2xpY2UoMCwgdC5sZW5ndGggLSAxKSwgdCA9IHRbdC5sZW5ndGggLSAxXSwgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHQ7XG4gICAgJCgnI3RyYW5zTGlzdCBsaScpLmNsaWNrKGV2ZW50ID0+IHtcbiAgICAgICAgLy8gaWYgaW50ZXJhY3QgaXMgc2VsZWN0ZWQsIHNob3cgdmFyaWFibGUgbGlzdCBhZ2FpblxuICAgICAgICBpZiAoJCh0aGlzKS50ZXh0KCkgPT09IFwiaW50ZXJhY3QoZCxlKVwiKSB7XG4gICAgICAgICAgICAkKCcjdElucHV0JykudmFsKHR2YXIuY29uY2F0KCcqJykpO1xuICAgICAgICAgICAgc2VsSW50ZXJhY3QgPSB0cnVlO1xuICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYW5kZU91dCgxMDApO1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0dmFyID0gJCgnI3RJbnB1dCcpLnZhbCgpO1xuICAgICAgICB2YXIgdGZ1bmMgPSAkKHRoaXMpLnRleHQoKS5yZXBsYWNlKFwiZFwiLCBcIl90cmFuc3ZhcjBcIik7XG4gICAgICAgIHZhciB0Y2FsbCA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAkKCcjdElucHV0JykudmFsKHRjYWxsKTtcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0cmFuc2Zvcm0obiA9IHR2YXIsIHQgPSB0ZnVuYywgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRpbmcgdGhlIHZhcmlhYmxlIGxpc3QgaW4gdGhlIGxlZnQgcGFuZWxcbiAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKHZhbHVlS2V5KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAvLyByZXBsYWNlIG5vbi1hbHBoYW51bWVyaWNzIGZvciBzZWxlY3Rpb24gcHVycG9zZXNcbiAgICAgICAgLy8gcGVyaGFwcyBlbnN1cmUgdGhpcyBpZCBpcyB1bmlxdWUgYnkgYWRkaW5nICdfJyB0byB0aGUgZnJvbnQ/XG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZCA9PiBkLnJlcGxhY2UoL1xcVy9nLCBcIl9cIikpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZCA9PiBmaW5kTm9kZUluZGV4KGQpID4gMiA/IHZhckNvbG9yIDogaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSlcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRhaW5lclwiLCBcImJvZHlcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRvZ2dsZVwiLCBcInBvcG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRyaWdnZXJcIiwgXCJob3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtcGxhY2VtZW50XCIsIFwicmlnaHRcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJTdW1tYXJ5IFN0YXRpc3RpY3NcIik7XG5cbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpXG4gICAgICAgIC5zdHlsZSgnaGVpZ2h0JywgMjAwMClcbiAgICAgICAgLnN0eWxlKCdvdmVyZmlsbCcsICdzY3JvbGwnKTtcblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuZGF0YShPYmplY3Qua2V5cyhtb2RzKSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcIl9tb2RlbF9cIi5jb25jYXQpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZCA9PiB2YXJDb2xvcilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRhaW5lclwiLCBcImJvZHlcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRvZ2dsZVwiLCBcInBvcG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRyaWdnZXJcIiwgXCJob3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtcGxhY2VtZW50XCIsIFwidG9wXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1odG1sXCIsIFwidHJ1ZVwiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdmVyXCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3V0XCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIsIFwiTW9kZWwgRGVzY3JpcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZCA9PiBtb2RzW2RdKTtcblxuICAgIC8vIGNhbGwgbGF5b3V0KCkgYmVjYXVzZSBhdCB0aGlzIHBvaW50IGFsbCBzY2FmZm9sZGluZyBpcyB1cCBhbmQgcmVhZHlcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrKCk7XG59XG5cbmZ1bmN0aW9uIGxheW91dCh2KSB7XG4gICAgdmFyIG15VmFsdWVzID0gW107XG4gICAgbm9kZXMgPSBbXTtcbiAgICBsaW5rcyA9IFtdO1xuXG4gICAgaWYgKHYgPT09IFwiYWRkXCIgfCB2ID09PSBcIm1vdmVcIikge1xuICAgICAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKS5zZWxlY3RBbGwoXCJwXCIpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgdmFyQ29sb3IpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuenZhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBpaSA9IGZpbmROb2RlSW5kZXgoenBhcmFtcy56dmFyc1tqXSk7XG4gICAgICAgICAgICBpZiAoYWxsTm9kZXNbaWldLmdyYXlvdXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGFsbE5vZGVzW2lpXSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB6cGFyYW1zLnp2YXJzW2pdLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICBzZWxlY3RNZSA9IFwiI1wiLmNvbmNhdChzZWxlY3RNZSk7XG4gICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgKCkgPT4gaGV4VG9SZ2JhKG5vZGVzW2pdLnN0cm9rZUNvbG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuemVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbXlzcmMgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMF0pO1xuICAgICAgICAgICAgdmFyIG15dGd0ID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzFdKTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbbXlzcmNdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbbXl0Z3RdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbGxOb2Rlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV0sIGFsbE5vZGVzWzJdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV1dO1xuICAgICAgICAgICAgbGlua3MgPSBbe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydChcIlRoZXJlIGFyZSB6ZXJvIHZhcmlhYmxlcyBpbiB0aGUgbWV0YWRhdGEuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFuZWxQbG90cygpOyAvLyBhZnRlciBub2RlcyBpcyBwb3B1bGF0ZWQsIGFkZCBzdWJzZXQgYW5kIHNldHggcGFuZWxzXG4gICAgcG9wdWxhdGVQb3BvdmVyKCk7IC8vIHBpcGVzIGluIHRoZSBzdW1tYXJ5IHN0YXRzIHNob3duIG9uIG1vdXNlb3ZlcnNcblxuICAgIHZhciBmb3JjZSA9IGQzLmxheW91dC5mb3JjZSgpXG4gICAgICAgIC5ub2Rlcyhub2RlcylcbiAgICAgICAgLmxpbmtzKGxpbmtzKVxuICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pXG4gICAgICAgIC5saW5rRGlzdGFuY2UoMTUwKVxuICAgICAgICAuY2hhcmdlKC04MDApXG4gICAgICAgIC5vbigndGljaycsIHRpY2spO1xuXG4gICAgLy8gZGVmaW5lIGFycm93IG1hcmtlcnMgZm9yIGdyYXBoIGxpbmtzXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnZW5kLWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNilcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RhcnQtYXJyb3cnKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDEwIDEwJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCA0KVxuICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCAzKVxuICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgMylcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMTAsLTVMMCwwTDEwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgLy8gbGluZSBkaXNwbGF5ZWQgd2hlbiBkcmFnZ2luZyBuZXcgbm9kZXNcbiAgICB2YXIgZHJhZ19saW5lID0gc3ZnLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluayBkcmFnbGluZSBoaWRkZW4nKVxuICAgICAgICAuYXR0cignZCcsICdNMCwwTDAsMCcpO1xuXG4gICAgLy8gaGFuZGxlcyB0byBsaW5rIGFuZCBub2RlIGVsZW1lbnQgZ3JvdXBzXG4gICAgdmFyIHBhdGggPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgncGF0aCcpLFxuICAgICAgICBjaXJjbGUgPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgnZycpO1xuXG4gICAgLy8gbW91c2UgZXZlbnQgdmFyc1xuICAgIHZhciBzZWxlY3RlZF9ub2RlID0gbnVsbCxcbiAgICAgICAgc2VsZWN0ZWRfbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbCxcbiAgICAgICAgbW91c2Vkb3duX25vZGUgPSBudWxsLFxuICAgICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRNb3VzZVZhcnMoKSB7XG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbDtcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcbiAgICAgICAgbW91c2Vkb3duX2xpbmsgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBmb3JjZSBsYXlvdXQgKGNhbGxlZCBhdXRvbWF0aWNhbGx5IGVhY2ggaXRlcmF0aW9uKVxuICAgIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICAgIC8vIGRyYXcgZGlyZWN0ZWQgZWRnZXMgd2l0aCBwcm9wZXIgcGFkZGluZyBmcm9tIG5vZGUgY2VudGVyc1xuICAgICAgICBwYXRoLmF0dHIoJ2QnLCBkID0+IHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBkLnRhcmdldC54IC0gZC5zb3VyY2UueCxcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBkLnRhcmdldC55IC0gZC5zb3VyY2UueSxcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSksXG4gICAgICAgICAgICAgICAgbm9ybVggPSBkZWx0YVggLyBkaXN0LFxuICAgICAgICAgICAgICAgIG5vcm1ZID0gZGVsdGFZIC8gZGlzdCxcbiAgICAgICAgICAgICAgICBzb3VyY2VQYWRkaW5nID0gZC5sZWZ0ID8gYWxsUiArIDUgOiBhbGxSLFxuICAgICAgICAgICAgICAgIHRhcmdldFBhZGRpbmcgPSBkLnJpZ2h0ID8gYWxsUiArIDUgOiBhbGxSLFxuICAgICAgICAgICAgICAgIHNvdXJjZVggPSBkLnNvdXJjZS54ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgc291cmNlWSA9IGQuc291cmNlLnkgKyAoc291cmNlUGFkZGluZyAqIG5vcm1ZKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gZC50YXJnZXQueCAtICh0YXJnZXRQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgICAgIHRhcmdldFkgPSBkLnRhcmdldC55IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWSk7XG4gICAgICAgICAgICByZXR1cm4gJ00nICsgc291cmNlWCArICcsJyArIHNvdXJjZVkgKyAnTCcgKyB0YXJnZXRYICsgJywnICsgdGFyZ2V0WTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNpcmNsZS5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+ICd0cmFuc2xhdGUoJyArIGQueCArICcsJyArIGQueSArICcpJyk7XG4gICAgfVxuXG4gICAgLy8gIGFkZCBsaXN0ZW5lcnMgdG8gbGVmdHBhbmVsLmxlZnQuICBldmVyeSB0aW1lIGEgdmFyaWFibGUgaXMgY2xpY2tlZCwgbm9kZXMgdXBkYXRlcyBhbmQgYmFja2dyb3VuZCBjb2xvciBjaGFuZ2VzLiAgbW91c2VvdmVyIHNob3dzIHN1bW1hcnkgc3RhdHMgb3IgbW9kZWwgZGVzY3JpcHRpb24uXG4gICAgZDMuc2VsZWN0KFwiI3RhYjFcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlclwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInZhcmlhYmxlc1wiKTtcbiAgICAgICAgICAgICQoXCJib2R5IGRpdi5wb3BvdmVyIGRpdi5wb3BvdmVyLWNvbnRlbnRcIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJmb3JtLWhvcml6b250YWxcIik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIHZhckNsaWNrKCkge1xuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgodGhpcy5pZCldLmdyYXlvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteVRleHQgPSBkMy5zZWxlY3QodGhpcykudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlDb2xvciA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlTQyA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobXlUZXh0KV0uc3Ryb2tlQ29sb3I7XG5cbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56dmFycyA9IFtdOyAvL2VtcHR5IHRoZSB6dmFycyBhcnJheVxuICAgICAgICAgICAgICAgICAgICBpZiAoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHsgLy8gd2UgYXJlIGFkZGluZyBhIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChmaW5kTm9kZShteVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1swXS5yZWZsZXhpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGZpbmROb2RlKG15VGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGRyb3BwaW5nIGEgdmFyaWFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShmaW5kTm9kZShteVRleHQpW1wiaW5kZXhcIl0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlTGlua3NGb3JOb2RlKGZpbmROb2RlKG15VGV4dCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXlTQyA9PSBkdkNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR2SW5kZXggPSB6cGFyYW1zLnpkdi5pbmRleE9mKG15VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR2SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5zcGxpY2UoZHZJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChteVNDID09IGNzQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NJbmRleCA9IHpwYXJhbXMuemNyb3NzLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemNyb3NzLnNwbGljZShjc0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG15U0MgPT0gdGltZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVJbmRleCA9IHpwYXJhbXMuenRpbWUuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnp0aW1lLnNwbGljZSh0aW1lSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobXlTQyA9PSBub21Db2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub21JbmRleCA9IHpwYXJhbXMuem5vbS5pbmRleE9mKG15VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVSZXNldChhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG15VGV4dCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKSAvLyBtb2RlbHMgdGFiXG4gICAgICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIHZhciBteUNvbG9yID0gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCB2YXJDb2xvcik7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQzLnJnYihteUNvbG9yKS50b1N0cmluZygpID09PSB2YXJDb2xvci50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnptb2RlbCA9IGQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bW9kZWwgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgLy8gdXBkYXRlIGdyYXBoIChjYWxsZWQgd2hlbiBuZWVkZWQpXG4gICAgZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICAgICAgLy8gbm9kZXMuaWQgaXMgcGVnZ2VkIHRvIGFsbE5vZGVzLCBpLmUuIHRoZSBvcmRlciBpbiB3aGljaCB2YXJpYWJsZXMgYXJlIHJlYWQgaW5cbiAgICAgICAgLy8gbm9kZXMuaW5kZXggaXMgZmxvYXRpbmcgYW5kIGRlcGVuZHMgb24gdXBkYXRlcyB0byBub2Rlcy4gIGEgdmFyaWFibGVzIGluZGV4IGNoYW5nZXMgd2hlbiBuZXcgdmFyaWFibGVzIGFyZSBhZGRlZC5cbiAgICAgICAgY2lyY2xlLmNhbGwoZm9yY2UuZHJhZyk7XG4gICAgICAgIGlmIChmb3JjZXRvZ2dsZVswXSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGZvcmNlLmdyYXZpdHkoMC4xKTtcbiAgICAgICAgICAgIGZvcmNlLmNoYXJnZSgtODAwKTtcbiAgICAgICAgICAgIGZvcmNlLmxpbmtTdHJlbmd0aCgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcmNlLmdyYXZpdHkoMCk7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoMCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2UucmVzdW1lKCk7XG5cbiAgICAgICAgLy8gcGF0aCAobGluaykgZ3JvdXBcbiAgICAgICAgcGF0aCA9IHBhdGguZGF0YShsaW5rcyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIGxpbmtzXG4gICAgICAgIC8vIFZKRDogZGFzaGVkIGxpbmtzIGJldHdlZW4gcGViYmxlcyBhcmUgXCJzZWxlY3RlZFwiLiB0aGlzIGlzIGRpc2FibGVkIGZvciBub3dcbiAgICAgICAgcGF0aC5jbGFzc2VkKCdzZWxlY3RlZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KSAvL3JldHVybiBkID09PSBzZWxlY3RlZF9saW5rOyB9KVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucmlnaHQgPyAndXJsKCNlbmQtYXJyb3cpJyA6ICcnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBsaW5rc1xuICAgICAgICBwYXRoLmVudGVyKCkuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluaycpXG4gICAgICAgICAgICAuY2xhc3NlZCgnc2VsZWN0ZWQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSkgLy9yZXR1cm4gZCA9PT0gc2VsZWN0ZWRfbGluazsgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxlZnQgPyAndXJsKCNzdGFydC1hcnJvdyknIDogJyc7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnJpZ2h0ID8gJ3VybCgjZW5kLWFycm93KScgOiAnJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGQpIHsgLy8gZG8gd2UgZXZlciBuZWVkIHRvIHNlbGVjdCBhIGxpbms/IG1ha2UgaXQgZGVsZXRlLi5cbiAgICAgICAgICAgICAgICB2YXIgb2JqMSA9IEpTT04uc3RyaW5naWZ5KGQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iajEgPT09IEpTT04uc3RyaW5naWZ5KGxpbmtzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua3Muc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG9sZCBsaW5rc1xuICAgICAgICBwYXRoLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAvLyBjaXJjbGUgKG5vZGUpIGdyb3VwXG4gICAgICAgIGNpcmNsZSA9IGNpcmNsZS5kYXRhKG5vZGVzLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZDtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgbm9kZXMgKHJlZmxleGl2ZSAmIHNlbGVjdGVkIHZpc3VhbCBzdGF0ZXMpXG4gICAgICAgIC8vZDMucmdiIGlzIHRoZSBmdW5jdGlvbiBhZGp1c3RpbmcgdGhlIGNvbG9yIGhlcmUuXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgncmVmbGV4aXZlJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnJlZmxleGl2ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLnJnYihkLm5vZGVDb2wpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZDMucmdiKGQuc3Ryb2tlQ29sb3IpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGQuc3Ryb2tlV2lkdGgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBub2Rlc1xuICAgICAgICB2YXIgZyA9IGNpcmNsZS5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXluYW1lID0gZC5uYW1lICsgXCJiaWdncm91cFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiAobXluYW1lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCBwbG90XG4gICAgICAgIGcuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAoZC5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICBkZW5zaXR5Tm9kZShkLCBvYmogPSB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZC5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgIGJhcnNOb2RlKGQsIG9iaiA9IHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImR2QXJjXCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMzKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkdkNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuMylcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdlRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC45KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2VGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgZHZDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGR2Q29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImR2VGV4dFwiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI2R2QXJjXCIuY29uY2F0KGQuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50ZXh0KFwiRGVwIFZhclwiKTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm5vbUFyY1wiLmNvbmNhdChkLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjNClcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgbm9tQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuMylcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNub21UZXh0XCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuOSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjbm9tVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIG5vbUNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQobm9tQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm5vbVRleHRcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDYpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDExLjUpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIiNub21BcmNcIi5jb25jYXQoZC5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRleHQoXCJOb21pbmFsXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKCdzdmc6Y2lyY2xlJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdub2RlJylcbiAgICAgICAgICAgIC5hdHRyKCdyJywgYWxsUilcbiAgICAgICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnaW5oZXJpdCcpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubm9kZUNvbDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBcIjAuNVwiKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLnJnYihkLnN0cm9rZUNvbG9yKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucmVmbGV4aXZlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3AgY2xpY2sgZnJvbSBidWJibGluZ1xuICAgICAgICAgICAgICAgIHN1bW1hcnlIb2xkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZCkgeyAvLyByaWdodCBjbGljayBvbiBub2RlXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCByaWdodCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgcmlnaHRDbGlja0xhc3QgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgbW91c2Vkb3duX25vZGUgPSBkO1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZWRvd25fbm9kZSA9PT0gc2VsZWN0ZWRfbm9kZSkgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZWxzZSBzZWxlY3RlZF9ub2RlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbGluayA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyByZXBvc2l0aW9uIGRyYWcgbGluZVxuICAgICAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAndXJsKCNlbmQtYXJyb3cpJylcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkpO1xuXG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3AgbW91c2V1cCBmcm9tIGJ1YmJsaW5nXG5cbiAgICAgICAgICAgICAgICBpZiAocmlnaHRDbGlja0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDbGlja0xhc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbW91c2Vkb3duX25vZGUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWRlZCBieSBGRlxuICAgICAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRyYWctdG8tc2VsZlxuICAgICAgICAgICAgICAgIG1vdXNldXBfbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNldXBfbm9kZSA9PT0gbW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVuZW5sYXJnZSB0YXJnZXQgbm9kZVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbGluayB0byBncmFwaCAodXBkYXRlIGlmIGV4aXN0cylcbiAgICAgICAgICAgICAgICAvLyBOQjogbGlua3MgYXJlIHN0cmljdGx5IHNvdXJjZSA8IHRhcmdldDsgYXJyb3dzIHNlcGFyYXRlbHkgc3BlY2lmaWVkIGJ5IGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSwgdGFyZ2V0LCBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlLmlkIDwgbW91c2V1cF9ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsaW5rO1xuICAgICAgICAgICAgICAgIGxpbmsgPSBsaW5rcy5maWx0ZXIoZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGwuc291cmNlID09PSBzb3VyY2UgJiYgbC50YXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5rID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxpbmtbZGlyZWN0aW9uXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0IG5ldyBsaW5rXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbGluayA9IGxpbms7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBudWxsKTtcblxuICAgICAgICAgICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBzaG93IG5vZGUgTmFtZXNcbiAgICAgICAgZy5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMTUpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaWQnKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkLm5hbWUpXG5cblxuICAgICAgICAvLyBzaG93IHN1bW1hcnkgc3RhdHMgb24gbW91c2VvdmVyXG4gICAgICAgIC8vIFNWRyBkb2Vzbid0IHN1cHBvcnQgdGV4dCB3cmFwcGluZywgdXNlIGh0bWwgaW5zdGVhZFxuICAgICAgICBnLnNlbGVjdEFsbChcImNpcmNsZS5ub2RlXCIpXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHRhYkxlZnQoXCJ0YWIzXCIpO1xuICAgICAgICAgICAgICAgIHZhclN1bW1hcnkoZCk7XG4gICAgICAgICAgICAgICAgYnlJZCgndHJhbnNmb3JtYXRpb25zJykuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5OmJsb2NrXCIpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3QgPSBieUlkKFwidHJhbnNTZWxcIik7XG4gICAgICAgICAgICAgICAgc2VsZWN0LnNlbGVjdGVkSW5kZXggPSBkLmlkO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhciA9IHZhbHVlS2V5W2QuaWRdO1xuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2R2QXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKCkuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAuMSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdlRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC41KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJudW1lcmljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbUFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjEpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjbm9tVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigxMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjY3NBcmNcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC4xKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI2NzVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjUpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGltZUFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgLjEpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGltZVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIC41KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMCk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnlIb2xkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJMZWZ0KGxlZnR0YWIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc0FyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNjc1RleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGltZUFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0aW1lVGV4dFwiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdkFyY1wiLmNvbmNhdChkLmlkKSkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheSgxMDApXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkdlRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjbm9tQXJjXCIuY29uY2F0KGQuaWQpKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI25vbVRleHRcIi5jb25jYXQoZC5pZCkpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoMTAwKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBvcHVsYXRpbmcgdHJhbnNmb3JtYXRpb24gZHJvcGRvd25cbiAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdC5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHRyYW5zZm9ybWF0aW9uIHZhcmlhYmxlIGxpc3QgaXMgc2lsZW50bHkgdXBkYXRlZCBhcyBwZWJibGVzIGFyZSBhZGRlZC9yZW1vdmVkXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLmRhdGEodCkgLy9zZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICQoJyN0cmFuc1NlbCBsaScpLmNsaWNrKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBpZiAnaW50ZXJhY3Rpb24nIGlzIHRoZSBzZWxlY3RlZCBmdW5jdGlvbiwgZG9uJ3Qgc2hvdyB0aGUgZnVuY3Rpb24gbGlzdCBhZ2FpblxuICAgICAgICAgICAgaWYgKHNlbEludGVyYWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSAkKCcjdElucHV0JykudmFsKCkuY29uY2F0KCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKG4pO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdHJhbnNQYXJzZShuID0gbik7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obiA9IHQuc2xpY2UoMCwgdC5sZW5ndGggLSAxKSwgdCA9IHRbdC5sZW5ndGggLSAxXSwgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwoJCh0aGlzKS50ZXh0KCkpO1xuICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZUluKDEwMCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgICAgICBjaXJjbGUuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICBmb3JjZS5zdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bihkKSB7XG4gICAgICAgIC8vIHByZXZlbnQgSS1iYXIgb24gZHJhZ1xuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgaWYgKGQzLmV2ZW50LmN0cmxLZXkgfHwgbW91c2Vkb3duX25vZGUgfHwgbW91c2Vkb3duX2xpbmspIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlKGQpIHtcbiAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBkcmFnIGxpbmVcbiAgICAgICAgZHJhZ19saW5lLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIGQzLm1vdXNlKHRoaXMpWzBdICsgJywnICsgZDMubW91c2UodGhpcylbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXAoZCkge1xuICAgICAgICBpZiAobW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gY2xlYXIgbW91c2UgZXZlbnQgdmFyc1xuICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgIH1cblxuICAgIC8vIGFwcCBzdGFydHMgaGVyZVxuICAgIHN2Zy5hdHRyKCdpZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwid2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vdXNlZG93bih0aGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBtb3VzZXVwKHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdCh3aW5kb3cpXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgLy9OT1RFOiBhbGwgY2xpY2tzIHdpbGwgYnViYmxlIGhlcmUgdW5sZXNzIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICB9KTtcblxuICAgIHJlc3RhcnQoKTsgLy8gdGhpcyBpcyB0aGUgY2FsbCB0aGUgcmVzdGFydCB0aGF0IGluaXRpYWxpemVzIHRoZSBmb3JjZS5sYXlvdXQoKVxuICAgIGZha2VDbGljaygpO1xufSAvLyBlbmQgbGF5b3V0XG5cbi8vIHJldHVybnMgaWRcbnZhciBmaW5kTm9kZUluZGV4ID0gZnVuY3Rpb24obm9kZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpIGluIGFsbE5vZGVzKSB7XG4gICAgICAgIGlmIChhbGxOb2Rlc1tpXVtcIm5hbWVcIl0gPT09IG5vZGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxsTm9kZXNbaV1bXCJpZFwiXTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBub2RlSW5kZXggPSBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgIGZvciAodmFyIGkgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzW2ldW1wibmFtZVwiXSA9PT0gbm9kZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgZmluZE5vZGUgPSBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgIGZvciAodmFyIGkgaW4gYWxsTm9kZXMpIHtcbiAgICAgICAgaWYgKGFsbE5vZGVzW2ldW1wibmFtZVwiXSA9PT0gbm9kZU5hbWUpIHJldHVybiBhbGxOb2Rlc1tpXVxuICAgIH07XG59XG5cbi8vIGZ1bmN0aW9uIGNhbGxlZCBieSBmb3JjZSBidXR0b25cbmZ1bmN0aW9uIGZvcmNlU3dpdGNoKCkge1xuICAgIGlmIChmb3JjZXRvZ2dsZVswXSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgZm9yY2V0b2dnbGUgPSBbXCJmYWxzZVwiXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JjZXRvZ2dsZSA9IFtcInRydWVcIl1cbiAgICB9XG5cbiAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT09IFwiZmFsc2VcIikge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNwbGljZUxpbmtzRm9yTm9kZShub2RlKSB7XG4gICAgdmFyIHRvU3BsaWNlID0gbGlua3MuZmlsdGVyKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgcmV0dXJuIChsLnNvdXJjZSA9PT0gbm9kZSB8fCBsLnRhcmdldCA9PT0gbm9kZSk7XG4gICAgfSk7XG4gICAgdG9TcGxpY2UubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgbGlua3Muc3BsaWNlKGxpbmtzLmluZGV4T2YobCksIDEpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB6UG9wKCkge1xuICAgIGlmIChkYXRhdXJsKSB7XG4gICAgICAgIHpwYXJhbXMuemRhdGF1cmwgPSBkYXRhdXJsO1xuICAgIH1cbiAgICB6cGFyYW1zLnptb2RlbGNvdW50ID0gbW9kZWxDb3VudDtcbiAgICB6cGFyYW1zLnplZGdlcyA9IFtdO1xuICAgIHpwYXJhbXMuenZhcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6dmFycyBhcnJheVxuICAgICAgICB6cGFyYW1zLnp2YXJzLnB1c2gobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIHZhciB0ZW1wID0gbm9kZXNbal0uaWQ7XG5cbiAgICAgICAgenBhcmFtcy56c2V0eFtqXSA9IGFsbE5vZGVzW3RlbXBdLnNldHh2YWxzO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmtzLmxlbmd0aDsgaisrKSB7IC8vcG9wdWxhdGUgemVkZ2VzIGFycmF5XG4gICAgICAgIHZhciBzcmN0Z3QgPSBbXTtcbiAgICAgICAgLy9jb3JyZWN0IHRoZSBzb3VyY2UgdGFyZ2V0IG9yZGVyaW5nIGZvciBaZWxpZ1xuICAgICAgICBpZiAobGlua3Nbal0ubGVmdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHNyY3RndCA9IFtsaW5rc1tqXS5zb3VyY2UubmFtZSwgbGlua3Nbal0udGFyZ2V0Lm5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3JjdGd0ID0gW2xpbmtzW2pdLnRhcmdldC5uYW1lLCBsaW5rc1tqXS5zb3VyY2UubmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgenBhcmFtcy56ZWRnZXMucHVzaChzcmN0Z3QpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXN0aW1hdGUoYnRuKSB7XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgenBhcmFtcy56c2Vzc2lvbmlkID09IFwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgelBvcCgpO1xuICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcbiAgICAvLyBwYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcblxuICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwiemVsaWdhcHBcIjsgLy9iYXNlLmNvbmNhdChqc29ub3V0KTtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY29uc29sZS5sb2coXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgIHpwYXJhbXMuYWxsVmFycyA9IHZhbHVlS2V5LnNsaWNlKDEwLCAyNSk7IC8vIGJlY2F1c2UgdGhlIFVSTCBpcyB0b28gbG9uZy4uLlxuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG4gICAgdmFyIHNlbGVjdG9ydXJsY2FsbCA9IHJhcHBVUkwgKyBcInNlbGVjdG9yYXBwXCI7XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZVN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICAgICAgYWxsUmVzdWx0cy5wdXNoKGpzb24pO1xuICAgICAgICBjb25zb2xlLmxvZyhhbGxSZXN1bHRzKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJqc29uIGluOiBcIiwganNvbik7XG5cbiAgICAgICAgdmFyIG15cGFyZW50ID0gYnlJZChcInJlc3VsdHNcIik7XG4gICAgICAgIGlmIChlc3RpbWF0ZWQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG15cGFyZW50LnJlbW92ZUNoaWxkKGJ5SWQoXCJyZXN1bHRzSG9sZGVyXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVzdGltYXRlZCA9IHRydWU7XG4gICAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgIC8vIHByb2dyYW1tYXRpYyBjbGljayBvbiBSZXN1bHRzIGJ1dHRvblxuICAgICAgICAkKFwiI2J0blJlc3VsdHNcIikudHJpZ2dlcihcImNsaWNrXCIpO1xuXG4gICAgICAgIG1vZGVsQ291bnQgPSBtb2RlbENvdW50ICsgMTtcbiAgICAgICAgdmFyIG1vZGVsID0gXCJNb2RlbFwiLmNvbmNhdChtb2RlbENvdW50KTtcblxuICAgICAgICBmdW5jdGlvbiBtb2RDb2woKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEodmFyQ29sb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RDb2woKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAuaW5zZXJ0KFwicFwiLCBcIjpmaXJzdC1jaGlsZFwiKSAvLyB0b3Agc3RhY2sgZm9yIHJlc3VsdHNcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgbW9kZWwpXG4gICAgICAgICAgICAudGV4dChtb2RlbClcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShzZWxWYXJDb2xvcikpXG4gICAgICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yLnJlcGxhY2UoL1xccyovZywgXCJcIik7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpLnJlcGxhY2UoL1xccyovZywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGEuc3Vic3RyKDAsIDE3KSA9PT0gYi5zdWJzdHIoMCwgMTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZXNjYXBlcyB0aGUgZnVuY3Rpb24gZWFybHkgaWYgdGhlIGRpc3BsYXllZCBtb2RlbCBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZENvbCgpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKTtcbiAgICAgICAgICAgICAgICB2aXoodGhpcy5pZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgckNhbGwgPSBbXTtcbiAgICAgICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG4gICAgICAgIGxvZ0FycmF5LnB1c2goXCJlc3RpbWF0ZTogXCIuY29uY2F0KHJDYWxsWzBdKSk7XG4gICAgICAgIHNob3dMb2coKTtcblxuICAgICAgICB2aXoobW9kZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzdGltYXRlRmFpbChidG4pIHtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7IC8vIHN0b3Agc3Bpbm5lclxuICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yU3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RpY2tlclwiKVxuICAgICAgICAgICAgLnRleHQoXCJTdWdnZXN0ZWQgdmFyaWFibGVzIGFuZCBwZXJjZW50IGltcHJvdmVtZW50IG9uIFJNU0U6IFwiICsganNvbi52YXJzKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWxlY3RvclN1Y2Nlc3M6IFwiLCBqc29uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RvckZhaWwoYnRuKSB7XG4gICAgICAgIGFsZXJ0KFwiU2VsZWN0b3IgRmFpbFwiKTtcbiAgICB9XG5cbiAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgYnRuLCBlc3RpbWF0ZVN1Y2Nlc3MsIGVzdGltYXRlRmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG5mdW5jdGlvbiBkYXRhRG93bmxvYWQoKSB7XG4gICAgelBvcCgpO1xuICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcblxuICAgIC8vcGFja2FnZSB0aGUgb3V0cHV0IGFzIEpTT05cbiAgICAvLyBhZGQgY2FsbCBoaXN0b3J5IGFuZCBwYWNrYWdlIHRoZSB6cGFyYW1zIG9iamVjdCBhcyBKU09OXG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICB2YXIgYnRuID0gXCJub2J1dHRvblwiO1xuXG4gICAgdmFyIHVybGNhbGwgPSByYXBwVVJMICsgXCJkYXRhYXBwXCI7IC8vYmFzZS5jb25jYXQoanNvbm91dCk7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJzb2xhSlNPTj1cIiArIGpzb25vdXQ7XG4gICAgY29uc29sZS5sb2coXCJ1cmxjYWxsIG91dDogXCIsIHVybGNhbGwpO1xuICAgIGNvbnNvbGUubG9nKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG5cbiAgICBmdW5jdGlvbiBkb3dubG9hZFN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZGF0YURvd25sb2FkIGpzb24gaW46IFwiLCBqc29uKTtcbiAgICAgICAgenBhcmFtcy56c2Vzc2lvbmlkID0ganNvbi5zZXNzaW9uaWRbMF07XG5cbiAgICAgICAgLy8gc2V0IHRoZSBsaW5rIFVSTFxuICAgICAgICBpZiAocHJvZHVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGxvZ1VSTCA9IHJhcHBVUkwgKyBcImxvZ19kaXIvbG9nX1wiICsgenBhcmFtcy56c2Vzc2lvbmlkICsgXCIudHh0XCI7XG4gICAgICAgICAgICBieUlkKFwibG9nSURcIikuaHJlZiA9IGxvZ1VSTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsb2dVUkwgPSBcInJvb2svbG9nX1wiICsgenBhcmFtcy56c2Vzc2lvbmlkICsgXCIudHh0XCI7XG4gICAgICAgICAgICBieUlkKFwibG9nSURcIikuaHJlZiA9IGxvZ1VSTDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG93bmxvYWRGYWlsKGJ0bikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGEgaGF2ZSBub3QgYmVlbiBkb3dubG9hZGVkXCIpO1xuICAgIH1cblxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIGRvd25sb2FkU3VjY2VzcywgZG93bmxvYWRGYWlsLCBzb2xhanNvbm91dCk7XG59XG5cbmZ1bmN0aW9uIHZpeihtKSB7XG4gICAgdmFyIG15bSA9ICttLnN1YnN0cig1LCA1KSAtIDE7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVLaWRzKHBhcmVudCkge1xuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbXlwYXJlbnQgPSBieUlkKFwicmVzdWx0c1ZpZXdcIik7XG4gICAgcmVtb3ZlS2lkcyhteXBhcmVudCk7XG5cbiAgICB2YXIganNvbiA9IGFsbFJlc3VsdHNbbXltXTtcblxuICAgIC8vIHBpcGUgaW4gZmlndXJlcyB0byByaWdodCBwYW5lbFxuICAgIHZhciBmaWxlbGlzdCA9IG5ldyBBcnJheTtcbiAgICBmb3IgKHZhciBpIGluIGpzb24uaW1hZ2VzKSB7XG4gICAgICAgIHZhciB6ZmlnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwganNvbi5pbWFnZXNbaV0pO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAyMDApO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMjAwKTtcbiAgICAgICAgYnlJZChcInJlc3VsdHNWaWV3XCIpLmFwcGVuZENoaWxkKHpmaWcpO1xuICAgIH1cblxuICAgIC8vIHdyaXRlIHRoZSByZXN1bHRzIHRhYmxlXG4gICAgdmFyIHJlc3VsdHNBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBqc29uLnN1bUluZm8pIHtcbiAgICAgICAgaWYgKGtleSA9PSBcImNvbG5hbWVzXCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0ganNvbi5zdW1JbmZvW2tleV07XG4gICAgICAgIHJlc3VsdHNBcnJheS5wdXNoKG9iaik7XG4gICAgICAgIC8qIFNPIHNheXMgdGhpcyBpcyBpbXBvcnRhbnQgY2hlY2ssIGJ1dCBJIGRvbid0IHNlZSBob3cgaXQgaGVscHMgaGVyZS4uLlxuICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgIC8vIGltcG9ydGFudCBjaGVjayB0aGF0IHRoaXMgaXMgb2JqZWN0cyBvd24gcHJvcGVydHlcbiAgICAgICAgIC8vIG5vdCBmcm9tIHByb3RvdHlwZSBwcm9wIGluaGVyaXRlZFxuICAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKXtcbiAgICAgICAgIGFsZXJ0KHByb3AgKyBcIiA9IFwiICsgb2JqW3Byb3BdKTtcbiAgICAgICAgIH1cbiAgICAgICAgIH0gICovXG4gICAgfVxuXG4gICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ0YWJsZVwiKTtcblxuICAgIHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZChcInRoZWFkXCIpO1xuICAgIHRoZWFkLmFwcGVuZChcInRyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0aFwiKVxuICAgICAgICAuZGF0YShqc29uLnN1bUluZm8uY29sbmFtZXMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG5cbiAgICB2YXIgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcbiAgICB0Ym9keS5zZWxlY3RBbGwoXCJ0clwiKVxuICAgICAgICAuZGF0YShyZXN1bHRzQXJyYXkpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0ZFwiKVxuICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGRcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIG15TnVtID0gTnVtYmVyKGQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG15TnVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG15TnVtLnRvUHJlY2lzaW9uKDMpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiYWxpY2VibHVlXCIpXG4gICAgICAgIH0pIC8vIGZvciBubyBkaXNjZXJuYWJsZSByZWFzb25cbiAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI0Y5RjlGOVwiKVxuICAgICAgICB9KTsgLy8oYnV0IG1heWJlIHdlJ2xsIHRoaW5rIG9mIG9uZSlcblxuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuaHRtbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxiPkZvcm11bGE6IDwvYj5cIi5jb25jYXQoanNvbi5jYWxsWzBdKTtcbiAgICAgICAgfSk7XG59XG5cbi8vIHBhcnNlcyB0aGUgdHJhbnNmb3JtYXRpb24gaW5wdXQuIHZhcmlhYmxlIG5hbWVzIGFyZSBvZnRlbiBuZXN0ZWQgaW5zaWRlIG9uZSBhbm90aGVyLCBlLmcuLCBldGh3YXIsIHdhciwgd2FycywgYW5kIHNvIHRoaXMgaXMgaGFuZGxlZFxuZnVuY3Rpb24gdHJhbnNQYXJzZShuKSB7XG4gICAgdmFyIG91dDIgPSBbXTtcbiAgICB2YXIgdDIgPSBuO1xuICAgIHZhciBrMiA9IDA7XG4gICAgdmFyIHN1Yk1lMiA9IFwiX3RyYW5zdmFyXCIuY29uY2F0KGsyKTtcbiAgICB2YXIgaW5kZXhlZCA9IFtdO1xuXG4gICAgLy8gb3V0MiBpcyBhbGwgbWF0Y2hlZCB2YXJpYWJsZXMsIGluZGV4ZWQgaXMgYW4gYXJyYXksIGVhY2ggZWxlbWVudCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hlZCB2YXJpYWJsZXMgc3RhcnRpbmcgaW5kZXggYW5kIGZpbmlzaGluZyBpbmRleC4gIGUuZy4sIG49XCJ3YXJzKzJcIiwgb3V0Mj1bd2FyLCB3YXJzXSwgaW5kZXhlZD1bezAsMn0sezAsM31dXG4gICAgZm9yICh2YXIgaSBpbiB2YWx1ZUtleSkge1xuICAgICAgICB2YXIgbTIgPSBuLm1hdGNoKHZhbHVlS2V5W2ldKTtcbiAgICAgICAgaWYgKG0yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvdXQyLnB1c2gobTJbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh2YWx1ZUtleVtpXSwgXCJnXCIpXG4gICAgICAgIHZhciBzID0gbi5zZWFyY2gocmUpO1xuICAgICAgICBpZiAocyAhPSAtMSkge1xuICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBmcm9tOiBzLFxuICAgICAgICAgICAgICAgIHRvOiBzICsgdmFsdWVLZXlbaV0ubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5lc3RlZCBsb29wIG5vdCBnb29kLCBidXQgaW5kZXhlZCBpcyBub3QgbGlrZWx5IHRvIGJlIHZlcnkgbGFyZ2UuXG4gICAgLy8gaWYgYSB2YXJpYWJsZSBpcyBuZXN0ZWQsIGl0IGlzIHJlbW92ZWQgZnJvbSBvdXQyXG4gICAgLy8gbm90aWNlLCBsb29wIGlzIGJhY2t3YXJkcyBzbyB0aGF0IGluZGV4IGNoYW5nZXMgZG9uJ3QgYWZmZWN0IHRoZSBzcGxpY2VcbiAgICBjb25zb2xlLmxvZyhcImluZGV4ZWQgXCIsIGluZGV4ZWQpO1xuICAgIGZvciAodmFyIGkgPSBpbmRleGVkLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpbmRleGVkLmxlbmd0aCAtIDE7IGogPiAtMTsgai0tKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpbmRleGVkW2ldLmZyb20gPj0gaW5kZXhlZFtqXS5mcm9tKSAmIChpbmRleGVkW2ldLnRvIDw9IGluZGV4ZWRbal0udG8pKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaSwgXCIgaXMgbmVzdGVkIGluIFwiLCBqKTtcbiAgICAgICAgICAgICAgICBvdXQyLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gb3V0Mikge1xuICAgICAgICB0MiA9IHQyLnJlcGxhY2Uob3V0MltpXSwgc3ViTWUyKTsgLy9zb21ldGhpbmcgdGhhdCdsbCBuZXZlciBiZSBhIHZhcmlhYmxlIG5hbWVcbiAgICAgICAgazIgPSBrMiArIDE7XG4gICAgICAgIHN1Yk1lMiA9IFwiX3RyYW5zdmFyXCIuY29uY2F0KGsyKTtcbiAgICB9XG5cbiAgICBpZiAob3V0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgIG91dDIucHVzaCh0Mik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibmV3IG91dCBcIiwgb3V0Mik7XG4gICAgICAgIHJldHVybiAob3V0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoXCJObyB2YXJpYWJsZSBuYW1lIGZvdW5kLiBQZXJoYXBzIGNoZWNrIHlvdXIgc3BlbGxpbmc/XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShuLCB0LCB0eXBlVHJhbnNmb3JtKSB7XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgenBhcmFtcy56c2Vzc2lvbmlkID09IFwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlVHJhbnNmb3JtKSB7XG4gICAgICAgIHQgPSB0LnJlcGxhY2UoXCIrXCIsIFwiX3BsdXNfXCIpOyAvLyBjYW4ndCBzZW5kIHRoZSBwbHVzIG9wZXJhdG9yXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2cobik7XG4gICAgY29uc29sZS5sb2codCk7XG5cbiAgICB2YXIgYnRuID0gYnlJZCgnYnRuRXN0aW1hdGUnKTtcblxuICAgIHZhciBteW4gPSBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG5bMF0pXTtcbiAgICBpZiAodHlwZW9mIG15biA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbXluID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChuKV07XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0ge1xuICAgICAgICB2YXJuYW1lc1R5cGVzOiBuLFxuICAgICAgICBpbnRlcnZhbDogbXluLmludGVydmFsLFxuICAgICAgICBudW1jaGFyOiBteW4ubnVtY2hhcixcbiAgICAgICAgbmF0dXJlOiBteW4ubmF0dXJlLFxuICAgICAgICBiaW5hcnk6IG15bi5iaW5hcnlcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2cobXluKTtcbiAgICAvLyBpZiB0eXBlVHJhbnNmb3JtIGJ1dCB3ZSBhbHJlYWR5IGhhdmUgdGhlIG1ldGFkYXRhXG4gICAgaWYgKHR5cGVUcmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKG15bi5uYXR1cmUgPT0gXCJub21pbmFsXCIgJiB0eXBlb2YgbXluLnBsb3R2YWx1ZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG15bi5wbG90dHlwZSA9IFwiYmFyXCI7XG4gICAgICAgICAgICBiYXJzTm9kZShteW4pO1xuICAgICAgICAgICAgcG9wdWxhdGVQb3BvdmVyKCk7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobXluLm5hdHVyZSAhPSBcIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG15bi5wbG90dHlwZSA9IFwiY29udGludW91c1wiO1xuICAgICAgICAgICAgZGVuc2l0eU5vZGUobXluKTtcbiAgICAgICAgICAgIHBvcHVsYXRlUG9wb3ZlcigpO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9wYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIHZhciB0cmFuc2Zvcm1zdHVmZiA9IHtcbiAgICAgICAgemRhdGF1cmw6IGRhdGF1cmwsXG4gICAgICAgIHp2YXJzOiBuLFxuICAgICAgICB6c2Vzc2lvbmlkOiB6cGFyYW1zLnpzZXNzaW9uaWQsXG4gICAgICAgIHRyYW5zZm9ybTogdCxcbiAgICAgICAgY2FsbEhpc3Rvcnk6IGNhbGxIaXN0b3J5LFxuICAgICAgICB0eXBlVHJhbnNmb3JtOiB0eXBlVHJhbnNmb3JtLFxuICAgICAgICB0eXBlU3R1ZmY6IG91dHR5cGVzXG4gICAgfTtcbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybXN0dWZmKTtcbiAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcInRyYW5zZm9ybWFwcFwiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICBjb25zb2xlLmxvZyhcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtU3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwianNvbiBpbjogXCIsIGpzb24pO1xuICAgICAgICBpZiAoanNvbi50eXBlVHJhbnNmb3JtWzBdKSB7XG4gICAgICAgICAgICBkMy5qc29uKGpzb24udXJsLCAoZXJyb3IsIGpzb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIGFsbE5vZGVzW215SW5kZXhdLCBqc29uZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbE5vZGVzW215SW5kZXhdLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikgZGVuc2l0eU5vZGUoYWxsTm9kZXNbbXlJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGxOb2Rlc1tteUluZGV4XS5wbG90dHlwZSA9PT0gXCJiYXJcIikgYmFyc05vZGUoYWxsTm9kZXNbbXlJbmRleF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYWxsTm9kZXNbbXlJbmRleF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsSGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgICAgICBmdW5jOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIHp2YXJzOiBuLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzdWJzZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJDYWxsID0gW107XG4gICAgICAgICAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcbiAgICAgICAgICAgIHZhciBuZXdWYXIgPSByQ2FsbFswXVswXTtcbiAgICAgICAgICAgIHRyYW5zLnB1c2gobmV3VmFyKTtcblxuICAgICAgICAgICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGpzb247XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15SW5kZXggPSBmaW5kTm9kZUluZGV4KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXlJbmRleCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJJbnZhbGlkIHRyYW5zZm9ybWF0aW9uOiB0aGlzIHZhcmlhYmxlIG5hbWUgYWxyZWFkeSBleGlzdHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0cmFuc2Zvcm1lZCB2YXJpYWJsZSB0byB0aGUgY3VycmVudCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFsbE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iajEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmxleGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJsYWJsXCI6IFwidHJhbnNmb3JtbGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFs1LCAxNSwgMjAsIDAsIDUsIDE1LCAyMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogWy42LCAuMiwgLjksIC44LCAuMSwgLjMsIC40XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm9kZUNvbFwiOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJhc2VDb2xcIjogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJva2VDb2xvclwiOiBzZWxWYXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3Ryb2tlV2lkdGhcIjogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN1YnNldHBsb3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN1YnNldHJhbmdlXCI6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2V0eHBsb3RcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNldHh2YWxzXCI6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZ3JheW91dFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVmYXVsdEludGVydmFsXCI6IGpzb25kYXRhW2tleV1bXCJpbnRlcnZhbFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVmYXVsdE51bWNoYXJcIjoganNvbmRhdGFba2V5XVtcIm51bWNoYXJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHROYXR1cmVcIjoganNvbmRhdGFba2V5XVtcIm5hdHVyZVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVmYXVsdEJpbmFyeVwiOiBqc29uZGF0YVtrZXldW1wiYmluYXJ5XCJdXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBvYmoxLCBqc29uZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXMucHVzaChvYmoxKTtcblxuICAgICAgICAgICAgICAgICAgICBzY2FmZm9sZGluZ1B1c2gockNhbGxbMF0pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUtleS5wdXNoKG5ld1Zhcik7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNpdHlOb2RlKGFsbE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyc05vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvL2ZvclxuXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGxvZ1xuICAgICAgICAgICAgbG9nQXJyYXkucHVzaChcInRyYW5zZm9ybTogXCIuY29uY2F0KHJDYWxsWzBdKSk7XG4gICAgICAgICAgICBzaG93TG9nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1GYWlsKGJ0bikge1xuICAgICAgICBhbGVydChcInRyYW5zZm9ybSBmYWlsXCIpO1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICB9XG5cbiAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgYnRuLCB0cmFuc2Zvcm1TdWNjZXNzLCB0cmFuc2Zvcm1GYWlsLCBzb2xhanNvbm91dCk7XG59XG5cbmZ1bmN0aW9uIHNjYWZmb2xkaW5nUHVzaCh2KSB7IC8vIGFkZGluZyBhIHZhcmlhYmxlIHRvIHRoZSB2YXJpYWJsZSBsaXN0IGFmdGVyIGEgdHJhbnNmb3JtYXRpb25cbiAgICBkMy5zZWxlY3QoXCIjdGFiMVwiKVxuICAgICAgICAuZGF0YSh2KVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZbMF0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRleHQodlswXSlcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSlcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRhaW5lclwiLCBcImJvZHlcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRvZ2dsZVwiLCBcInBvcG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRyaWdnZXJcIiwgXCJob3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtcGxhY2VtZW50XCIsIFwicmlnaHRcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJTdW1tYXJ5IFN0YXRpc3RpY3NcIilcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gdmFyQ2xpY2soKSB7IC8vIHdlJ3ZlIGFkZGVkIGEgbmV3IHZhcmlhYmxlLCBzbyB3ZSBuZWVkIHRvIGFkZCB0aGUgbGlzdGVuZXJcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15VGV4dCA9IGQzLnNlbGVjdCh0aGlzKS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteUNvbG9yID0gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteVNDID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleChteVRleHQpXS5zdHJva2VDb2xvcjtcblxuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnp2YXJzID0gW107IC8vZW1wdHkgdGhlIHp2YXJzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5yZ2IobXlDb2xvcikudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSkgeyAvLyB3ZSBhcmUgYWRkaW5nIGEgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGZpbmROb2RlKG15VGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzWzBdLnJlZmxleGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goZmluZE5vZGUobXlUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gZHJvcHBpbmcgYSB2YXJpYWJsZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoZmluZE5vZGUobXlUZXh0KVtcImluZGV4XCJdLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZUxpbmtzRm9yTm9kZShmaW5kTm9kZShteVRleHQpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG15U0MgPT0gZHZDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdkluZGV4ID0genBhcmFtcy56ZHYuaW5kZXhPZihteVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdkluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56ZHYuc3BsaWNlKGR2SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobXlTQyA9PSBjc0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzSW5kZXggPSB6cGFyYW1zLnpjcm9zcy5pbmRleE9mKG15VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpjcm9zcy5zcGxpY2UoY3NJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChteVNDID09IHRpbWVDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lSW5kZXggPSB6cGFyYW1zLnp0aW1lLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56dGltZS5zcGxpY2UoZHZJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChteVNDID09IG5vbUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vbUluZGV4ID0genBhcmFtcy56bm9tLmluZGV4T2YobXlUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9tSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpub20uc3BsaWNlKGR2SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVJlc2V0KGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobXlUZXh0KV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgIH0pO1xuICAgIHBvcHVsYXRlUG9wb3ZlcigpOyAvLyBwaXBlcyBpbiB0aGUgc3VtbWFyeSBzdGF0c1xuXG4gICAgLy8gZHJvcCBkb3duIG1lbnUgZm9yIHRyYW5mb3JtYXRpb24gdG9vbGJhclxuICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAuZGF0YSh2KVxuICAgICAgICAuYXBwZW5kKFwib3B0aW9uXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbn1cblxuLy8gYmVsb3cgZnJvbSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jb3JzLyBmb3IgY3Jvc3Mtb3JpZ2luIHJlc291cmNlIHNoYXJpbmdcbi8vIENyZWF0ZSB0aGUgWEhSIG9iamVjdC5cbmZ1bmN0aW9uIGNyZWF0ZUNPUlNSZXF1ZXN0KG1ldGhvZCwgdXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBpZiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIpIHtcbiAgICAgICAgLy8gWEhSIGZvciBDaHJvbWUvRmlyZWZveC9PcGVyYS9TYWZhcmkuXG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFhEb21haW5SZXF1ZXN0IGZvciBJRS5cbiAgICAgICAgeGhyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDT1JTIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgIHhociA9IG51bGw7XG4gICAgfVxuICAgIC8vIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgcmV0dXJuIHhocjtcbn1cblxuLy8gTWFrZSB0aGUgYWN0dWFsIENPUlMgcmVxdWVzdC5cbmZ1bmN0aW9uIG1ha2VDb3JzUmVxdWVzdCh1cmwsIGJ0biwgY2FsbGJhY2ssIHdhcm5pbmdjYWxsYmFjaywganNvbnN0cmluZykge1xuICAgIHZhciB4aHIgPSBjcmVhdGVDT1JTUmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgYWxlcnQoJ0NPUlMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlc3BvbnNlIGhhbmRsZXJzIGZvciBhc3luY2hyb25vdXMgbG9hZFxuICAgIC8vIG9ubG9hZCBvciBvbnJlYWR5c3RhdGVjaGFuZ2U/XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgY29uc29sZS5sb2coXCJ0ZXh0IFwiLCB0ZXh0KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKHRleHQpOyAvLyBzaG91bGQgd3JhcCBpbiB0cnkgLyBjYXRjaFxuICAgICAgICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoanNvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgYWxlcnQoJ0Vycm9yOiBDb3VsZCBub3QgcGFyc2UgaW5jb21pbmcgSlNPTi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lc1swXSA9PSBcIndhcm5pbmdcIikge1xuICAgICAgICAgICAgd2FybmluZ2NhbGxiYWNrKGJ0bik7XG4gICAgICAgICAgICBhbGVydChcIldhcm5pbmc6IFwiICsganNvbi53YXJuaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGJ0biwganNvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vdGU6IHhoci5yZWFkeXN0YXRlIHNob3VsZCBiZSA0LCBhbmQgc3RhdHVzIHNob3VsZCBiZSAyMDAuICBhIHN0YXR1cyBvZiAwIG9jY3VycyB3aGVuIHRoZSB1cmwgYmVjb21lcyB0b28gbGFyZ2VcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMCkge1xuICAgICAgICAgICAgYWxlcnQoJ1RoZXJlIHdhcyBhbiBlcnJvciBtYWtpbmcgdGhlIHJlcXVlc3QuIHhtbGh0dHByZXF1ZXN0IHN0YXR1cyBpcyAwLicpO1xuICAgICAgICB9IGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlICE9IDQpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdUaGVyZSB3YXMgYW4gZXJyb3IgbWFraW5nIHRoZSByZXF1ZXN0LiB4bWxodHRwcmVxdWVzdCByZWFkeXN0YXRlIGlzIG5vdCA0LicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQoJ1dvb3BzLCB0aGVyZSB3YXMgYW4gZXJyb3IgbWFraW5nIHRoZSByZXF1ZXN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKHhocik7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7XG4gICAgfTtcbiAgICB4aHIuc2VuZChqc29uc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gbGVnZW5kKGMpIHtcbiAgICBpZiAoenBhcmFtcy56dGltZS5sZW5ndGggIT0gMCB8IHpwYXJhbXMuemNyb3NzLmxlbmd0aCAhPSAwIHwgenBhcmFtcy56ZHYubGVuZ3RoICE9IDAgfCB6cGFyYW1zLnpub20ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgYnlJZChcImxlZ2VuZFwiKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnlJZChcImxlZ2VuZFwiKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6bm9uZVwiKTtcbiAgICB9XG4gICAgaWYgKHpwYXJhbXMuenRpbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgYnlJZChcInRpbWVCdXR0b25cIikuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJjbGVhcmZpeCBoaWRlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5SWQoXCJ0aW1lQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggc2hvd1wiKTtcbiAgICB9XG4gICAgaWYgKHpwYXJhbXMuemNyb3NzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGJ5SWQoXCJjc0J1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IGhpZGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnlJZChcImNzQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggc2hvd1wiKTtcbiAgICB9XG4gICAgaWYgKHpwYXJhbXMuemR2Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGJ5SWQoXCJkdkJ1dHRvblwiKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImNsZWFyZml4IGhpZGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnlJZChcImR2QnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggc2hvd1wiKTtcbiAgICB9XG4gICAgaWYgKHpwYXJhbXMuem5vbS5sZW5ndGggPT0gMCkge1xuICAgICAgICBieUlkKFwibm9tQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggaGlkZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBieUlkKFwibm9tQnV0dG9uXCIpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiY2xlYXJmaXggc2hvd1wiKTtcbiAgICB9XG4gICAgYm9yZGVyU3RhdGUoKTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgbG9jYXRpb24ucmVsb2FkKCk7XG59XG5cbi8vIHByb2dyYW1tYXRpY2FsbHkgZGVzZWxlY3RpbmcgZXZlcnkgc2VsZWN0ZWQgdmFyaWFibGUuLi5cbmZ1bmN0aW9uIGVyYXNlKCkge1xuICAgIGxlZnRwYW5lbE1lZGl1bSgpO1xuICAgIHJpZ2h0cGFuZWxNZWRpdW0oKTtcbiAgICBieUlkKFwibGVnZW5kXCIpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpub25lXCIpO1xuICAgIHRhYkxlZnQoJ3RhYjEnKTtcbiAgICBqUXVlcnkuZm4uZDNDbGljayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbigpLmVhY2goKGksIGUpID0+IHtcbiAgICAgICAgICAgIHZhciBteWNvbCA9IGQzLnJnYih0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICBpZiAobXljb2wudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgJChcIiN0YWIxXCIpLmQzQ2xpY2soKTtcbn1cblxuZnVuY3Rpb24gZGVzZWxlY3QoZCkge1xuICAgIGNvbnNvbGUubG9nKGQpO1xufVxuXG4vLyBodHRwOi8vd3d3LnR1dG9yaWFsczJsZWFybi5jb20vdHV0b3JpYWxzL3NjcmlwdHMvamF2YXNjcmlwdC94bWwtcGFyc2VyLWphdmFzY3JpcHQuaHRtbFxuZnVuY3Rpb24gbG9hZFhNTERvYyhYTUxuYW1lKSB7XG4gICAgdmFyIHhtbERvYztcbiAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHhtbERvYyA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeG1sRG9jLm9wZW4oXCJHRVRcIiwgWE1MbmFtZSwgZmFsc2UpO1xuICAgICAgICB4bWxEb2Muc2VuZChcIlwiKTtcbiAgICAgICAgcmV0dXJuIHhtbERvYy5yZXNwb25zZVhNTDtcbiAgICB9XG4gICAgLy8gSUUgNSBhbmQgSUUgNlxuICAgIGVsc2UgaWYgKEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpKSB7XG4gICAgICAgIHhtbERvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKTtcbiAgICAgICAgeG1sRG9jLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIHhtbERvYy5sb2FkKFhNTG5hbWUpO1xuICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgIH1cbiAgICBhbGVydChcIkVycm9yIGxvYWRpbmcgZG9jdW1lbnQhXCIpO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFiTGVmdCh0YWIpIHtcbiAgICBpZiAodGFiICE9IFwidGFiM1wiKSB7XG4gICAgICAgIGxlZnR0YWIgPSB0YWI7XG4gICAgfVxuICAgIHZhciB0YWJpID0gdGFiLnN1YnN0cmluZygzKTtcbiAgICBieUlkKCd0YWIxJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBieUlkKCd0YWIyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBieUlkKCd0YWIzJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZiAodGFiID09PSBcInRhYjFcIikge1xuICAgICAgICBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xuICAgICAgICBieUlkKCdidG5TdWJzZXQnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgYnlJZCgnYnRuVmFyaWFibGVzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgICAgICBieUlkKFwiYnRuU2VsZWN0XCIpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGQzLnNlbGVjdChcIiNsZWZ0cGFuZWxcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xuICAgIH0gZWxzZSBpZiAodGFiID09PSBcInRhYjJcIikge1xuICAgICAgICBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xuICAgICAgICBieUlkKCdidG5WYXJpYWJsZXMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgYnlJZCgnYnRuU3Vic2V0Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgICAgICBkMy5zZWxlY3QoXCIjbGVmdHBhbmVsXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSA9PT0gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4IGV4cGFuZHBhbmVsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnlJZChcImJ0blNlbGVjdFwiKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnlJZChcImJ0blNlbGVjdFwiKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeCBleHBhbmRwYW5lbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5SWQoJ2J0blN1YnNldCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBieUlkKCdidG5WYXJpYWJsZXMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI2xlZnRwYW5lbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG4gICAgfVxuICAgIGJ5SWQodGFiKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbn1cblxuZnVuY3Rpb24gdGFiUmlnaHQodGFiaWQpIHtcbiAgICBieUlkKCdtb2RlbHMnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGJ5SWQoJ3NldHgnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGJ5SWQoJ3Jlc3VsdHMnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmICh0YWJpZCA9PSBcImJ0bk1vZGVsc1wiKSB7XG4gICAgICAgIGJ5SWQoJ2J0blNldHgnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgYnlJZCgnYnRuUmVzdWx0cycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBieUlkKCdidG5Nb2RlbHMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgICAgIGJ5SWQoJ21vZGVscycpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG4gICAgfSBlbHNlIGlmICh0YWJpZCA9PSBcImJ0blNldHhcIikge1xuICAgICAgICBieUlkKCdidG5Nb2RlbHMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgYnlJZCgnYnRuUmVzdWx0cycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBieUlkKCdidG5TZXR4Jykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgICAgICBieUlkKCdzZXR4Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGlmIChyaWdodHRhYiA9PSBcImJ0blNldHhcIiB8IGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpLmF0dHIoXCJjbGFzc1wiKSA9PSBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIikge1xuICAgICAgICAgICAgdG9nZ2xlUigpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YWJpZCA9PSBcImJ0blJlc3VsdHNcIikge1xuICAgICAgICBieUlkKCdidG5Nb2RlbHMnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgYnlJZCgnYnRuU2V0eCcpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBieUlkKCdidG5SZXN1bHRzJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgICAgICBieUlkKCdyZXN1bHRzJykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGlmIChlc3RpbWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0dGFiID09IFwiYnRuUmVzdWx0c1wiIHwgZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIikuYXR0cihcImNsYXNzXCIpID09IFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKSB7XG4gICAgICAgICAgICB0b2dnbGVSKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByaWdodHRhYiA9IHRhYmlkO1xuXG4gICAgZnVuY3Rpb24gdG9nZ2xlUigpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgPT09IFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeCBleHBhbmRwYW5lbFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeCBleHBhbmRwYW5lbFwiO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YXJTdW1tYXJ5KGQpIHtcbiAgICB2YXIgcmludCA9IGQzLmZvcm1hdChcInJcIik7XG4gICAgdmFyIHN1bW1hcnlkYXRhID0gW10sXG4gICAgICAgIHRtcERhdGFzZXQgPSBbXSxcbiAgICAgICAgdDEgPSBbXCJNZWFuOlwiLCBcIk1lZGlhbjpcIiwgXCJNb3N0IEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTWVkaWFuIEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTGVhc3QgRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgXCJTdGFuZC5EZXY6XCIsIFwiTWluaW11bTpcIiwgXCJNYXhpbXVtOlwiLCBcIkludmFsaWQ6XCIsIFwiVmFsaWQ6XCIsIFwiVW5pcXVlczpcIiwgXCJIZXJmaW5kYWhsOlwiXSxcbiAgICAgICAgdDIgPSBbKCtkLm1lYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksICgrZC5tZWRpYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksIGQubW9kZSwgcmludChkLmZyZXFtb2RlKSwgZC5taWQsIHJpbnQoZC5mcmVxbWlkKSwgZC5mZXdlc3QsIHJpbnQoZC5mcmVxZmV3ZXN0KSwgKCtkLnNkKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCAoK2QubWluKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCAoK2QubWF4KS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpLCByaW50KGQuaW52YWxpZCksIHJpbnQoZC52YWxpZCksIHJpbnQoZC51bmlxdWVzKSwgKCtkLmhlcmZpbmRhaGwpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCldLFxuICAgICAgICBpLCBqO1xuICAgIGlmIChwcml2KSB7XG4gICAgICAgIGlmIChkLm1lYW5DSSkge1xuICAgICAgICAgICAgdDEgPSBbXCJNZWFuOlwiLCBcIk1lZGlhbjpcIiwgXCJNb3N0IEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTWVkaWFuIEZyZXE6XCIsIFwiT2NjdXJyZW5jZXM6XCIsIFwiTGVhc3QgRnJlcTpcIiwgXCJPY2N1cnJlbmNlczpcIiwgXCJTdGFuZC5EZXY6XCIsIFwiTWluaW11bTpcIiwgXCJNYXhpbXVtOlwiLCBcIkludmFsaWQ6XCIsIFwiVmFsaWQ6XCIsIFwiVW5pcXVlczpcIiwgXCJIZXJmaW5kYWhsOlwiXSxcbiAgICAgICAgICAgICAgICB0MiA9IFsoK2QubWVhbikudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiIChcIiArICgrZC5tZWFuQ0kubG93ZXJCb3VuZCkudG9QcmVjaXNpb24oMikudG9TdHJpbmcoKSArIFwiIC0gXCIgKyAoK2QubWVhbkNJLnVwcGVyQm91bmQpLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCkgKyBcIilcIiwgKCtkLm1lZGlhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLCAoK2Quc2QpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksICgrZC5taW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksICgrZC5tYXgpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCksIHJpbnQoZC5pbnZhbGlkKSwgcmludChkLnZhbGlkKSwgcmludChkLnVuaXF1ZXMpLCAoK2QuaGVyZmluZGFobCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKV0sXG4gICAgICAgICAgICAgICAgaSwgajtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0MS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodDJbaV0uaW5kZXhPZihcIk5hTlwiKSA+IC0xIHwgdDJbaV0gPT0gXCJOQVwiIHwgdDJbaV0gPT0gXCJcIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0bXBEYXRhc2V0ID0gW107XG4gICAgICAgIHRtcERhdGFzZXQucHVzaCh0MVtpXSk7XG4gICAgICAgIHRtcERhdGFzZXQucHVzaCh0MltpXSk7XG4gICAgICAgIHN1bW1hcnlkYXRhLnB1c2godG1wRGF0YXNldCk7XG4gICAgfTtcblxuICAgIGQzLnNlbGVjdChcIiN0YWIzXCIpIC8vIHRhYiB3aGVuIHlvdSBtb3VzZW92ZXIgYSBwZWJibGVcbiAgICAgICAgLnNlbGVjdChcInBcIilcbiAgICAgICAgLmh0bWwoXCI8Y2VudGVyPjxiPlwiICsgZC5uYW1lICsgXCI8L2I+PGJyPjxpPlwiICsgZC5sYWJsICsgXCI8L2k+PC9jZW50ZXI+XCIpXG4gICAgICAgIC5hcHBlbmQoXCJ0YWJsZVwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgICAgLmRhdGEoc3VtbWFyeWRhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0ZFwiKVxuICAgICAgICAuZGF0YShkID0+IGQpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRkXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsICgpID0+IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCJhbGljZWJsdWVcIikpXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsICgpID0+IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRjlGOUY5XCIpKTtcblxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KFwiI3RhYjNcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICBpZiAodHlwZW9mIGQucGxvdHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIC8vIC5wcm9wZXJ0aWVzIGlzIHVuZGVmaW5lZCBmb3Igc29tZSB2YXJzXG4gICAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmIChkLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikgZGVuc2l0eShkLCBkaXYgPSBcInZhclN1bW1hcnlcIiwgcHJpdik7XG4gICAgZWxzZSBpZiAoZC5wbG90dHlwZSA9PT0gXCJiYXJcIikgYmFycyhkLCBkaXYgPSBcInZhclN1bW1hcnlcIiwgcHJpdik7XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KFwiI3RhYjNcIikgLy8gbm8gZ3JhcGggdG8gZHJhdywgYnV0IHN0aWxsIG5lZWQgdG8gcmVtb3ZlIHByZXZpb3VzIGdyYXBoXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVQb3BvdmVyKCkge1xuICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZCA9PiBwb3BvdmVyQ29udGVudChhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KGQpXSkpO1xufVxuXG5mdW5jdGlvbiBwb3BvdmVyQ29udGVudChkKSB7XG4gICAgdmFyIHJpbnQgPSBkMy5mb3JtYXQoXCJyXCIpO1xuICAgIHZhciBvdXR0ZXh0ID0gXCJcIjtcbiAgICBpZiAoZC5sYWJsICE9IFwiXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TGFiZWw8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+PGk+XCIgKyBkLmxhYmwgKyBcIjwvaT48L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLm1lYW4gIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lYW48L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCJcbiAgICAgICAgaWYgKHByaXYgJiYgZC5tZWFuQ0kpIHtcbiAgICAgICAgICAgIG91dHRleHQgKz0gKCtkLm1lYW4pLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCkgKyBcIiAoXCIgKyAoK2QubWVhbkNJLmxvd2VyQm91bmQpLnRvUHJlY2lzaW9uKDIpLnRvU3RyaW5nKCkgKyBcIiAtIFwiICsgKCtkLm1lYW5DSS51cHBlckJvdW5kKS50b1ByZWNpc2lvbigyKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHRleHQgKz0gKCtkLm1lYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKClcbiAgICAgICAgfVxuICAgICAgICBvdXR0ZXh0ICs9IFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBpZiAoZC5tZWRpYW4gIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lZGlhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArICgrZC5tZWRpYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgaWYgKGQubW9kZSAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TW9zdCBGcmVxPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgZC5tb2RlICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLmZyZXFtb2RlICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5PY2N1cnJlbmNlczwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC5mcmVxbW9kZSkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgaWYgKGQubWlkICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NZWRpYW4gRnJlcTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIGQubWlkICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLmZyZXFtaWQgIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk9jY3VycmVuY2VzPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLmZyZXFtaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLmZld2VzdCAhPSBcIk5BXCIpIHtcbiAgICAgICAgb3V0dGV4dCA9IG91dHRleHQgKyBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TGVhc3QgRnJlcTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIGQuZmV3ZXN0ICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLmZyZXFmZXdlc3QgIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk9jY3VycmVuY2VzPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLmZyZXFmZXdlc3QpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLnNkICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5TdGFuZCBEZXY8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyAoK2Quc2QpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgaWYgKGQubWF4ICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NYXhpbXVtPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgKCtkLm1heCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBpZiAoZC5taW4gIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1pbmltdW08L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyAoK2QubWluKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLmludmFsaWQgIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPkludmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuaW52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIjtcbiAgICB9XG4gICAgaWYgKGQudmFsaWQgIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPlZhbGlkPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLnZhbGlkKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICBpZiAoZC51bmlxdWVzICE9IFwiTkFcIikge1xuICAgICAgICBvdXR0ZXh0ID0gb3V0dGV4dCArIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5VbmlxdWVzPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgcmludChkLnVuaXF1ZXMpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCI7XG4gICAgfVxuICAgIGlmIChkLmhlcmZpbmRhaGwgIT0gXCJOQVwiKSB7XG4gICAgICAgIG91dHRleHQgPSBvdXR0ZXh0ICsgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPkhlcmZpbmRhaGw8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyAoK2QuaGVyZmluZGFobCkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiO1xuICAgIH1cbiAgICByZXR1cm4gb3V0dGV4dDtcbn1cblxuZnVuY3Rpb24gcG9wdXBYKGQpIHtcbiAgICB2YXIgdHNmID0gZDMuZm9ybWF0KFwiLjRyXCIpO1xuICAgIHZhciByaW50ID0gZDMuZm9ybWF0KFwiclwiKTtcbiAgICAvL0NyZWF0ZSB0aGUgdG9vbHRpcCBsYWJlbFxuICAgIGQzLnNlbGVjdChcIiN0b29sdGlwXCIpXG4gICAgICAgIC5zdHlsZShcImxlZnRcIiwgdGVtcFggKyBcInB4XCIpXG4gICAgICAgIC5zdHlsZShcInRvcFwiLCB0ZW1wWSArIFwicHhcIilcbiAgICAgICAgLnNlbGVjdChcIiN0b29sdGlwdGV4dFwiKVxuICAgICAgICAuaHRtbChcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lYW4pICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lZGlhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lZGlhbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TW9kZTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIGQubW9kZSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5TdGFuZCBEZXY8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyB0c2YoZC5zZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWF4aW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1heCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWluaW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1pbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+VmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQudmFsaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPkludmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuaW52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIlxuICAgICAgICApO1xufVxuXG5mdW5jdGlvbiBwYW5lbFBsb3RzKCkge1xuICAgIC8vIGJ1aWxkIGFycmF5cyBmcm9tIG5vZGVzIGluIG1haW5cbiAgICBsZXQgdmFycyA9IFtdO1xuICAgIGxldCBpZHMgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICB2YXJzLnB1c2gobi5uYW1lLnJlcGxhY2UoL1xcKHxcXCkvZywgJycpKTtcbiAgICAgICAgaWRzLnB1c2gobi5pZCk7XG4gICAgfSk7XG5cbiAgICAvL3JlbW92ZSBhbGwgcGxvdHMsIGNvdWxkIGJlIHNtYXJ0ZXIgaGVyZVxuICAgIGQzLnNlbGVjdCgnI3NldHgnKS5zZWxlY3RBbGwoJ3N2ZycpLnJlbW92ZSgpO1xuICAgIGQzLnNlbGVjdCgnI3RhYjInKS5zZWxlY3RBbGwoJ3N2ZycpLnJlbW92ZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IGFsbE5vZGVzW2lkc1tpXV07XG4gICAgICAgIG5vZGUuc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgIGlmIChub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocHJpdik7XG4gICAgICAgICAgICBkZW5zaXR5KG5vZGUsIGRpdiA9IFwic2V0eFwiLCBwcml2KTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBkZW5zaXR5KG5vZGUsIGRpdiA9IFwic3Vic2V0XCIsIHByaXYpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiYmFyXCIgJiBub2RlLnNldHhwbG90ID09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnNldHhwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhcnMobm9kZSwgZGl2ID0gXCJzZXR4XCIsIHByaXYpO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhcnNTdWJzZXQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkMy5zZWxlY3QoXCIjc2V0eFwiKS5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHJlZ3N0ciA9IC8oLispX3NldHhfKFxcZCspLztcbiAgICAgICAgICAgIHZhciBteW5hbWUgPSByZWdzdHIuZXhlYyh0aGlzLmlkKTtcbiAgICAgICAgICAgIHZhciBub2RlaWQgPSBteW5hbWVbMl07XG4gICAgICAgICAgICBteW5hbWUgPSBteW5hbWVbMV07XG4gICAgICAgICAgICB2YXIgaiA9IHZhcnMuaW5kZXhPZihteW5hbWUpO1xuICAgICAgICAgICAgaWYgKGogPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tub2RlaWRdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl9zZXR4X1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbm9kZWlkXS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl90YWIyX1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufVxuXG4vLyBlYXN5IGZ1bmN0aW9ucyB0byBjb2xsYXBzZSBwYW5lbHMgdG8gYmFzZVxuZnVuY3Rpb24gcmlnaHRwYW5lbE1lZGl1bSgpIHtcbiAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbn1cblxuZnVuY3Rpb24gbGVmdHBhbmVsTWVkaXVtKCkge1xuICAgIGQzLnNlbGVjdChcIiNsZWZ0cGFuZWxcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG59XG5cbi8vIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29sb3IgY29kZXNcbmZ1bmN0aW9uIGhleFRvUmdiYShoZXgpIHtcbiAgICB2YXIgaCA9IGhleC5yZXBsYWNlKCcjJywgJycpO1xuICAgIHZhciBiaWdpbnQgPSBwYXJzZUludChoLCAxNik7XG4gICAgdmFyIHIgPSAoYmlnaW50ID4+IDE2KSAmIDI1NTtcbiAgICB2YXIgZyA9IChiaWdpbnQgPj4gOCkgJiAyNTU7XG4gICAgdmFyIGIgPSBiaWdpbnQgJiAyNTU7XG4gICAgdmFyIGEgPSAnMC41JztcbiAgICByZXR1cm4gXCJyZ2JhKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiLFwiICsgYSArIFwiKVwiO1xufVxuXG4vLyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgYW5kIGEgY29sb3IgYW5kIHVwZGF0ZXMgenBhcmFtc1xuZnVuY3Rpb24gc2V0Q29sb3JzKG4sIGMpIHtcbiAgICBpZiAobi5zdHJva2VXaWR0aCA9PSAnMScpIHsgLy8gYWRkaW5nIHRpbWUsIGNzLCBkdiwgbm9tIHRvIGEgbm9kZSB3aXRoIG5vIHN0cm9rZVxuICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzQnO1xuICAgICAgICBuLnN0cm9rZUNvbG9yID0gYztcbiAgICAgICAgbi5ub2RlQ29sID0gdGFnZ2VkQ29sb3I7XG4gICAgICAgIGlmIChkdkNvbG9yID09IGMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFycmF5LCBpZiBub3QsIG1ha2UgaXQgYW4gYXJyYXlcbiAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoenBhcmFtcy56ZHYpKTtcbiAgICAgICAgICAgIHpwYXJhbXMuemR2ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHpwYXJhbXMuemR2KSA9PSBcIltvYmplY3QgQXJyYXldXCIgPyB6cGFyYW1zLnpkdiA6IFtdO1xuICAgICAgICAgICAgenBhcmFtcy56ZHYucHVzaChuLm5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNzQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgenBhcmFtcy56Y3Jvc3MgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoenBhcmFtcy56Y3Jvc3MpID09IFwiW29iamVjdCBBcnJheV1cIiA/IHpwYXJhbXMuemNyb3NzIDogW107XG4gICAgICAgICAgICB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZUNvbG9yID09IGMpIHtcbiAgICAgICAgICAgIHpwYXJhbXMuenRpbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoenBhcmFtcy56dGltZSkgPT0gXCJbb2JqZWN0IEFycmF5XVwiID8genBhcmFtcy56dGltZSA6IFtdO1xuICAgICAgICAgICAgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9tQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgenBhcmFtcy56bm9tID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHpwYXJhbXMuem5vbSkgPT0gXCJbb2JqZWN0IEFycmF5XVwiID8genBhcmFtcy56bm9tIDogW107XG4gICAgICAgICAgICB6cGFyYW1zLnpub20ucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgYWxsTm9kZXNbZmluZE5vZGVJbmRleChuLm5hbWUpXS5uYXR1cmUgPSBcIm5vbWluYWxcIjtcbiAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZDMuc2VsZWN0KFwiI3RhYjFcIikuc2VsZWN0KFwicCNcIi5jb25jYXQobi5uYW1lKSlcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShjKSk7XG4gICAgfSBlbHNlIGlmIChuLnN0cm9rZVdpZHRoID09ICc0Jykge1xuICAgICAgICBpZiAoYyA9PSBuLnN0cm9rZUNvbG9yKSB7IC8vIGRlc2VsZWN0aW5nIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzEnO1xuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgbi5ub2RlQ29sID0gY29sb3JzKG4uaWQpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RhYjFcIikuc2VsZWN0KFwicCNcIi5jb25jYXQobi5uYW1lKSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKTtcblxuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gYykge1xuICAgICAgICAgICAgICAgIHZhciBkdkluZGV4ID0genBhcmFtcy56ZHYuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChkdkluZGV4ID4gLTEpIHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3NDb2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzSW5kZXggPSB6cGFyYW1zLnpjcm9zcy5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNzSW5kZXggPiAtMSkgenBhcmFtcy56Y3Jvc3Muc3BsaWNlKGNzSW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lSW5kZXggPSB6cGFyYW1zLnp0aW1lLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodGltZUluZGV4ID4gLTEpIHpwYXJhbXMuenRpbWUuc3BsaWNlKHRpbWVJbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vbUNvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9tSW5kZXggPSB6cGFyYW1zLnpub20uaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChub21JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem5vbS5zcGxpY2Uobm9tSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG4ubmFtZSldLm5hdHVyZSA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobi5uYW1lKV0uZGVmYXVsdE5hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGRlc2VsZWN0aW5nIHRpbWUsIGNzLCBkdiwgbm9tIEFORCBjaGFuZ2luZyBpdCB0byB0aW1lLCBjcywgZHYsIG5vbVxuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gbi5zdHJva2VDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBkdkluZGV4ID0genBhcmFtcy56ZHYuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChkdkluZGV4ID4gLTEpIHpwYXJhbXMuemR2LnNwbGljZShkdkluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3NDb2xvciA9PSBuLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzSW5kZXggPSB6cGFyYW1zLnpjcm9zcy5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNzSW5kZXggPiAtMSkgenBhcmFtcy56Y3Jvc3Muc3BsaWNlKGNzSW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lQ29sb3IgPT0gbi5zdHJva2VDb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lSW5kZXggPSB6cGFyYW1zLnp0aW1lLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodGltZUluZGV4ID4gLTEpIHpwYXJhbXMuenRpbWUuc3BsaWNlKHRpbWVJbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vbUNvbG9yID09IG4uc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9tSW5kZXggPSB6cGFyYW1zLnpub20uaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChub21JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem5vbS5zcGxpY2Uobm9tSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG4ubmFtZSldLm5hdHVyZSA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgobi5uYW1lKV0uZGVmYXVsdE5hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuLnN0cm9rZUNvbG9yID0gYztcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0YWIxXCIpLnNlbGVjdChcInAjXCIuY29uY2F0KG4ubmFtZSkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKGMpKTtcblxuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gYykgenBhcmFtcy56ZHYucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3NDb2xvciA9PSBjKSB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lQ29sb3IgPT0gYykgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub21Db2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KG4ubmFtZSldLm5hdHVyZSA9IFwibm9taW5hbFwiO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJvcmRlclN0YXRlKCkge1xuICAgIHpwYXJhbXMuemR2Lmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZHZCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZHZDb2xvcikgOlxuICAgICAgICAkKCcjZHZCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Y3Jvc3MubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNjc0J1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBjc0NvbG9yKSA6XG4gICAgICAgICQoJyNjc0J1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnp0aW1lLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjdGltZUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCB0aW1lQ29sb3IpIDpcbiAgICAgICAgJCgnI3RpbWVCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56bm9tLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjbm9tQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIG5vbUNvbG9yKSA6XG4gICAgICAgICQoJyNub21CdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG59XG5cbi8vIHNtYWxsIGFwcGVhcmFuY2UgcmVzZXRzLCBidXQgcGVyaGFwcyB0aGlzIHdpbGwgYmVjb21lIGEgaGFyZCByZXNldCBiYWNrIHRvIGFsbCBvcmlnaW5hbCBhbGxOb2RlIHZhbHVlcz9cbmZ1bmN0aW9uIG5vZGVSZXNldChuKSB7XG4gICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgIG4uc3Ryb2tlV2lkdGggPSBcIjFcIjtcbiAgICBuLm5vZGVDb2wgPSBuLmJhc2VDb2w7XG59XG5cbmZ1bmN0aW9uIHN1YnNldFNlbGVjdChidG4pIHtcbiAgICBpZiAoZGF0YXVybCkge1xuICAgICAgICB6cGFyYW1zLnpkYXRhdXJsID0gZGF0YXVybDtcbiAgICB9XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgenBhcmFtcy56c2Vzc2lvbmlkID09IFwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHpwYXJhbXMuenZhcnMgPSBbXTtcbiAgICB6cGFyYW1zLnpwbG90ID0gW107XG4gICAgdmFyIHN1YnNldEVtcHR5ID0gdHJ1ZTtcbiAgICAvLyBpcyB0aGlzIHRoZSBzYW1lIGFzIHpQb3AoKT9cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7IC8vIHBvcHVsYXRlIHp2YXJzIGFuZCB6c3Vic2V0IGFycmF5c1xuICAgICAgICB6cGFyYW1zLnp2YXJzLnB1c2gobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIHZhciB0ZW1wID0gbm9kZXNbal0uaWQ7XG4gICAgICAgIHpwYXJhbXMuenN1YnNldFtqXSA9IGFsbE5vZGVzW3RlbXBdLnN1YnNldHJhbmdlO1xuICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMF0gIT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVswXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzFdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgenBhcmFtcy56cGxvdC5wdXNoKGFsbE5vZGVzW3RlbXBdLnBsb3R0eXBlKTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKSB7XG4gICAgICAgICAgICBzdWJzZXRFbXB0eSA9IGZhbHNlO1xuICAgICAgICB9IC8vIG9ubHkgbmVlZCB0byBjaGVjayBvbmVcbiAgICB9XG5cbiAgICBpZiAoc3Vic2V0RW1wdHkgPT0gdHJ1ZSkge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IE5vIG5ldyBzdWJzZXQgc2VsZWN0ZWQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBvdXR0eXBlcy5wdXNoKHtcbiAgICAgICAgICAgIHZhcm5hbWVzVHlwZXM6IGFsbE5vZGVzW2pdLm5hbWUsXG4gICAgICAgICAgICBuYXR1cmU6IGFsbE5vZGVzW2pdLm5hdHVyZSxcbiAgICAgICAgICAgIG51bWNoYXI6IGFsbE5vZGVzW2pdLm51bWNoYXIsXG4gICAgICAgICAgICBiaW5hcnk6IGFsbE5vZGVzW2pdLmJpbmFyeSxcbiAgICAgICAgICAgIGludGVydmFsOiBhbGxOb2Rlc1tqXS5pbnRlcnZhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3Vic2V0c3R1ZmYgPSB7XG4gICAgICAgIHpkYXRhdXJsOiB6cGFyYW1zLnpkYXRhdXJsLFxuICAgICAgICB6dmFyczogenBhcmFtcy56dmFycyxcbiAgICAgICAgenN1YnNldDogenBhcmFtcy56c3Vic2V0LFxuICAgICAgICB6c2Vzc2lvbmlkOiB6cGFyYW1zLnpzZXNzaW9uaWQsXG4gICAgICAgIHpwbG90OiB6cGFyYW1zLnpwbG90LFxuICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgIHR5cGVTdHVmZjogb3V0dHlwZXNcbiAgICB9O1xuXG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShzdWJzZXRzdHVmZik7XG4gICAgdmFyIHVybGNhbGwgPSByYXBwVVJMICsgXCJzdWJzZXRhcHBcIjtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY29uc29sZS5sb2coXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgIGZ1bmN0aW9uIHN1YnNldFNlbGVjdFN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIHNlbGVjdExhZGRhLnN0b3AoKTsgLy8gc3RvcCBtb3Rpb25cbiAgICAgICAgJChcIiNidG5WYXJpYWJsZXNcIikudHJpZ2dlcihcImNsaWNrXCIpOyAvLyBwcm9ncmFtbWF0aWMgY2xpY2tzXG4gICAgICAgICQoXCIjYnRuTW9kZWxzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcblxuICAgICAgICB2YXIgZ3JheU91dHMgPSBbXTtcbiAgICAgICAgdmFyIHJDYWxsID0gW107XG4gICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuXG4gICAgICAgIC8vIHN0b3JlIGNvbnRlbnRzIG9mIHRoZSBwcmUtc3Vic2V0IHNwYWNlXG4gICAgICAgIHpQb3AoKTtcbiAgICAgICAgdmFyIG15Tm9kZXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBhbGxOb2Rlcyk7XG4gICAgICAgIHZhciBteVBhcmFtcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHpwYXJhbXMpO1xuICAgICAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICAgICAgdmFyIG15Rm9yY2UgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBmb3JjZXRvZ2dsZSk7XG4gICAgICAgIHZhciBteVByZXByb2Nlc3MgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBwcmVwcm9jZXNzKTtcbiAgICAgICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgICAgICB2YXIgbXlIaXN0b3J5ID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgY2FsbEhpc3RvcnkpO1xuXG4gICAgICAgIHNwYWNlc1tteXNwYWNlXSA9IHtcbiAgICAgICAgICAgIFwiYWxsTm9kZXNcIjogbXlOb2RlcyxcbiAgICAgICAgICAgIFwienBhcmFtc1wiOiBteVBhcmFtcyxcbiAgICAgICAgICAgIFwidHJhbnNcIjogbXlUcmFucyxcbiAgICAgICAgICAgIFwiZm9yY2VcIjogbXlGb3JjZSxcbiAgICAgICAgICAgIFwicHJlcHJvY2Vzc1wiOiBteVByZXByb2Nlc3MsXG4gICAgICAgICAgICBcImxvZ0FycmF5XCI6IG15TG9nLFxuICAgICAgICAgICAgXCJjYWxsSGlzdG9yeVwiOiBteUhpc3RvcnlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgcHJlLXN1YnNldCBzdmdcbiAgICAgICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5hdHRyKCdjbGFzcycsICdpdGVtJyk7XG4gICAgICAgIHNlbGVjdE1lID0gXCIjd2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcblxuICAgICAgICBteXNwYWNlID0gc3BhY2VzLmxlbmd0aDtcbiAgICAgICAgY2FsbEhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICBmdW5jOiBcInN1YnNldFwiLFxuICAgICAgICAgICAgenZhcnM6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenZhcnMpLFxuICAgICAgICAgICAgenN1YnNldDogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56c3Vic2V0KSxcbiAgICAgICAgICAgIHpwbG90OiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnpwbG90KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGlzIGlzIHRvIGJlIHVzZWQgdG8gZ3JheSBvdXQgYW5kIHJlbW92ZSBsaXN0ZW5lcnMgZm9yIHZhcmlhYmxlcyB0aGF0IGhhdmUgYmVlbiBzdWJzZXR0ZWQgb3V0IG9mIHRoZSBkYXRhXG4gICAgICAgIGZ1bmN0aW9uIHZhck91dCh2KSB7XG4gICAgICAgICAgICAvLyBpZiBpbiBub2RlcywgcmVtb3ZlIGdyYXkgb3V0IGluIGxlZnQgcGFuZWxcbiAgICAgICAgICAgIC8vIG1ha2UgdW5jbGlja2FibGUgaW4gbGVmdCBwYW5lbFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdE1lID0gdltpXS5yZXBsYWNlKC9cXFcvZywgXCJfXCIpO1xuICAgICAgICAgICAgICAgIGJ5SWQoc2VsZWN0TWUpLnN0eWxlLmNvbG9yID0gaGV4VG9SZ2JhKGdyYXlDb2xvcik7XG4gICAgICAgICAgICAgICAgc2VsZWN0TWUgPSBcInAjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9nQXJyYXkucHVzaChcInN1YnNldDogXCIuY29uY2F0KHJDYWxsWzBdKSk7XG4gICAgICAgIHNob3dMb2coKTtcbiAgICAgICAgcmVXcml0ZUxvZygpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNpbm5lcmNhcm91c2VsXCIpXG4gICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0gYWN0aXZlJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICgpID0+IFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICd3aGl0ZXNwYWNlJyk7XG4gICAgICAgIHN2ZyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpO1xuXG4gICAgICAgIGQzLmpzb24oanNvbi51cmwsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15SW5kZXggPSBmaW5kTm9kZUluZGV4KGtleSk7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90dHlwZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIGFsbE5vZGVzW215SW5kZXhdLCBqc29uZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc3Vic2V0cmFuZ2UgPSBbXCJcIiwgXCJcIl07XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zZXR4dmFscyA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tteUluZGV4XS52YWxpZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXlPdXRzLnB1c2goYWxsTm9kZXNbbXlJbmRleF0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLmdyYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVQbG90KCk7XG4gICAgICAgICAgICBwb3B1bGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgIGxheW91dCh2ID0gXCJhZGRcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhck91dChncmF5T3V0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Vic2V0U2VsZWN0RmFpbChidG4pIHtcbiAgICAgICAgc2VsZWN0TGFkZGEuc3RvcCgpOyAvL3N0b3AgbW90aW9uXG4gICAgfVxuXG4gICAgc2VsZWN0TGFkZGEuc3RhcnQoKTsgLy9zdGFydCBidXR0b24gbW90aW9uXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgc3Vic2V0U2VsZWN0U3VjY2Vzcywgc3Vic2V0U2VsZWN0RmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG5mdW5jdGlvbiByZWFkUHJlcHJvY2Vzcyh1cmwsIHAsIHYsIGNhbGxiYWNrKSB7XG4gICAgY29uc29sZS5sb2codXJsKTtcbiAgICBkMy5qc29uKHVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgdmFyIGpzb25kYXRhID0ganNvbjtcblxuICAgICAgICBjb25zb2xlLmxvZyhcImluc2lkZSByZWFkUHJlcHJvY2VzcyBmdW5jdGlvblwiKTtcbiAgICAgICAgY29uc29sZS5sb2coanNvbmRhdGEpO1xuICAgICAgICBjb25zb2xlLmxvZyhqc29uZGF0YVtcInZhcmlhYmxlc1wiXSk7XG5cbiAgICAgICAgaWYgKGpzb25kYXRhLmRhdGFzZXQucHJpdikge1xuICAgICAgICAgICAgcHJpdiA9IGpzb25kYXRhW1wiZGF0YXNldFwiXVtcInByaXZcIl07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9jb3B5aW5nIHRoZSBvYmplY3RcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhW1widmFyaWFibGVzXCJdKSB7XG4gICAgICAgICAgICBwW2tleV0gPSBqc29uZGF0YVtcInZhcmlhYmxlc1wiXVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFib3V0KCkge1xuICAgICQoJyNhYm91dCcpLnNob3coKTtcbn1cblxuZnVuY3Rpb24gY2xvc2VhYm91dCgpIHtcbiAgICAkKCcjYWJvdXQnKS5oaWRlKCk7XG59XG5cbmZ1bmN0aW9uIG9wZW5jaXRlKCkge1xuICAgICQoJyNjaXRlJykuc2hvdygpO1xufVxuXG5mdW5jdGlvbiBjbG9zZWNpdGUodG9nZ2xlKSB7XG4gICAgaWYgKHRvZ2dsZSA9PSBmYWxzZSkgJCgnI2NpdGUnKS5oaWRlKCk7XG59XG5cbmZ1bmN0aW9uIGNsaWNrY2l0ZSh0b2dnbGUpIHtcbiAgICBpZiAodG9nZ2xlID09IGZhbHNlKSB7XG4gICAgICAgICQoJyNjaXRlJykuc2hvdygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgJCgnI2NpdGUnKS5oaWRlKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyByZW1vdmVzIGFsbCB0aGUgY2hpbGRyZW4gc3ZncyBpbnNpZGUgc3Vic2V0IGFuZCBzZXR4IGRpdnNcbmZ1bmN0aW9uIHJlUGxvdCgpIHtcbiAgICBkMy5zZWxlY3QoJyN0YWIyJylcbiAgICAgICAgLnNlbGVjdEFsbCgnc3ZnJylcbiAgICAgICAgLnJlbW92ZSgpO1xuICAgIGQzLnNlbGVjdCgnI3NldHgnKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgYWxsTm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgbi5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICBuLnN1YnNldHBsb3QgPSBmYWxzZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2hvd0xvZygpIHtcbiAgICBpZiAobG9nQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICBieUlkKCdsb2dkaXYnKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XG4gICAgICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAuZGF0YShsb2dBcnJheSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcblx0cmV0dXJuO1xuICAgIH1cbiAgICBieUlkKCdsb2dkaXYnKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6bm9uZVwiKTtcbn1cblxuZnVuY3Rpb24gcmVXcml0ZUxvZygpIHtcbiAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEobG9nQXJyYXkpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XG59XG5cbi8vIGFjdHMgYXMgaWYgdGhlIHVzZXIgY2xpY2tlZCBpbiB3aGl0ZXNwYWNlLiB1c2VmdWwgd2hlbiByZXN0YXJ0KCkgaXMgb3V0c2lkZSBvZiBzY29wZVxuZnVuY3Rpb24gZmFrZUNsaWNrKCkge1xuICAgIHZhciBteXdzID0gXCIjd2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAvLyBkMyBhbmQgcHJvZ3JhbW1hdGljIGV2ZW50cyBkb24ndCBtZXNoIHdlbGwsIGhlcmUncyBhIFNPIHdvcmthcm91bmQgdGhhdCBsb29rcyBnb29kIGJ1dCB1c2VzIGpxdWVyeS4uLlxuICAgIGpRdWVyeS5mbi5kM0NsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVhY2goKGksIGUpID0+IHtcbiAgICAgICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KFwibW91c2Vkb3duXCIsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgJChteXdzKS5kM0NsaWNrKCk7XG4gICAgZDMuc2VsZWN0KG15d3MpXG4gICAgICAgIC5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FwcF9kZGkuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBcUZBO0FBK3VEQTtBQUNBO0FBcjBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQVNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBTEE7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQVNBO0FBQ0E7QUFHQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBR0E7QUFHQTtBQUVBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/* no static exports found */
/* all exports used */
/*!********************************************!*\
  !*** ./Ladda/dist/ladda-themeless.min.css ***!
  \********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3M/MWY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 3 */
/* no static exports found */
/* all exports used */
/*!*****************!*\
  !*** ./app.css ***!
  \*****************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FwcC5jc3M/N2YyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 4 */
/* no static exports found */
/* all exports used */
/*!***********************************************!*\
  !*** ./bootstrap/css/bootstrap-theme.min.css ***!
  \***********************************************/
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3M/OTBiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/* no static exports found */
/* all exports used */
/*!******************************!*\
  !*** ./~/mithril/mithril.js ***!
  \******************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n\"use strict\"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode(\"[\", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== \"object\") return Vnode(\"#\", undefined, undefined, node === false ? \"\" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*(\"|'|)((?:\\\\[\"'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = \"div\", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === \"\" && value !== \"\") tag = value\n\t\telse if (type === \"#\") attrs.id = value\n\t\telse if (type === \".\") classes.push(value)\n\t\telse if (match[3][0] === \"[\") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\([\"'])/g, \"$1\").replace(/\\\\\\\\/g, \"\\\\\")\n\t\t\tif (match[4] === \"class\") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(\" \")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + \" \" + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== \"key\") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === \"#\") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== \"string\" && typeof selector !== \"function\" && typeof selector.view !== \"function\") {\n\t\tthrow Error(\"The selector must be either a string or a component.\");\n\t}\n\tif (typeof selector === \"string\") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== \"object\" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === \"string\") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = \"\"\n\treturn Vnode(\"<\", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode(\"[\", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error(\"Promise must be called with `new`\")\n\tif (typeof executor !== \"function\") throw new TypeError(\"executor must be a function\")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === \"object\" || typeof value === \"function\") && typeof (then = value.then) === \"function\") {\n\t\t\t\t\tif (value === self) throw new TypeError(\"Promise can't be resolved w/ itself\")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error(\"Possible unhandled promise rejection:\", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== \"function\") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === \"function\" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === \"object\" || typeof list[i] === \"function\") && typeof list[i].then === \"function\") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== \"undefined\") {\n\tif (typeof window.Promise === \"undefined\") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== \"undefined\") {\n\tif (typeof global.Promise === \"undefined\") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== \"[object Object]\") return \"\"\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join(\"&\")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === \"[object Object]\") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + \"[\" + i + \"]\", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== \"\" ? \"=\" + encodeURIComponent(value) : \"\"))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp(\"^file://\", \"i\")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === \"function\") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === \"string\") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = \"GET\"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === \"GET\" || args.method === \"TRACE\") ? false : (typeof args.useBody === \"boolean\" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== \"function\") args.serialize = typeof FormData !== \"undefined\" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== \"function\") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== \"function\") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === \"boolean\" ? args.async : true, typeof args.user === \"string\" ? args.user : undefined, typeof args.password === \"string\" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader(\"Accept\", \"application/json, text/*\")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === \"function\") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don't throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || \"_mithril_\" + Math.round(Math.random() * 1e16) + \"_\" + callbackCount++\n\t\t\tvar script = $window.document.createElement(\"script\")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error(\"JSONP request failed\"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || \"callback\"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== \"\") {\n\t\t\tvar prefix = url.indexOf(\"?\") < 0 ? \"?\" : \"&\"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== \"\" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === \"function\") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === \"string\") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase \"#\": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase \"<\": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase \"[\": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: \"table\", thead: \"table\", tbody: \"table\", tfoot: \"table\", tr: \"tbody\", th: \"tr\", td: \"tr\", colgroup: \"table\", col: \"colgroup\"}[match1[1]] || \"div\"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tswitch (vnode.tag) {\n\t\t\tcase \"svg\": ns = \"http://www.w3.org/2000/svg\"; break\n\t\t\tcase \"math\": ns = \"http://www.w3.org/1998/Math/MathML\"; break\n\t\t}\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== \"\") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === \"function\") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === \"function\") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, undefined)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, undefined, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === \"string\") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase \"#\": updateText(old, vnode); break\n\t\t\t\t\tcase \"<\": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase \"[\": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tswitch (vnode.tag) {\n\t\t\tcase \"svg\": ns = \"http://www.w3.org/2000/svg\"; break\n\t\t\tcase \"math\": ns = \"http://www.w3.org/1998/Math/MathML\"; break\n\t\t}\n\t\tif (vnode.tag === \"textarea\") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== \"\") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode(\"#\", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode(\"#\", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error(\"A view cannot return the vnode it received as argument\")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === \"<\") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error(\"Child node of a contenteditable must be trusted\")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeremove === \"function\") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === \"function\") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === \"string\") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === \"function\") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onremove === \"function\") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === \"key\" || key2 === \"is\" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== \"object\" || typeof value === \"undefined\" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(\":\")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === \"xlink\") {\n\t\t\telement.setAttributeNS(\"http://www.w3.org/1999/xlink\", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === \"o\" && key2[1] === \"n\" && typeof value === \"function\") updateEvent(vnode, key2, value)\n\t\telse if (key2 === \"style\") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\tif (vnode.tag === \"input\" && key2 === \"value\" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return\n\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\tif (vnode.tag === \"select\" && key2 === \"value\" && vnode.dom.value == value && vnode.dom === $doc.activeElement) return\n\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\tif (vnode.tag === \"option\" && key2 === \"value\" && vnode.dom.value == value) return\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === \"input\" && key2 === \"type\") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tif (value) element.setAttribute(key2, \"\")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === \"className\" ? \"class\" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === \"select\" && attrs2 != null) {\n\t\t\tif (\"value\" in attrs2) setAttr(vnode, \"value\", null, attrs2.value, undefined)\n\t\t\tif (\"selectedIndex\" in attrs2) setAttr(vnode, \"selectedIndex\", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === \"className\") key2 = \"class\"\n\t\t\t\t\tif (key2[0] === \"o\" && key2[1] === \"n\" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== \"key\") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === \"value\" || attr === \"checked\" || attr === \"selectedIndex\" || attr === \"selected\" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === \"oninit\" || attr === \"oncreate\" || attr === \"onupdate\" || attr === \"onremove\" || attr === \"onbeforeremove\" || attr === \"onbeforeupdate\"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === \"href\" || attr === \"list\" || attr === \"form\" || attr === \"width\" || attr === \"height\"// || attr === \"type\"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf(\"-\") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = \"\", old = null\n\t\tif (style == null) element.style.cssText = \"\"\n\t\telse if (typeof style === \"string\") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === \"string\") element.style.cssText = \"\"\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== \"string\") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== \"function\" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === \"function\" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === \"function\") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === \"function\") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === \"function\") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === \"function\") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== \"string\" && typeof vnode._state.onbeforeupdate === \"function\") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error(\"Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.\")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = \"\"\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, undefined)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw !== false) redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== \"function\") throw new Error(\"m.mount(element, component) expects a component, not a vnode\")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === \"\" || string == null) return {}\n\tif (string.charAt(0) === \"?\") string = string.slice(1)\n\tvar entries = string.split(\"&\"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split(\"=\")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : \"\"\n\t\tif (value === \"true\") value = true\n\t\telse if (value === \"false\") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf(\"[\") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == \"\" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === \"\") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === \"function\"\n\tvar callAsync0 = typeof setImmediate === \"function\" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === \"pathname\" && data[0] !== \"/\") data = \"/\" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf(\"?\")\n\t\tvar hashIndex = path.indexOf(\"#\")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: \"#!\"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase \"#\": return normalize1(\"hash\").slice(router.prefix.length)\n\t\t\tcase \"?\": return normalize1(\"search\").slice(router.prefix.length) + normalize1(\"hash\")\n\t\t\tdefault: return normalize1(\"pathname\").slice(router.prefix.length) + normalize1(\"search\") + normalize1(\"hash\")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += \"?\" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += \"#\" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp(\"^\" + route0.replace(/:[^\\/]+?\\.{3}/g, \"(.*?)\").replace(/:[^\\/]+/g, \"([^\\\\/]+)\") + \"\\/?$\")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, \"\")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === \"#\") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error(\"Ensure the DOM element that was passed to `m.route` is not undefined\")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error(\"Could not resolve default route \" + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === \"function\" || typeof comp === \"function\")? comp : \"div\"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === \"function\") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, \"div\")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) options = {replace: true}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute(\"href\", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute(\"href\")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== \"undefined\" && typeof key3 !== \"undefined\") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = \"1.1.1\"\nm.vnode = Vnode\nif (true) module[\"exports\"] = m\nelse window.m = m\n}());\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../timers-browserify/main.js */ 10).setImmediate, __webpack_require__(/*! ./../webpack/buildin/global.js */ 0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWl0aHJpbC9taXRocmlsLmpzP2JkNDIiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdHZhciBpcyA9IGF0dHJzMiAmJiBhdHRyczIuaXNcblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdHNldEF0dHJzKHZub2RlLCBhdHRyczIsIG5zKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS50ZXh0ICE9PSBcIlwiKSBlbGVtZW50LnRleHRDb250ZW50ID0gdm5vZGUudGV4dFxuXHRcdFx0XHRlbHNlIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdFx0Y3JlYXRlTm9kZXMoZWxlbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdFx0XHRzZXRMYXRlQXR0cnModm5vZGUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpIHtcblx0XHR2YXIgc2VudGluZWxcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZy52aWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gT2JqZWN0LmNyZWF0ZSh2bm9kZS50YWcpXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnN0YXRlLnZpZXdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHZvaWQgMFxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS50YWdcblx0XHRcdGlmIChzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCAhPSBudWxsKSByZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gdHJ1ZVxuXHRcdFx0dm5vZGUuc3RhdGUgPSAodm5vZGUudGFnLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS50YWcucHJvdG90eXBlLnZpZXcgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgdm5vZGUudGFnKHZub2RlKSA6IHZub2RlLnRhZyh2bm9kZSlcblx0XHR9XG5cdFx0dm5vZGUuX3N0YXRlID0gdm5vZGUuc3RhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdGluaXRMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSBudWxsXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5kb20gIT0gbnVsbCA/IHZub2RlLmluc3RhbmNlLmRvbVNpemUgOiAwXG5cdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gZWxlbWVudFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0XHRyZXR1cm4gJGVtcHR5RnJhZ21lbnRcblx0XHR9XG5cdH1cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgdW5kZWZpbmVkKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIHVuZGVmaW5lZCwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRzd2l0Y2ggKHZub2RlLnRhZykge1xuXHRcdFx0Y2FzZSBcInN2Z1wiOiBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjsgYnJlYWtcblx0XHRcdGNhc2UgXCJtYXRoXCI6IG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7IGJyZWFrXG5cdFx0fVxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkyID09PSBcInZhbHVlXCIgJiYgdm5vZGUuZG9tLnZhbHVlID09IHZhbHVlICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcInNlbGVjdFwiICYmIGtleTIgPT09IFwidmFsdWVcIiAmJiB2bm9kZS5kb20udmFsdWUgPT0gdmFsdWUgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYga2V5MiA9PT0gXCJ2YWx1ZVwiICYmIHZub2RlLmRvbS52YWx1ZSA9PSB2YWx1ZSkgcmV0dXJuXG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCBcIlwiKVxuXHRcdFx0XHRlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkyLCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0TGF0ZUF0dHJzKHZub2RlKSB7XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwidmFsdWVcIiwgbnVsbCwgYXR0cnMyLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMyLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMyLCBucykge1xuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5Miwgb2xkICYmIG9sZFtrZXkyXSwgYXR0cnMyW2tleTJdLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRpZiAoYXR0cnMyID09IG51bGwgfHwgIShrZXkyIGluIGF0dHJzMikpIHtcblx0XHRcdFx0XHRpZiAoa2V5MiA9PT0gXCJjbGFzc05hbWVcIikga2V5MiA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5MiAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXHQvL3N0eWxlXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgc3R5bGUpIHtcblx0XHRpZiAob2xkID09PSBzdHlsZSkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIiwgb2xkID0gbnVsbFxuXHRcdGlmIChzdHlsZSA9PSBudWxsKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdGZvciAodmFyIGtleTIgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXkyXSA9IHN0eWxlW2tleTJdXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkICE9IG51bGwgJiYgdHlwZW9mIG9sZCAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleTIgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleTJdID0gXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkyIGluIGVsZW1lbnQpIGVsZW1lbnRba2V5Ml0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleTIuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gPT09IGNhbGxiYWNrKSByZXR1cm5cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5Ml0gPSBjYWxsYmFja1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKGRvbSwgdm5vZGVzKSB7XG5cdFx0aWYgKCFkb20pIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKVxuXHRcdHZhciBob29rcyA9IFtdXG5cdFx0dmFyIGFjdGl2ZSA9ICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCB1bmRlZmluZWQpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0XHRpZiAoJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdH1cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XG5cdC8vNjBmcHMgdHJhbnNsYXRlcyB0byAxNi42bXMsIHJvdW5kIGl0IGRvd24gc2luY2Ugc2V0VGltZW91dCByZXF1aXJlcyBpbnRcblx0dmFyIHRpbWUgPSAxNlxuXHR2YXIgbGFzdCA9IDAsIHBlbmRpbmcgPSBudWxsXG5cdHZhciB0aW1lb3V0ID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dFxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KClcblx0XHRpZiAobGFzdCA9PT0gMCB8fCBub3cgLSBsYXN0ID49IHRpbWUpIHtcblx0XHRcdGxhc3QgPSBub3dcblx0XHRcdGNhbGxiYWNrKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHRcdFx0cGVuZGluZyA9IHRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrKClcblx0XHRcdFx0bGFzdCA9IERhdGUubm93KClcblx0XHRcdH0sIHRpbWUgLSAobm93IC0gbGFzdCkpXG5cdFx0fVxuXHR9XG59XG52YXIgXzExID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgcmVuZGVyU2VydmljZSA9IGNvcmVSZW5kZXJlcigkd2luZG93KVxuXHRyZW5kZXJTZXJ2aWNlLnNldEV2ZW50Q2FsbGJhY2soZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLnJlZHJhdyAhPT0gZmFsc2UpIHJlZHJhdygpXG5cdH0pXG5cdHZhciBjYWxsYmFja3MgPSBbXVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5MSwgY2FsbGJhY2spIHtcblx0XHR1bnN1YnNjcmliZShrZXkxKVxuXHRcdGNhbGxiYWNrcy5wdXNoKGtleTEsIHRocm90dGxlKGNhbGxiYWNrKSlcblx0fVxuXHRmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkxKSB7XG5cdFx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2Yoa2V5MSlcblx0XHRpZiAoaW5kZXggPiAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMilcblx0fVxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdGNhbGxiYWNrc1tpXSgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiB7c3Vic2NyaWJlOiBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSwgcmVkcmF3OiByZWRyYXcsIHJlbmRlcjogcmVuZGVyU2VydmljZS5yZW5kZXJ9XG59XG52YXIgcmVkcmF3U2VydmljZSA9IF8xMSh3aW5kb3cpXG5yZXF1ZXN0U2VydmljZS5zZXRDb21wbGV0aW9uQ2FsbGJhY2socmVkcmF3U2VydmljZS5yZWRyYXcpXG52YXIgXzE2ID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZTApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBbXSlcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvbXBvbmVudC52aWV3ID09IG51bGwgJiYgdHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJtLm1vdW50KGVsZW1lbnQsIGNvbXBvbmVudCkgZXhwZWN0cyBhIGNvbXBvbmVudCwgbm90IGEgdm5vZGVcIilcblx0XHRcblx0XHR2YXIgcnVuMCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFZub2RlKGNvbXBvbmVudCkpXG5cdFx0fVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4wKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnJlZHJhdygpXG5cdH1cbn1cbm0ubW91bnQgPSBfMTYocmVkcmF3U2VydmljZSlcbnZhciBQcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblx0dmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCImXCIpLCBkYXRhMCA9IHt9LCBjb3VudGVycyA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleTUgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblx0XHRpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWVcblx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlXG5cdFx0dmFyIGxldmVscyA9IGtleTUuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YTBcblx0XHRpZiAoa2V5NS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleTUgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXk1XSA9PSBudWxsKSBjb3VudGVyc1trZXk1XSA9IDBcblx0XHRcdFx0bGV2ZWwgPSBjb3VudGVyc1trZXk1XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnNvcltsZXZlbF0gPSBpc1ZhbHVlID8gdmFsdWUgOiBpc051bWJlciA/IFtdIDoge31cblx0XHRcdH1cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGEwXG59XG52YXIgY29yZVJvdXRlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgY2FsbEFzeW5jMCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gbm9ybWFsaXplMShmcmFnbWVudDApIHtcblx0XHR2YXIgZGF0YSA9ICR3aW5kb3cubG9jYXRpb25bZnJhZ21lbnQwXS5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0aWYgKGZyYWdtZW50MCA9PT0gXCJwYXRobmFtZVwiICYmIGRhdGFbMF0gIT09IFwiL1wiKSBkYXRhID0gXCIvXCIgKyBkYXRhXG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHR2YXIgYXN5bmNJZFxuXHRmdW5jdGlvbiBkZWJvdW5jZUFzeW5jKGNhbGxiYWNrMCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhc3luY0lkICE9IG51bGwpIHJldHVyblxuXHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYzAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrMCgpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSkge1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKVxuXHRcdHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpXG5cdFx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRcdHZhciBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBxdWVyeVBhcmFtcykgcXVlcnlEYXRhW2tleTRdID0gcXVlcnlQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0aWYgKGhhc2hJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgaGFzaFBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShoYXNoSW5kZXggKyAxKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gaGFzaFBhcmFtcykgaGFzaERhdGFba2V5NF0gPSBoYXNoUGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhFbmQpXG5cdH1cblx0dmFyIHJvdXRlciA9IHtwcmVmaXg6IFwiIyFcIn1cblx0cm91dGVyLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZTIgPSByb3V0ZXIucHJlZml4LmNoYXJBdCgwKVxuXHRcdHN3aXRjaCAodHlwZTIpIHtcblx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBub3JtYWxpemUxKFwiaGFzaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aClcblx0XHRcdGNhc2UgXCI/XCI6IHJldHVybiBub3JtYWxpemUxKFwic2VhcmNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gbm9ybWFsaXplMShcInBhdGhuYW1lXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdH1cblx0fVxuXHRyb3V0ZXIuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHR2YXIgcXVlcnlEYXRhID0ge30sIGhhc2hEYXRhID0ge31cblx0XHRwYXRoID0gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpXG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBkYXRhKSBxdWVyeURhdGFba2V5NF0gPSBkYXRhW2tleTRdXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uKG1hdGNoMiwgdG9rZW4pIHtcblx0XHRcdFx0ZGVsZXRlIHF1ZXJ5RGF0YVt0b2tlbl1cblx0XHRcdFx0cmV0dXJuIGRhdGFbdG9rZW5dXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHF1ZXJ5RGF0YSlcblx0XHRpZiAocXVlcnkpIHBhdGggKz0gXCI/XCIgKyBxdWVyeVxuXHRcdHZhciBoYXNoID0gYnVpbGRRdWVyeVN0cmluZyhoYXNoRGF0YSlcblx0XHRpZiAoaGFzaCkgcGF0aCArPSBcIiNcIiArIGhhc2hcblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0dmFyIHRpdGxlID0gb3B0aW9ucyA/IG9wdGlvbnMudGl0bGUgOiBudWxsXG5cdFx0XHQkd2luZG93Lm9ucG9wc3RhdGUoKVxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHR9XG5cdFx0ZWxzZSAkd2luZG93LmxvY2F0aW9uLmhyZWYgPSByb3V0ZXIucHJlZml4ICsgcGF0aFxuXHR9XG5cdHJvdXRlci5kZWZpbmVSb3V0ZXMgPSBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdHZhciBwYXRoID0gcm91dGVyLmdldFBhdGgoKVxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9XG5cdFx0XHR2YXIgcGF0aG5hbWUgPSBwYXJzZVBhdGgocGF0aCwgcGFyYW1zLCBwYXJhbXMpXG5cdFx0XHR2YXIgc3RhdGUgPSAkd2luZG93Lmhpc3Rvcnkuc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGsgaW4gc3RhdGUpIHBhcmFtc1trXSA9IHN0YXRlW2tdXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciByb3V0ZTAgaW4gcm91dGVzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIl5cIiArIHJvdXRlMC5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZywgXCIoLio/KVwiKS5yZXBsYWNlKC86W15cXC9dKy9nLCBcIihbXlxcXFwvXSspXCIpICsgXCJcXC8/JFwiKVxuXHRcdFx0XHRpZiAobWF0Y2hlci50ZXN0KHBhdGhuYW1lKSkge1xuXHRcdFx0XHRcdHBhdGhuYW1lLnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IHJvdXRlMC5tYXRjaCgvOlteXFwvXSsvZykgfHwgW11cblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTIpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW2tleXNbaV0ucmVwbGFjZSgvOnxcXC4vZywgXCJcIildID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUocm91dGVzW3JvdXRlMF0sIHBhcmFtcywgcGF0aCwgcm91dGUwKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChwYXRoLCBwYXJhbXMpXG5cdFx0fVxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkgJHdpbmRvdy5vbnBvcHN0YXRlID0gZGVib3VuY2VBc3luYyhyZXNvbHZlUm91dGUpXG5cdFx0ZWxzZSBpZiAocm91dGVyLnByZWZpeC5jaGFyQXQoMCkgPT09IFwiI1wiKSAkd2luZG93Lm9uaGFzaGNoYW5nZSA9IHJlc29sdmVSb3V0ZVxuXHRcdHJlc29sdmVSb3V0ZSgpXG5cdH1cblx0cmV0dXJuIHJvdXRlclxufVxudmFyIF8yMCA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UwKSB7XG5cdHZhciByb3V0ZVNlcnZpY2UgPSBjb3JlUm91dGVyKCR3aW5kb3cpXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHYpIHtyZXR1cm4gdn1cblx0dmFyIHJlbmRlcjEsIGNvbXBvbmVudCwgYXR0cnMzLCBjdXJyZW50UGF0aCwgbGFzdFVwZGF0ZVxuXHR2YXIgcm91dGUgPSBmdW5jdGlvbihyb290LCBkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuXHRcdGlmIChyb290ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIGBtLnJvdXRlYCBpcyBub3QgdW5kZWZpbmVkXCIpXG5cdFx0dmFyIHJ1bjEgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZW5kZXIxICE9IG51bGwpIHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCByZW5kZXIxKFZub2RlKGNvbXBvbmVudCwgYXR0cnMzLmtleSwgYXR0cnMzKSkpXG5cdFx0fVxuXHRcdHZhciBiYWlsID0gZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0aWYgKHBhdGggIT09IGRlZmF1bHRSb3V0ZSkgcm91dGVTZXJ2aWNlLnNldFBhdGgoZGVmYXVsdFJvdXRlLCBudWxsLCB7cmVwbGFjZTogdHJ1ZX0pXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGRlZmF1bHQgcm91dGUgXCIgKyBkZWZhdWx0Um91dGUpXG5cdFx0fVxuXHRcdHJvdXRlU2VydmljZS5kZWZpbmVSb3V0ZXMocm91dGVzLCBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIHBhdGgpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzMyA9IHBhcmFtcywgY3VycmVudFBhdGggPSBwYXRoLCBsYXN0VXBkYXRlID0gbnVsbFxuXHRcdFx0XHRyZW5kZXIxID0gKHJvdXRlUmVzb2x2ZXIucmVuZGVyIHx8IGlkZW50aXR5KS5iaW5kKHJvdXRlUmVzb2x2ZXIpXG5cdFx0XHRcdHJ1bjEoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGJhaWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB1cGRhdGUocGF5bG9hZCwgXCJkaXZcIilcblx0XHRcdH1cblx0XHR9LCBiYWlsKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4xKVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSBvcHRpb25zID0ge3JlcGxhY2U6IHRydWV9XG5cdFx0bGFzdFVwZGF0ZSA9IG51bGxcblx0XHRyb3V0ZVNlcnZpY2Uuc2V0UGF0aChwYXRoLCBkYXRhLCBvcHRpb25zKVxuXHR9XG5cdHJvdXRlLmdldCA9IGZ1bmN0aW9uKCkge3JldHVybiBjdXJyZW50UGF0aH1cblx0cm91dGUucHJlZml4ID0gZnVuY3Rpb24ocHJlZml4MCkge3JvdXRlU2VydmljZS5wcmVmaXggPSBwcmVmaXgwfVxuXHRyb3V0ZS5saW5rID0gZnVuY3Rpb24odm5vZGUxKSB7XG5cdFx0dm5vZGUxLmRvbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHJvdXRlU2VydmljZS5wcmVmaXggKyB2bm9kZTEuYXR0cnMuaHJlZilcblx0XHR2bm9kZTEuZG9tLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDIpIHJldHVyblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHR2YXIgaHJlZiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuXHRcdFx0aWYgKGhyZWYuaW5kZXhPZihyb3V0ZVNlcnZpY2UucHJlZml4KSA9PT0gMCkgaHJlZiA9IGhyZWYuc2xpY2Uocm91dGVTZXJ2aWNlLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRyb3V0ZS5zZXQoaHJlZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdHJvdXRlLnBhcmFtID0gZnVuY3Rpb24oa2V5Mykge1xuXHRcdGlmKHR5cGVvZiBhdHRyczMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGtleTMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBhdHRyczNba2V5M11cblx0XHRyZXR1cm4gYXR0cnMzXG5cdH1cblx0cmV0dXJuIHJvdXRlXG59XG5tLnJvdXRlID0gXzIwKHdpbmRvdywgcmVkcmF3U2VydmljZSlcbm0ud2l0aEF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSwgY2FsbGJhY2sxLCBjb250ZXh0KSB7XG5cdHJldHVybiBmdW5jdGlvbihlKSB7XG5cdFx0Y2FsbGJhY2sxLmNhbGwoY29udGV4dCB8fCB0aGlzLCBhdHRyTmFtZSBpbiBlLmN1cnJlbnRUYXJnZXQgPyBlLmN1cnJlbnRUYXJnZXRbYXR0ck5hbWVdIDogZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpXG5cdH1cbn1cbnZhciBfMjggPSBjb3JlUmVuZGVyZXIod2luZG93KVxubS5yZW5kZXIgPSBfMjgucmVuZGVyXG5tLnJlZHJhdyA9IHJlZHJhd1NlcnZpY2UucmVkcmF3XG5tLnJlcXVlc3QgPSByZXF1ZXN0U2VydmljZS5yZXF1ZXN0XG5tLmpzb25wID0gcmVxdWVzdFNlcnZpY2UuanNvbnBcbm0ucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmdcbm0uYnVpbGRRdWVyeVN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmdcbm0udmVyc2lvbiA9IFwiMS4xLjFcIlxubS52bm9kZSA9IFZub2RlXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IG1cbmVsc2Ugd2luZG93Lm0gPSBtXG59KCkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9taXRocmlsL21pdGhyaWwuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/* no static exports found */
/* all exports used */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../bootstrap/css/bootstrap-theme.min.css */ 4);\n\n__webpack_require__(/*! ../app.css */ 3);\n\n__webpack_require__(/*! ../Ladda/dist/ladda-themeless.min.css */ 2);\n\nvar _mithril = __webpack_require__(/*! mithril */ 5);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app_ddi = __webpack_require__(/*! ./app_ddi.js */ 1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction leftpanel() {\n    return (0, _mithril2.default)('#leftpanel.sidepanel.container.clearfix', [(0, _mithril2.default)('#toggleLpanelicon.panelbar', (0, _mithril2.default)(\"span\", [_mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\")])), (0, _mithril2.default)('#leftpaneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", \"Data Selection\")), (0, _mithril2.default)(\".btn-toolbar[role='toolbar']\", {\n        style: {\n            \"margin-left\": \".5em\",\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\".btn-group\", {\n        style: {\n            \"margin-left\": \"0\"\n        }\n    }, [(0, _mithril2.default)(\"button#btnVariables.btn.active[type='button']\", {\n        title: 'Click variable name to add or remove the variable pebble from the modeling space.',\n        onclick: function onclick(v) {\n            return (0, _app_ddi.tabLeft)('tab1');\n        }\n    }, \"Variables\"), (0, _mithril2.default)(\"button#btnSubset.btn.btn-default[type='button']\", {\n        onclick: function onclick(v) {\n            return (0, _app_ddi.tabLeft)('tab2');\n        }\n    }, \"Subset\")]), (0, _mithril2.default)(\"button#btnSelect.btn.btn-default.ladda-button[data-spinner-color='#000000'][data-style='zoom-in'][onclick='subsetSelect(\\'btnSelect\\');'][type='button']\", {\n        title: 'Subset data by the intersection of all selected values.',\n        style: {\n            \"display\": \"none\",\n            \"float\": \"right\",\n            \"margin-right\": \"10px\"\n        }\n    }, (0, _mithril2.default)(\"span.ladda-label\", {\n        style: {\n            \"pointer-events\": \"none\"\n        }\n    }, \"Select\"))]), (0, _mithril2.default)(\".row-fluid\", (0, _mithril2.default)('#leftpanelcontent', (0, _mithril2.default)('#leftContentArea', {\n        style: {\n            \"overflow\": \"scroll\",\n            \"height\": \"488px\"\n        }\n    }, [(0, _mithril2.default)('#tab1', {\n        style: {\n            \"display\": \"block\",\n            \"padding\": \"6px 12px\",\n            \"text-align\": \"center\"\n        }\n    }), (0, _mithril2.default)('#tab2', {\n        style: {\n            \"display\": \"none\",\n            \"margin-top\": \".5em\"\n        }\n    }), (0, _mithril2.default)('#tab3', (0, _mithril2.default)(\"p\", {\n        style: {\n            \"padding\": \".5em 1em\"\n        }\n    }, \"Select a variable from within the visualization in the center panel to view its summary statistics.\"))])))]);\n}\n\nfunction rightpanel() {\n    return (0, _mithril2.default)(\".sidepanel.container.clearfix[id='rightpanel']\", [(0, _mithril2.default)(\".panelbar[id='toggleRpanelicon']\", (0, _mithril2.default)(\"span\", [_mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\"), (0, _mithril2.default)(\"br\"), _mithril2.default.trust(\"&#9679;\")])), (0, _mithril2.default)(\".panel-heading.text-center[id='rightpaneltitle']\", (0, _mithril2.default)(\"h3.panel-title\", \"Model Selection\")), (0, _mithril2.default)(\".btn-group.btn-group-justified[aria-label='...'][role='group']\", {\n        style: {\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\"button.btn.active[id='btnModels'][onclick='tabRight(\\'btnModels\\');'][type='button']\", {\n        style: {\n            \"width\": \"33%\"\n        }\n    }, \"Models\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnSetx'][onclick='tabRight(\\'btnSetx\\');'][type='button']\", {\n        style: {\n            \"width\": \"34%\"\n        }\n    }, \"Set Covar.\"), (0, _mithril2.default)(\"button.btn.btn-default[id='btnResults'][onclick='tabRight(\\'btnResults\\');'][type='button']\", {\n        style: {\n            \"width\": \"33%\"\n        }\n    }, \"Results\")]), (0, _mithril2.default)(\".row-fluid\", (0, _mithril2.default)(\"[id='rightpanelcontent']\", (0, _mithril2.default)(\"[id='rightContentArea']\", {\n        style: {\n            \"overflow\": \"scroll\",\n            \"height\": \"488px\"\n        }\n    }, [(0, _mithril2.default)(\"[id='results']\", {\n        style: {\n            \"margin-top\": \".5em\"\n        }\n    }, [(0, _mithril2.default)(\".container[id='resultsView']\", {\n        style: {\n            \"width\": \"80%\",\n            \"background-color\": \"white\",\n            \"display\": \"none\",\n            \"float\": \"right\",\n            \"overflow\": \"auto\",\n            \"white-space\": \"nowrap\"\n        }\n    }), (0, _mithril2.default)(\"[id='modelView']\", {\n        style: {\n            \"width\": \"20%\",\n            \"background-color\": \"white\",\n            \"display\": \"none\",\n            \"float\": \"left\"\n        }\n    }), (0, _mithril2.default)(\"p[id='resultsHolder']\", {\n        style: {\n            \"padding\": \".5em 1em\"\n        }\n    })]), (0, _mithril2.default)(\"[id='setx']\", {\n        style: {\n            \"display\": \"none\"\n        }\n    }), (0, _mithril2.default)(\"[id='models']\", {\n        style: {\n            \"display\": \"block\",\n            \"padding\": \"6px 12px\",\n            \"text-align\": \"center\"\n        }\n    })])))]);\n}\n\nvar fileid = \"\";\nvar hostname = \"\";\nvar apikey = \"\";\nvar ddiurl = \"\";\nvar dataurl = \"\";\n\nvar Body = function () {\n    function Body() {\n        _classCallCheck(this, Body);\n    }\n\n    _createClass(Body, [{\n        key: 'oncreate',\n        value: function oncreate() {\n            $('#leftpanel span').click(function () {\n                if (!$('#leftpanel').hasClass('forceclosepanel')) {\n                    $('#leftpanel').removeClass('expandpanel');\n                    $('#leftpanel > div.row-fluid').toggleClass('closepanel');\n                    $('#leftpanel').toggleClass('closepanel');\n                    $('#main').toggleClass('svg-leftpanel');\n                    $('#btnSelect').css('display', 'none');\n                }\n            });\n            $('#rightpanel span').click(function () {\n                if (!$('#leftpanel').hasClass('forceclosepanel')) {\n                    $('#rightpanel').removeClass('expandpanel');\n                    $('#rightpanel > div.row-fluid').toggleClass('closepanel');\n                    $('#rightpanel').toggleClass('closepanel');\n                    $('#main').toggleClass('svg-rightpanel');\n                }\n            });\n\n            var myurl = window.location.toString();\n            var cindex = 0;\n            if (myurl.indexOf(\"dfId=\") > 0) {\n                fileid = myurl.substring(myurl.indexOf(\"dfId=\") + 5);\n                cindex = fileid.indexOf(\"&\");\n                if (cindex > 0) {\n                    fileid = fileid.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"host=\") > 0) {\n                hostname = myurl.substring(myurl.indexOf(\"host=\") + 5);\n                cindex = hostname.indexOf(\"&\");\n                if (cindex > 0) {\n                    hostname = hostname.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"key=\") > 0) {\n                apikey = myurl.substring(myurl.indexOf(\"key=\") + 4);\n                cindex = apikey.indexOf(\"&\");\n                if (cindex > 0) {\n                    apikey = apikey.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"ddiurl=\") > 0) {\n                ddiurl = myurl.substring(myurl.indexOf(\"ddiurl=\") + 7);\n                ddiurl = ddiurl.replace(/%25/g, \"%\");\n                ddiurl = ddiurl.replace(/%3A/g, \":\");\n                ddiurl = ddiurl.replace(/%2F/g, \"/\");\n                cindex = ddiurl.indexOf(\"&\");\n                if (cindex > 0) {\n                    ddiurl = ddiurl.substring(0, cindex);\n                };\n            };\n            if (myurl.indexOf(\"dataurl=\") > 0) {\n                dataurl = myurl.substring(myurl.indexOf(\"dataurl=\") + 8);\n                dataurl = dataurl.replace(/%25/g, \"%\");\n                dataurl = dataurl.replace(/%3A/g, \":\");\n                dataurl = dataurl.replace(/%2F/g, \"/\");\n                cindex = dataurl.indexOf(\"&\");\n                if (cindex > 0) {\n                    dataurl = dataurl.substring(0, cindex);\n                };\n            };\n\n            console.log(\"fileid: \" + fileid);\n            console.log(\"hostname: \" + hostname);\n            console.log(\"apikey: \" + apikey);\n            console.log(\"ddiurl: \" + ddiurl);\n            console.log(\"dataurl: \" + dataurl);\n\n            (0, _app_ddi.main)(fileid, hostname, ddiurl, dataurl);\n        }\n    }, {\n        key: 'view',\n        value: function view() {\n            return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav.navbar.navbar-default[id='option'][role='navigation']\", (0, _mithril2.default)(\"div\", [(0, _mithril2.default)(\".navbar-header[id='navbarheader']\", [(0, _mithril2.default)(\"img[alt='TwoRavens'][onmouseout='closeabout();'][onmouseover='about();'][src='images/TwoRavens.png'][width='100']\", {\n                style: {\n                    \"margin-left\": \"2em\",\n                    \"margin-top\": \"-0.5em\"\n                }\n            }), (0, _mithril2.default)(\".panel.panel-default[id='about']\", {\n                style: {\n                    \"position\": \"absolute\",\n                    \"left\": \"140px\",\n                    \"width\": \"380px\",\n                    \"display\": \"none\",\n                    \"z-index\": \"50\"\n                }\n            }, (0, _mithril2.default)(\".panel-body\"))]), (0, _mithril2.default)(\".field[id='dataField']\", {\n                style: {\n                    \"text-align\": \"center\",\n                    \"margin-top\": \"0.5em\"\n                }\n            }, [(0, _mithril2.default)(\"h4[id='dataName'][onclick='citetoggle=clickcite(citetoggle);'][onmouseout='closecite(citetoggle);'][onmouseover='opencite();']\", {\n                style: {\n                    \"display\": \"inline\"\n                }\n            }, \"Dataset Name\"), (0, _mithril2.default)(\".panel.panel-default[id='cite']\", {\n                style: {\n                    \"position\": \"absolute\",\n                    \"right\": \"50%\",\n                    \"width\": \"380px\",\n                    \"display\": \"none\",\n                    \"z-index\": \"50\",\n                    \"text-align\": \"left\"\n                }\n            }, (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)(\"button.btn.btn-default.ladda-button.navbar-right[data-spinner-color='#000000'][data-style='zoom-in'][id='btnEstimate'][onclick='estimate(\\'btnEstimate\\')']\", {\n                style: {\n                    \"margin-left\": \"2em\",\n                    \"margin-right\": \"1em\"\n                }\n            }, (0, _mithril2.default)(\"span.ladda-label\", \"Estimate\")), (0, _mithril2.default)(\"button.btn.btn-default.navbar-right[id='btnReset'][onclick='reset()'][title='Reset']\", {\n                style: {\n                    \"margin-left\": \"2.0em\"\n                }\n            }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-repeat\", {\n                style: {\n                    \"font-size\": \"1em\",\n                    \"color\": \"#818181\",\n                    \"pointer-events\": \"none\"\n                }\n            })), (0, _mithril2.default)(\".transformTool[id='transformations'][title='Construct transformations of existing variables using valid R syntax. For example, assuming a variable named d, you could enter \\'log(d)\\' or \\'d^2\\'.']\")])])), (0, _mithril2.default)(\".left.svg-leftpanel.svg-rightpanel.carousel.slide[id='main']\", [(0, _mithril2.default)(\".carousel-inner\"), (0, _mithril2.default)(\".spaceTool[id='spacetools']\", {\n                style: {\n                    \"z-index\": \"16\"\n                }\n            }, [(0, _mithril2.default)(\"button.btn.btn-default[id='btnForce'][onclick='forceSwitch()'][title='Pin the variable pebbles to the page.']\", (0, _mithril2.default)(\"span.glyphicon.glyphicon-pushpin\")), (0, _mithril2.default)(\"button.btn.btn-default[id='btnEraser'][onclick='erase()'][title='Wipe all variables from the modeling space.']\", (0, _mithril2.default)(\"span.glyphicon.glyphicon-magnet\"))]), (0, _mithril2.default)(\".legendary.panel.panel-default[id='legend']\", {\n                style: {\n                    \"display\": \"none\"\n                }\n            }, [(0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", [\"Legend  \", (0, _mithril2.default)(\"span.glyphicon.glyphicon-large.glyphicon-chevron-down.pull-right[data-target='#collapseLegend'][data-toggle='collapse'][href='#collapseLegend'][onclick='$(this).toggleClass(\\'glyphicon-chevron-up\\').toggleClass(\\'glyphicon-chevron-down\\');']\", {\n                style: _defineProperty({\n                    \"cursor\": \"pointer\"\n                }, 'cursor', \"hand\")\n            })])), (0, _mithril2.default)(\".panel-collapse.collapse.in[id='collapseLegend']\", (0, _mithril2.default)(\".panel-body\", [(0, _mithril2.default)(\".clearfix.hide[id='timeButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Time\")]), (0, _mithril2.default)(\".clearfix.hide[id='csButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Cross Sec\")]), (0, _mithril2.default)(\".clearfix.hide[id='dvButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Dep Var\")]), (0, _mithril2.default)(\".clearfix.hide[id='nomButton']\", [(0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg\", {\n                style: {\n                    \"width\": \"20px\",\n                    \"height\": \"20px\"\n                }\n            }, (0, _mithril2.default)(\"circle[cx='10'][cy='10'][fill='white'][r='9'][stroke='black'][stroke-width='2']\"))), (0, _mithril2.default)(\".rectLabel\", \"Nom Var\")])]))]), (0, _mithril2.default)(\".logbox.panel.panel-default[id='logdiv']\", {\n                style: {\n                    \"display\": \"none\"\n                }\n            }, [(0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", [\"History \", (0, _mithril2.default)(\"span.glyphicon.glyphicon-large.glyphicon-chevron-down.pull-right[data-target='#collapseLog'][data-toggle='collapse'][href='#collapseLog'][id='logicon'][onclick='$(this).toggleClass(\\'glyphicon-chevron-down\\').toggleClass(\\'glyphicon-chevron-up\\');']\", {\n                style: _defineProperty({\n                    \"cursor\": \"pointer\"\n                }, 'cursor', \"hand\")\n            })])), (0, _mithril2.default)(\".panel-collapse.collapse.in[id='collapseLog']\", (0, _mithril2.default)(\".panel-body\"))]), (0, _mithril2.default)(\"[id='ticker']\", {\n                style: {\n                    \"position\": \"fixed\",\n                    \"height\": \"50px\",\n                    \"width\": \"100%\",\n                    \"background\": \"#F9F9F9\",\n                    \"bottom\": \"0\"\n                }\n            }, (0, _mithril2.default)(\"a[href='somelink'][id='logID'][target='_blank']\", \"Replication\")), leftpanel(), rightpanel()]));\n        }\n    }]);\n\n    return Body;\n}();\n\n_mithril2.default.mount(document.body, Body);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi9hcHAuY3NzJztcbmltcG9ydCAnLi4vTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzcyc7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQge1xuICAgIG1haW4sXG4gICAgdGFiTGVmdFxufSBmcm9tICcuL2FwcF9kZGkuanMnO1xuXG5mdW5jdGlvbiBsZWZ0cGFuZWwoKSB7XG4gICAgcmV0dXJuIG0oJyNsZWZ0cGFuZWwuc2lkZXBhbmVsLmNvbnRhaW5lci5jbGVhcmZpeCcsIFtcbiAgICAgICAgbSgnI3RvZ2dsZUxwYW5lbGljb24ucGFuZWxiYXInLFxuICAgICAgICAgICAgbShcInNwYW5cIiwgW1xuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpLFxuICAgICAgICAgICAgICAgIG0oXCJiclwiKSxcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKSxcbiAgICAgICAgICAgICAgICBtKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIiksXG4gICAgICAgICAgICAgICAgbShcImJyXCIpLFxuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpXG4gICAgICAgICAgICBdKVxuICAgICAgICApLFxuICAgICAgICBtKCcjbGVmdHBhbmVsdGl0bGUucGFuZWwtaGVhZGluZy50ZXh0LWNlbnRlcicsXG4gICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIiwgXCJEYXRhIFNlbGVjdGlvblwiKVxuICAgICAgICApLFxuICAgICAgICBtKFwiLmJ0bi10b29sYmFyW3JvbGU9J3Rvb2xiYXInXVwiLCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogXCIuNWVtXCIsXG4gICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwiLjVlbVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIG0oXCIuYnRuLWdyb3VwXCIsIHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiMFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuVmFyaWFibGVzLmJ0bi5hY3RpdmVbdHlwZT0nYnV0dG9uJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NsaWNrIHZhcmlhYmxlIG5hbWUgdG8gYWRkIG9yIHJlbW92ZSB0aGUgdmFyaWFibGUgcGViYmxlIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlLicsXG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IHYgPT4gdGFiTGVmdCgndGFiMScpXG4gICAgICAgICAgICAgICAgfSwgXCJWYXJpYWJsZXNcIiksXG4gICAgICAgICAgICAgICAgbShcImJ1dHRvbiNidG5TdWJzZXQuYnRuLmJ0bi1kZWZhdWx0W3R5cGU9J2J1dHRvbiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb25jbGljazogdiA9PiB0YWJMZWZ0KCd0YWIyJylcbiAgICAgICAgICAgICAgICB9LCBcIlN1YnNldFwiKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBtKFwiYnV0dG9uI2J0blNlbGVjdC5idG4uYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0nIzAwMDAwMCddW2RhdGEtc3R5bGU9J3pvb20taW4nXVtvbmNsaWNrPSdzdWJzZXRTZWxlY3QoXFwnYnRuU2VsZWN0XFwnKTsnXVt0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdTdWJzZXQgZGF0YSBieSB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCBzZWxlY3RlZCB2YWx1ZXMuJyxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZmxvYXRcIjogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIjEwcHhcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG0oXCJzcGFuLmxhZGRhLWxhYmVsXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJTZWxlY3RcIikpXG4gICAgICAgIF0pLFxuICAgICAgICBtKFwiLnJvdy1mbHVpZFwiLFxuICAgICAgICAgICAgbSgnI2xlZnRwYW5lbGNvbnRlbnQnLFxuICAgICAgICAgICAgICAgIG0oJyNsZWZ0Q29udGVudEFyZWEnLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJmbG93XCI6IFwic2Nyb2xsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjQ4OHB4XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbSgnI3RhYjEnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImJsb2NrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nXCI6IFwiNnB4IDEycHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbSgnI3RhYjInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIuNWVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG0oJyN0YWIzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJwXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmdcIjogXCIuNWVtIDFlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgXCJTZWxlY3QgYSB2YXJpYWJsZSBmcm9tIHdpdGhpbiB0aGUgdmlzdWFsaXphdGlvbiBpbiB0aGUgY2VudGVyIHBhbmVsIHRvIHZpZXcgaXRzIHN1bW1hcnkgc3RhdGlzdGljcy5cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gcmlnaHRwYW5lbCgpIHtcbiAgICByZXR1cm4gbShcIi5zaWRlcGFuZWwuY29udGFpbmVyLmNsZWFyZml4W2lkPSdyaWdodHBhbmVsJ11cIiwgW1xuICAgICAgICBtKFwiLnBhbmVsYmFyW2lkPSd0b2dnbGVScGFuZWxpY29uJ11cIixcbiAgICAgICAgICAgIG0oXCJzcGFuXCIsIFtcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKSxcbiAgICAgICAgICAgICAgICBtKFwiYnJcIiksXG4gICAgICAgICAgICAgICAgbS50cnVzdChcIiYjOTY3OTtcIiksXG4gICAgICAgICAgICAgICAgbShcImJyXCIpLFxuICAgICAgICAgICAgICAgIG0udHJ1c3QoXCImIzk2Nzk7XCIpLFxuICAgICAgICAgICAgICAgIG0oXCJiclwiKSxcbiAgICAgICAgICAgICAgICBtLnRydXN0KFwiJiM5Njc5O1wiKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgKSxcbiAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nLnRleHQtY2VudGVyW2lkPSdyaWdodHBhbmVsdGl0bGUnXVwiLFxuICAgICAgICAgICAgbShcImgzLnBhbmVsLXRpdGxlXCIsXG4gICAgICAgICAgICAgICAgXCJNb2RlbCBTZWxlY3Rpb25cIlxuICAgICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICBtKFwiLmJ0bi1ncm91cC5idG4tZ3JvdXAtanVzdGlmaWVkW2FyaWEtbGFiZWw9Jy4uLiddW3JvbGU9J2dyb3VwJ11cIiwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIuNWVtXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYWN0aXZlW2lkPSdidG5Nb2RlbHMnXVtvbmNsaWNrPSd0YWJSaWdodChcXCdidG5Nb2RlbHNcXCcpOyddW3R5cGU9J2J1dHRvbiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIzMyVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIk1vZGVsc1wiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHRbaWQ9J2J0blNldHgnXVtvbmNsaWNrPSd0YWJSaWdodChcXCdidG5TZXR4XFwnKTsnXVt0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMzQlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJTZXQgQ292YXIuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdFtpZD0nYnRuUmVzdWx0cyddW29uY2xpY2s9J3RhYlJpZ2h0KFxcJ2J0blJlc3VsdHNcXCcpOyddW3R5cGU9J2J1dHRvbiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIzMyVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIlJlc3VsdHNcIlxuICAgICAgICAgICAgKVxuICAgICAgICBdKSxcbiAgICAgICAgbShcIi5yb3ctZmx1aWRcIixcbiAgICAgICAgICAgIG0oXCJbaWQ9J3JpZ2h0cGFuZWxjb250ZW50J11cIixcbiAgICAgICAgICAgICAgICBtKFwiW2lkPSdyaWdodENvbnRlbnRBcmVhJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyZmxvd1wiOiBcInNjcm9sbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCI0ODhweFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgICAgIG0oXCJbaWQ9J3Jlc3VsdHMnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcFwiOiBcIi41ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiLmNvbnRhaW5lcltpZD0ncmVzdWx0c1ZpZXcnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjgwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxvYXRcIjogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJmbG93XCI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJbaWQ9J21vZGVsVmlldyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbG9hdFwiOiBcImxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcInBbaWQ9J3Jlc3VsdHNIb2xkZXInXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nXCI6IFwiLjVlbSAxZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBtKFwiW2lkPSdzZXR4J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIG0oXCJbaWQ9J21vZGVscyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmdcIjogXCI2cHggMTJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dC1hbGlnblwiOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgIF0pO1xufVxuXG5sZXQgZmlsZWlkID0gXCJcIjtcbmxldCBob3N0bmFtZSA9IFwiXCI7XG5sZXQgYXBpa2V5ID0gXCJcIjtcbmxldCBkZGl1cmwgPSBcIlwiO1xubGV0IGRhdGF1cmwgPSBcIlwiO1xuXG5jbGFzcyBCb2R5IHtcbiAgICBvbmNyZWF0ZSgpIHtcbiAgICAgICAgJCgnI2xlZnRwYW5lbCBzcGFuJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoISQoJyNsZWZ0cGFuZWwnKS5oYXNDbGFzcygnZm9yY2VjbG9zZXBhbmVsJykpIHtcbiAgICAgICAgICAgICAgICAkKCcjbGVmdHBhbmVsJykucmVtb3ZlQ2xhc3MoJ2V4cGFuZHBhbmVsJyk7XG4gICAgICAgICAgICAgICAgJCgnI2xlZnRwYW5lbCA+IGRpdi5yb3ctZmx1aWQnKS50b2dnbGVDbGFzcygnY2xvc2VwYW5lbCcpO1xuICAgICAgICAgICAgICAgICQoJyNsZWZ0cGFuZWwnKS50b2dnbGVDbGFzcygnY2xvc2VwYW5lbCcpO1xuICAgICAgICAgICAgICAgICQoJyNtYWluJykudG9nZ2xlQ2xhc3MoJ3N2Zy1sZWZ0cGFuZWwnKTtcbiAgICAgICAgICAgICAgICAkKCcjYnRuU2VsZWN0JykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICQoJyNyaWdodHBhbmVsIHNwYW4nKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghJCgnI2xlZnRwYW5lbCcpLmhhc0NsYXNzKCdmb3JjZWNsb3NlcGFuZWwnKSkge1xuICAgICAgICAgICAgICAgICQoJyNyaWdodHBhbmVsJykucmVtb3ZlQ2xhc3MoJ2V4cGFuZHBhbmVsJyk7XG4gICAgICAgICAgICAgICAgJCgnI3JpZ2h0cGFuZWwgPiBkaXYucm93LWZsdWlkJykudG9nZ2xlQ2xhc3MoJ2Nsb3NlcGFuZWwnKTtcbiAgICAgICAgICAgICAgICAkKCcjcmlnaHRwYW5lbCcpLnRvZ2dsZUNsYXNzKCdjbG9zZXBhbmVsJyk7XG4gICAgICAgICAgICAgICAgJCgnI21haW4nKS50b2dnbGVDbGFzcygnc3ZnLXJpZ2h0cGFuZWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IG15dXJsID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjaW5kZXggPSAwO1xuICAgICAgICBpZiAobXl1cmwuaW5kZXhPZihcImRmSWQ9XCIpID4gMCkge1xuICAgICAgICAgICAgZmlsZWlkID0gbXl1cmwuc3Vic3RyaW5nKG15dXJsLmluZGV4T2YoXCJkZklkPVwiKSArIDUpO1xuICAgICAgICAgICAgY2luZGV4ID0gZmlsZWlkLmluZGV4T2YoXCImXCIpO1xuICAgICAgICAgICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWxlaWQgPSBmaWxlaWQuc3Vic3RyaW5nKDAsIGNpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAobXl1cmwuaW5kZXhPZihcImhvc3Q9XCIpID4gMCkge1xuICAgICAgICAgICAgaG9zdG5hbWUgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImhvc3Q9XCIpICsgNSk7XG4gICAgICAgICAgICBjaW5kZXggPSBob3N0bmFtZS5pbmRleE9mKFwiJlwiKTtcbiAgICAgICAgICAgIGlmIChjaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgaG9zdG5hbWUgPSBob3N0bmFtZS5zdWJzdHJpbmcoMCwgY2luZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChteXVybC5pbmRleE9mKFwia2V5PVwiKSA+IDApIHtcbiAgICAgICAgICAgIGFwaWtleSA9IG15dXJsLnN1YnN0cmluZyhteXVybC5pbmRleE9mKFwia2V5PVwiKSArIDQpO1xuICAgICAgICAgICAgY2luZGV4ID0gYXBpa2V5LmluZGV4T2YoXCImXCIpO1xuICAgICAgICAgICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBhcGlrZXkgPSBhcGlrZXkuc3Vic3RyaW5nKDAsIGNpbmRleCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAobXl1cmwuaW5kZXhPZihcImRkaXVybD1cIikgPiAwKSB7XG4gICAgICAgICAgICBkZGl1cmwgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImRkaXVybD1cIikgKyA3KTtcbiAgICAgICAgICAgIGRkaXVybCA9IGRkaXVybC5yZXBsYWNlKC8lMjUvZywgXCIlXCIpO1xuICAgICAgICAgICAgZGRpdXJsID0gZGRpdXJsLnJlcGxhY2UoLyUzQS9nLCBcIjpcIik7XG4gICAgICAgICAgICBkZGl1cmwgPSBkZGl1cmwucmVwbGFjZSgvJTJGL2csIFwiL1wiKTtcbiAgICAgICAgICAgIGNpbmRleCA9IGRkaXVybC5pbmRleE9mKFwiJlwiKTtcbiAgICAgICAgICAgIGlmIChjaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGRpdXJsID0gZGRpdXJsLnN1YnN0cmluZygwLCBjaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG15dXJsLmluZGV4T2YoXCJkYXRhdXJsPVwiKSA+IDApIHtcbiAgICAgICAgICAgIGRhdGF1cmwgPSBteXVybC5zdWJzdHJpbmcobXl1cmwuaW5kZXhPZihcImRhdGF1cmw9XCIpICsgOCk7XG4gICAgICAgICAgICBkYXRhdXJsID0gZGF0YXVybC5yZXBsYWNlKC8lMjUvZywgXCIlXCIpO1xuICAgICAgICAgICAgZGF0YXVybCA9IGRhdGF1cmwucmVwbGFjZSgvJTNBL2csIFwiOlwiKTtcbiAgICAgICAgICAgIGRhdGF1cmwgPSBkYXRhdXJsLnJlcGxhY2UoLyUyRi9nLCBcIi9cIik7XG4gICAgICAgICAgICBjaW5kZXggPSBkYXRhdXJsLmluZGV4T2YoXCImXCIpO1xuICAgICAgICAgICAgaWYgKGNpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhdXJsID0gZGF0YXVybC5zdWJzdHJpbmcoMCwgY2luZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJmaWxlaWQ6IFwiICsgZmlsZWlkKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJob3N0bmFtZTogXCIgKyBob3N0bmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYXBpa2V5OiBcIiArIGFwaWtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZGRpdXJsOiBcIiArIGRkaXVybCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZGF0YXVybDogXCIgKyBkYXRhdXJsKTtcblxuICAgICAgICBtYWluKGZpbGVpZCwgaG9zdG5hbWUsIGRkaXVybCwgZGF0YXVybCk7XG4gICAgfVxuXG4gICAgdmlldygpIHtcbiAgICAgICAgcmV0dXJuIG0oJ21haW4nLFxuICAgICAgICAgICAgbShcIm5hdi5uYXZiYXIubmF2YmFyLWRlZmF1bHRbaWQ9J29wdGlvbiddW3JvbGU9J25hdmlnYXRpb24nXVwiLFxuICAgICAgICAgICAgICAgIG0oXCJkaXZcIiwgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiLm5hdmJhci1oZWFkZXJbaWQ9J25hdmJhcmhlYWRlciddXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJpbWdbYWx0PSdUd29SYXZlbnMnXVtvbm1vdXNlb3V0PSdjbG9zZWFib3V0KCk7J11bb25tb3VzZW92ZXI9J2Fib3V0KCk7J11bc3JjPSdpbWFnZXMvVHdvUmF2ZW5zLnBuZyddW3dpZHRoPScxMDAnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCItMC41ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC5wYW5lbC1kZWZhdWx0W2lkPSdhYm91dCddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCI6IFwiMTQwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIzODBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ6LWluZGV4XCI6IFwiNTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgbShcIi5maWVsZFtpZD0nZGF0YUZpZWxkJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIwLjVlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJoNFtpZD0nZGF0YU5hbWUnXVtvbmNsaWNrPSdjaXRldG9nZ2xlPWNsaWNrY2l0ZShjaXRldG9nZ2xlKTsnXVtvbm1vdXNlb3V0PSdjbG9zZWNpdGUoY2l0ZXRvZ2dsZSk7J11bb25tb3VzZW92ZXI9J29wZW5jaXRlKCk7J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiaW5saW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEYXRhc2V0IE5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwucGFuZWwtZGVmYXVsdFtpZD0nY2l0ZSddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyaWdodFwiOiBcIjUwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjM4MHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInotaW5kZXhcIjogXCI1MFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwibGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtYm9keVwiLCApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uLm5hdmJhci1yaWdodFtkYXRhLXNwaW5uZXItY29sb3I9JyMwMDAwMDAnXVtkYXRhLXN0eWxlPSd6b29tLWluJ11baWQ9J2J0bkVzdGltYXRlJ11bb25jbGljaz0nZXN0aW1hdGUoXFwnYnRuRXN0aW1hdGVcXCcpJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tcmlnaHRcIjogXCIxZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5sYWRkYS1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVzdGltYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQubmF2YmFyLXJpZ2h0W2lkPSdidG5SZXNldCddW29uY2xpY2s9J3Jlc2V0KCknXVt0aXRsZT0nUmVzZXQnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiMi4wZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLXJlcGVhdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjFlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcIiM4MTgxODFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi50cmFuc2Zvcm1Ub29sW2lkPSd0cmFuc2Zvcm1hdGlvbnMnXVt0aXRsZT0nQ29uc3RydWN0IHRyYW5zZm9ybWF0aW9ucyBvZiBleGlzdGluZyB2YXJpYWJsZXMgdXNpbmcgdmFsaWQgUiBzeW50YXguIEZvciBleGFtcGxlLCBhc3N1bWluZyBhIHZhcmlhYmxlIG5hbWVkIGQsIHlvdSBjb3VsZCBlbnRlciBcXCdsb2coZClcXCcgb3IgXFwnZF4yXFwnLiddXCIsIClcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG0oXCIubGVmdC5zdmctbGVmdHBhbmVsLnN2Zy1yaWdodHBhbmVsLmNhcm91c2VsLnNsaWRlW2lkPSdtYWluJ11cIiwgW1xuICAgICAgICAgICAgICAgIG0oXCIuY2Fyb3VzZWwtaW5uZXJcIiwgKSxcbiAgICAgICAgICAgICAgICBtKFwiLnNwYWNlVG9vbFtpZD0nc3BhY2V0b29scyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiei1pbmRleFwiOiBcIjE2XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHRbaWQ9J2J0bkZvcmNlJ11bb25jbGljaz0nZm9yY2VTd2l0Y2goKSddW3RpdGxlPSdQaW4gdGhlIHZhcmlhYmxlIHBlYmJsZXMgdG8gdGhlIHBhZ2UuJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tcHVzaHBpblwiKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdFtpZD0nYnRuRXJhc2VyJ11bb25jbGljaz0nZXJhc2UoKSddW3RpdGxlPSdXaXBlIGFsbCB2YXJpYWJsZXMgZnJvbSB0aGUgbW9kZWxpbmcgc3BhY2UuJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tbWFnbmV0XCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBtKFwiLmxlZ2VuZGFyeS5wYW5lbC5wYW5lbC1kZWZhdWx0W2lkPSdsZWdlbmQnXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTGVnZW5kICBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLWxhcmdlLmdseXBoaWNvbi1jaGV2cm9uLWRvd24ucHVsbC1yaWdodFtkYXRhLXRhcmdldD0nI2NvbGxhcHNlTGVnZW5kJ11bZGF0YS10b2dnbGU9J2NvbGxhcHNlJ11baHJlZj0nI2NvbGxhcHNlTGVnZW5kJ11bb25jbGljaz0nJCh0aGlzKS50b2dnbGVDbGFzcyhcXCdnbHlwaGljb24tY2hldnJvbi11cFxcJykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tZG93blxcJyk7J11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJzb3JcIjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImN1cnNvclwiOiBcImhhbmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtY29sbGFwc2UuY29sbGFwc2UuaW5baWQ9J2NvbGxhcHNlTGVnZW5kJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtYm9keVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5jbGVhcmZpeC5oaWRlW2lkPSd0aW1lQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGltZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLmNsZWFyZml4LmhpZGVbaWQ9J2NzQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ3Jvc3MgU2VjXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY2xlYXJmaXguaGlkZVtpZD0nZHZCdXR0b24nXVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdENvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3ZnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIyMHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjIwcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiY2lyY2xlW2N4PScxMCddW2N5PScxMCddW2ZpbGw9J3doaXRlJ11bcj0nOSddW3N0cm9rZT0nYmxhY2snXVtzdHJva2Utd2lkdGg9JzInXVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RMYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJEZXAgVmFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY2xlYXJmaXguaGlkZVtpZD0nbm9tQnV0dG9uJ11cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcInN2Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIyMHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImNpcmNsZVtjeD0nMTAnXVtjeT0nMTAnXVtmaWxsPSd3aGl0ZSddW3I9JzknXVtzdHJva2U9J2JsYWNrJ11bc3Ryb2tlLXdpZHRoPScyJ11cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0TGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTm9tIFZhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIG0oXCIubG9nYm94LnBhbmVsLnBhbmVsLWRlZmF1bHRbaWQ9J2xvZ2RpdiddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWhlYWRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJoMy5wYW5lbC10aXRsZVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJIaXN0b3J5IFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tbGFyZ2UuZ2x5cGhpY29uLWNoZXZyb24tZG93bi5wdWxsLXJpZ2h0W2RhdGEtdGFyZ2V0PScjY29sbGFwc2VMb2cnXVtkYXRhLXRvZ2dsZT0nY29sbGFwc2UnXVtocmVmPScjY29sbGFwc2VMb2cnXVtpZD0nbG9naWNvbiddW29uY2xpY2s9JyQodGhpcykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tZG93blxcJykudG9nZ2xlQ2xhc3MoXFwnZ2x5cGhpY29uLWNoZXZyb24tdXBcXCcpOyddXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY3Vyc29yXCI6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdXJzb3JcIjogXCJoYW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWNvbGxhcHNlLmNvbGxhcHNlLmluW2lkPSdjb2xsYXBzZUxvZyddXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgbShcIltpZD0ndGlja2VyJ11cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiZml4ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjUwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZFwiOiBcIiNGOUY5RjlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJvdHRvbVwiOiBcIjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtKFwiYVtocmVmPSdzb21lbGluayddW2lkPSdsb2dJRCddW3RhcmdldD0nX2JsYW5rJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUmVwbGljYXRpb25cIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsZWZ0cGFuZWwoKSxcbiAgICAgICAgICAgICAgICByaWdodHBhbmVsKClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5tLm1vdW50KGRvY3VtZW50LmJvZHksIEJvZHkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7Ozs7Ozs7QUFJQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFPQTtBQUNBO0FBREE7QUFEQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFLQTtBQUFBO0FBQUE7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUZBO0FBUUE7QUFDQTtBQURBO0FBREE7QUFVQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBUUE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQURBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFrQkE7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBREE7QUFEQTtBQVFBO0FBQ0E7QUFEQTtBQURBO0FBUUE7QUFDQTtBQURBO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFEQTtBQVNBO0FBQ0E7QUFEQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQURBO0FBREE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBV0E7QUFDQTtBQURBO0FBREE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBREE7QUFlQTtBQUNBO0FBREE7QUFEQTtBQWFBO0FBQ0E7QUFEQTtBQURBO0FBU0E7QUFDQTtBQURBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBZ0JBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFnQkE7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQWdCQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBaUJBO0FBQ0E7QUFEQTtBQURBO0FBU0E7QUFDQTtBQURBO0FBREE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQURBO0FBaUJBOzs7Ozs7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/* no static exports found */
/* all exports used */
/*!**********************!*\
  !*** ./src/plots.js ***!
  \**********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.density = density;\nexports.bars = bars;\nexports.barsSubset = barsSubset;\nexports.densityNode = densityNode;\nexports.barsNode = barsNode;\nvar d3Color = '#1f77b4'; // d3's default blue\n\n// function to use d3 to graph density plots with preprocessed data\nfunction density(node, div, priv) {\n    var mydiv;\n    if (div == \"subset\") {\n        mydiv = \"#tab2\";\n    } else if (div == \"setx\") {\n        mydiv = \"#setx\";\n    } else if (div == \"varSummary\") {\n        mydiv = \"#tab3\";\n    } else {\n        return alert(\"Error: incorrect div selected for plots\");\n    }\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n\n    // an array of objects\n    var data2 = [];\n    for (var i = 0; i < node.plotx.length; i++) {\n        data2.push({\n            x: node.plotx[i],\n            y: node.ploty[i]\n        });\n    }\n    var add = function add(d) {\n        d.x = +d.x;\n        d.y = +d.y;\n    };\n    data2.forEach(add);\n    if (priv) {\n        if (node.plotCI) {\n            // stores values for upper/lower bound\n            var store = function store(bound) {\n                var error = [];\n                for (var _i = 0; _i < node.plotx.length; _i++) {\n                    error.push({\n                        x: node.plotx[_i],\n                        y: node.plotCI[bound][_i]\n                    });\n                }\n                return error.map(add);\n            };\n            var _upperError = store('upperBound');\n            var _lowerError = store('lowerBound');\n            console.log('upperError');\n            console.log(_upperError);\n        }\n    }\n\n    var tempWidth = d3.select(mydiv).style(\"width\");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(mydiv).style(\"height\");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 30\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (mydiv == \"#tab3\") {\n        width = 0.7 * (width - margin.left - margin.right), height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (mydiv == \"#tab2\" | mydiv == \"#setx\") {\n        width = 200;\n        height = 120;\n    } else {\n        width = 0.35 * (width - margin.left - margin.right), height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n    var invx = d3.scale.linear().range([d3.min(xVals), d3.max(xVals)]).domain([0, width]);\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).ticks(5).orient(\"bottom\");\n    var yAxis = d3.svg.axis().scale(y).orient(\"left\");\n    var brush = d3.svg.brush().x(x).extent(node.subsetrange).on(\"brush\", brushed);\n    var brush2 = d3.svg.brush().x(x).on(\"brush\", brushed2);\n    var area = d3.svg.area().interpolate(\"monotone\").x(function (d) {\n        return x(d.x);\n    }).y0(height);\n    var line = d3.svg.line().x(function (d) {\n        return x(d.x);\n    }).y(function (d) {\n        return y(d.y);\n    }).interpolate(\"monotone\");\n\n    // cumbersome to treat \"tab3\" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == \"#tab3\") {\n        var plotsvg = d3.select(mydiv).selectAll(\"svg\").remove();\n        var plotsvg = d3.select(mydiv).append(\"svg\").attr(\"id\", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style(\"width\", 300 // set height to the height of #main.left\n        ).style(\"height\", 200).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    } else {\n        var plotsvg = d3.select(mydiv).append(\"svg\").attr(\"id\", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, \"\");\n            return myname.concat(\"_\", mydiv.substr(1), \"_\", node.id);\n        }).style(\"width\", width + margin.left + margin.right //setting height to the height of #main.left\n        ).style(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    };\n    plotsvg.append(\"path\").datum(data2).attr(\"class\", \"area\").attr(\"d\", area);\n\n    if (priv && node.plotCI) {\n        //add upper bound\n        plotsvg.append(\"path\").attr(\"class\", \"upperError\").datum(upperError).attr(\"d\", area);\n    }\n\n    if (priv && node.plotCI) {\n        //add lower bound\n        plotsvg.append(\"path\").attr(\"class\", \"lowerError\").datum(lowerError).attr(\"d\", area);\n    }\n\n    plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis);\n\n    plotsvg.append(\"text\").attr(\"x\", width / 2).attr(\"y\", 0 - margin.top / 2).attr(\"text-anchor\", \"middle\").style(\"font-size\", \"12px\").text(node.name);\n\n    // add brush if subset\n    if (mydiv == \"#tab2\") {\n        plotsvg.append(\"text\").attr(\"id\", \"range\").attr(\"x\", 25).attr(\"y\", height + 40).text(function () {\n            return \"Range: \".concat(d3.min(xVals).toPrecision(4), \" to \", d3.max(xVals).toPrecision(4));\n        });\n\n        plotsvg.append(\"g\").attr(\"class\", \"x brush\").call(brush).selectAll(\"rect\").attr(\"height\", height);\n    }\n\n    // add z lines and sliders setx\n    if (mydiv == \"#setx\") {\n        plotsvg.append(\"text\").attr(\"id\", \"range\").attr(\"x\", 25).attr(\"y\", height + 40).text(function () {\n            return \"x: \".concat((+node.mean).toPrecision(4));\n        });\n\n        plotsvg.append(\"text\").attr(\"id\", \"range2\").attr(\"x\", 25).attr(\"y\", height + 50).text(function () {\n            return \"x1: \".concat((+node.mean).toPrecision(4));\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate(\"linear\");\n\n        var colSeq = [\"#A2CD5A\", \"orange\", \"red\"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (d3.min(xVals) - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (d3.max(xVals) - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                \"x\": x(+node.mean + i * node.sd),\n                \"y\": height * .7\n            }, {\n                \"x\": x(+node.mean + i * node.sd),\n                \"y\": height * .9\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", colSeq[d3.min([i, colSeq.length - 1])]).attr(\"stroke-width\", 1.5).attr(\"fill\", \"none\");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                \"x\": x(+node.mean - i * node.sd),\n                \"y\": height * .7\n            }, {\n                \"x\": x(+node.mean - i * node.sd),\n                \"y\": height * .9\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", colSeq[d3.min([i, colSeq.length - 1])]).attr(\"stroke-width\", 1.5).attr(\"fill\", \"none\");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height * .8 + \")\").call(d3.svg.axis().scale(x).ticks(0).orient(\"bottom\"));\n        var slider = plotsvg.append(\"g\").attr(\"class\", \"slider\").call(brush);\n        var handle = slider.append(\"polygon\").attr(\"class\", \"handle\").attr(\"transform\", \"translate(0,\" + height * .7 + \")\").attr(\"points\", function (d) {\n            var s = 6;\n            var xnm = node.setxvals[0] == '' ? x(node.mean) : x(node.setxvals[0]);\n            return xnm - s + \",\" + -s + \" \" + (xnm + s) + \",\" + -s + \" \" + xnm + \",\" + s * 1.3;\n        });\n        var slider2 = plotsvg.append(\"g\").attr(\"class\", \"slider\").call(brush2);\n        var handle2 = slider2.append(\"polygon\").attr(\"class\", \"handle\").attr(\"transform\", \"translate(0,\" + height * .9 + \")\").attr(\"points\", function (d) {\n            var s = 6;\n            var xnm = node.setxvals[1] == '' ? x(node.mean) : x(node.setxvals[1]);\n            return xnm - s + \",\" + s + \" \" + (xnm + s) + \",\" + s + \" \" + xnm + \",\" + -s * 1.3;\n        });\n    }\n\n    // brushing functions\n    function brushed() {\n        if (mydiv == \"#tab2\") {\n            plotsvg.select(\"text#range\").text(function () {\n                return brush.empty() ? \"Range: \".concat(d3.min(xVals).toPrecision(4), \" to \", d3.max(xVals).toPrecision(4)) : \"Range: \".concat(brush.extent()[0].toPrecision(4), \" to \", brush.extent()[1].toPrecision(4));\n            });\n            node.subsetrange = brush.extent()[0].toPrecision(4) != brush.extent()[1].toPrecision(4) ? [brush.extent()[0].toPrecision(4), brush.extent()[1].toPrecision(4)] : [\"\", \"\"];\n        } else if (mydiv == \"#setx\") {\n            var value = brush.extent()[0];\n            var s = 6;\n            if (d3.event.sourceEvent) {\n                value = x.invert(d3.mouse(this)[0]);\n                brush.extent([value, value]);\n            }\n\n            // set x position of slider center                     \n            var xpos = x(value);\n            if (value > d3.max(xVals)) {\n                // dragged past max\n                xpos = x(d3.max(xVals));\n            } else if (value < d3.min(xVals)) {\n                // dragged past min\n                xpos = x(d3.min(xVals));\n            } else {\n                var m = +node.mean;\n                var sd = +node.sd;\n                var zScore = (value - m) / sd; // z-score\n                var zRound = Math.round(zScore); // nearest integer z-score\n                if (.1 > Math.abs(zRound - zScore)) {\n                    // snap to integer z-score\n                    xpos = x(m + zRound * sd);\n                }\n            }\n\n            // create slider symbol and text\n            handle.attr(\"points\", function (d) {\n                return xpos - s + \",\" + -s + \" \" + (xpos + s) + \",\" + -s + \" \" + xpos + \",\" + s * 1.3;\n            });\n            plotsvg.select(\"text#range\").text(function () {\n                return \"x: \".concat(invx(xpos).toPrecision(4));\n            });\n            node.setxvals[1] = invx(xpos).toPrecision(4);\n        }\n    }\n\n    // certainly a more clever way to do this, but for now it's basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center \n        var xpos = x(value);\n        if (value > d3.max(xVals)) {\n            // dragged past max\n            xpos = x(d3.max(xVals));\n        } else if (value < d3.min(xVals)) {\n            // dragged past min\n            xpos = x(d3.min(xVals));\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr(\"points\", function (d) {\n            return xpos - s + \",\" + s + \" \" + (xpos + s) + \",\" + s + \" \" + xpos + \",\" + -s * 1.3;\n        });\n        plotsvg.select(\"text#range2\").text(function () {\n            return \"x1: \".concat(invx(xpos).toPrecision(4));\n        });\n        node.setxvals[1] = invx(xpos).toPrecision(4);\n    }\n}\n\nfunction bars(node, div, priv) {\n    // Histogram spacing\n    var barPadding = .015; // Space between bars \n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var ciUpperVals = new Array();\n    var ciLowerVals = new Array();\n    var ciSize;\n\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === \"nominal\") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) {\n                continue;\n            }\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[xi] = node.plotValuesCI.lowerBound[keys[i]];\n                    ciUpperVals[xi] = node.plotValuesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n            };\n\n            yValKey.push({\n                y: yVals[xi],\n                x: keys[i]\n            });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n        ciUpperVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n        ciLowerVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            console.log(\"plotvalues in bars\");\n            console.log(node);\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[i] = node.plotvaluesCI.lowerBound[keys[i]];\n                    ciUpperVals[i] = node.plotvaluesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[i] - ciLowerVals[i];\n            }\n        }\n    }\n\n    if (yVals.length > 15 & node.numchar === \"numeric\" | yVals.length > 5 & node.numchar === \"character\") {\n        plotXaxis = false;\n    }\n    var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n    if (priv) {\n        if (node.plotvaluesCI) {\n            var maxCI = d3.max(ciUpperVals);\n            maxY = maxCI;\n        };\n    };\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var mydiv;\n    if (div == \"setx\") {\n        mydiv = \"#setx\";\n    } else if (div == \"varSummary\") {\n        mydiv = \"#tab3\";\n    } else {\n        return alert(\"Error: incorrect div selected for plots\");\n    }\n\n    var tempWidth = d3.select(mydiv).style(\"width\");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n\n    var tempHeight = d3.select(mydiv).style(\"height\");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (mydiv == \"#tab3\") {\n        width = 0.7 * (width - margin.left - margin.right);\n        height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (mydiv == \"#setx\") {\n        width = 200;\n        height = 120;\n    } else {\n        width = 0.35 * (width - margin.left - margin.right);\n        height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    if (priv && node.stabilityBin) {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 1.5]).range([0, width]);\n    } else {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n    }\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient(\"bottom\");\n\n    var yAxis = d3.svg.axis().scale(y).orient(\"left\");\n\n    var brush = d3.svg.brush().x(x).extent(function () {\n        return node.subsetrange.length == 1 ? [node.subsetrange[0], node.subsetrange[0]] : node.subsetrange;\n    }).on(\"brush\", brushed);\n\n    var brush2 = d3.svg.brush().x(x).on(\"brush\", brushed2);\n\n    // Create SVG element\n    // cumbersome to treat \"tab3\" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == \"#tab3\") {\n        var plotsvg = d3.select(mydiv).selectAll(\"svg\").remove();\n\n        var plotsvg = d3.select(mydiv).append(\"svg\").attr(\"id\", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style(\"width\", 300 //setting height to the height of #main.left\n        ).style(\"height\", 200).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    } else {\n        var plotsvg = d3.select(mydiv).append(\"svg\").attr(\"id\", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, \"\");\n            return myname.concat(\"_\", mydiv.substr(1), \"_\", node.id);\n        }).style(\"width\", width + margin.left + margin.right //setting height to the height of #main.left\n        ).style(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n    };\n\n    var rectWidth = x(minX + 0.5 - 2 * barPadding); //the \"width\" is the coordinate of the end of the first bar\n\n    plotsvg.selectAll(\"rect\").data(yVals).enter().append(\"rect\").attr(\"x\", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr(\"y\", function (d) {\n        return y(maxY - d);\n    }).attr(\"width\", rectWidth).attr(\"height\", y).attr(\"fill\", \"#1f77b4\");\n\n    // draw error bars, threshold line and extra bin\n    if (priv) {\n        if (yVals.length <= 20) {\n            plotsvg.selectAll(\"line\").data(ciUpperVals).enter().append(\"line\").style(\"stroke\", \"black\").attr(\"x1\", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr(\"y1\", function (d) {\n                return y(maxY - d);\n            }).attr(\"x2\", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr(\"y2\", function (d) {\n                y2 = y(maxY - d + ciSize);\n                return y2 >= y(maxY) ? y(maxY) : y2;\n            });\n\n            //draw top ticks on error bars\n            //need to fix the height of the graphs - the tops of error bars are getting cut off\n            plotsvg.selectAll(\".topTick\").data(ciUpperVals).enter().append(\"line\").attr(\"class\", \"topTick\").style(\"stroke\", \"black\").attr(\"x1\", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding //make tick bigger to increase visibility\n                    );\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr(\"y1\", function (d) {\n                return y(maxY - d);\n            }).attr(\"x2\", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth; //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr(\"y2\", function (d) {\n                return y(maxY - d);\n            });\n\n            // draw bottom ticks of error bars\n            plotsvg.selectAll(\".bottomTick\").data(ciLowerVals).enter().append(\"line\").attr(\"class\", \"bottomTick\").style(\"stroke\", \"black\").attr(\"x1\", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding);\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr(\"y1\", function (d) {\n                return y(maxY - d);\n            }).attr(\"x2\", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth;\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr(\"y2\", function (d) {\n                return y(maxY - d);\n            });\n        } else {\n            plotsvg.selectAll(\".denseError\").data(yVals).enter().append(\"rect\").attr(\"class\", \"denseError\").attr(\"x\", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding);\n            }).attr(\"y\", function (d) {\n                return y(maxY - d) - .1 * y(d);\n            }).attr(\"width\", rectWidth).attr(\"height\", function (d) {\n                return y(maxY - d) + .1 * y(d) - (y(maxY - d) - .1 * y(d));\n            }).attr(\"fill\", \"silver\");\n        }\n\n        //if statement for stability histograms\n        //extra stability bin\n        if (node.stabilityBin) {\n            plotsvg.append(\"rect\").attr(\"x\", x(maxX + 0.5 - barPadding)).attr(\"y\", y(maxY) - node.stabilityBin).attr(\"width\", rectWidth).attr(\"height\", node.stabilityBin).attr(\"fill\", \"silver\");\n        }\n\n        //threshold line\n        if (node.threshold) {\n            plotsvg.append(\"line\").style(\"stroke\", \"black\").attr(\"x1\", x(minX - 0.5 + barPadding)).attr(\"y1\", y(maxY) - node.threshold).attr(\"x2\", function () {\n                console.log(\"stabilityBin\");\n                console.log(node.stabilityBin);\n                if (node.stabilityBin) {\n                    return x(maxX + 0.5 - barPadding) + rectWidth;\n                } else {\n                    return x(maxX + 0.5 - barPadding);\n                }\n            }).attr(\"y2\", y(maxY) - node.threshold);\n        }\n    }\n\n    if (plotXaxis) {\n        plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis);\n    }\n\n    plotsvg.append(\"text\").attr(\"x\", width / 2).attr(\"y\", 0 - margin.top / 2).attr(\"text-anchor\", \"middle\").style(\"font-size\", \"12px\").text(node.name);\n\n    if (mydiv == \"#setx\") {\n        plotsvg.append(\"text\").attr(\"id\", \"range\").attr(\"x\", 25).attr(\"y\", height + 40).text(function () {\n            if (node.nature === \"nominal\") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return \"x: \" + yValKey[t].x;\n            } else {\n                return \"x: \".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        plotsvg.append(\"text\").attr(\"id\", \"range2\").attr(\"x\", 25).attr(\"y\", height + 50).text(function () {\n            if (node.nature === \"nominal\") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return \"x1: \" + yValKey[t].x;\n            } else {\n                return \"x1: \".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate(\"linear\");\n\n        var colSeq = [\"#A2CD5A\", \"orange\", \"red\"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (minX - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (maxX - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                \"x\": x(+node.mean + i * node.sd),\n                \"y\": height * .7\n            }, {\n                \"x\": x(+node.mean + i * node.sd),\n                \"y\": height * .9\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", colSeq[d3.min([i, colSeq.length - 1])]).attr(\"stroke-width\", 1.5).attr(\"fill\", \"none\");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                \"x\": x(+node.mean - i * node.sd),\n                \"y\": height * .7\n            }, {\n                \"x\": x(+node.mean - i * node.sd),\n                \"y\": height * .9\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", colSeq[d3.min([i, colSeq.length - 1])]).attr(\"stroke-width\", 1.5).attr(\"fill\", \"none\");\n        }\n\n        for (var i = d3.min(xVals); i <= d3.max(xVals); i++) {\n            lineData = [{\n                \"x\": x(i),\n                \"y\": height * .75\n            }, {\n                \"x\": x(i),\n                \"y\": height * .85\n            }];\n            plotsvg.append(\"path\").attr(\"d\", lineFunction([lineData[0], lineData[1]])).attr(\"stroke\", \"black\").attr(\"stroke-width\", 1).attr(\"fill\", \"none\");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height * .8 + \")\").call(d3.svg.axis().scale(x).ticks(0).orient(\"bottom\"));\n\n        var slider = plotsvg.append(\"g\").attr(\"class\", \"slider\").call(brush);\n\n        var handle = slider.append(\"polygon\").attr(\"class\", \"handle\").attr(\"transform\", \"translate(0,\" + height * .7 + \")\").attr(\"points\", function (d) {\n            var s = 6;\n            if (node.setxvals[0] == \"\") {\n                if (node.nature == \"nominal\") {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    var xnm = x(Math.round(xVals.length / 2) - 1);\n                } else {\n                    var xnm = x(node.mean);\n                }\n            } else {\n                var xnm = x(node.setxvals[0]);\n            };\n            return xnm - s + \",\" + -s + \" \" + (xnm + s) + \",\" + -s + \" \" + xnm + \",\" + s * 1.3;\n        });\n\n        var slider2 = plotsvg.append(\"g\").attr(\"class\", \"slider\").call(brush2);\n\n        var handle2 = slider2.append(\"polygon\").attr(\"class\", \"handle\").attr(\"transform\", \"translate(0,\" + height * .9 + \")\").attr(\"points\", function (d) {\n            var s = 6;\n            if (node.setxvals[1] == \"\") {\n                if (node.nature == \"nominal\") {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    var xnm = x(Math.round(xVals.length / 2) - 1);\n                } else {\n                    var xnm = x(node.mean);\n                }\n            } else {\n                var xnm = x(node.setxvals[1]);\n            };\n            return xnm - s + \",\" + s + \" \" + (xnm + s) + \",\" + s + \" \" + xnm + \",\" + -s * 1.3;\n        });\n    }\n\n    function twoSF(x) {\n        var tsf = d3.format(\".2r\"); // format to two significant figures after the decimal place\n        return tsf(x).replace(/0+$/, \"\").replace(/\\.$/, \"\" // trim trailing zeros after a period, and any orphaned period\n        );\n    }\n\n    // brushing functions\n    function brushed() {\n        var value = brush.extent()[0];\n        var s = 6;\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush.extent([value, value]);\n        }\n\n        // set x position of slider center                     \n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle.attr(\"points\", function (d) {\n            return xpos - s + \",\" + -s + \" \" + (xpos + s) + \",\" + -s + \" \" + xpos + \",\" + s * 1.3;\n        });\n        plotsvg.select(\"text#range\").text(function () {\n            if (node.nature === \"nominal\") {\n                return \"x: \" + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                return \"x: \".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n\n    // certainly a more clever way to do this, but for now it's basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center \n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr(\"points\", function (d) {\n            return xpos - s + \",\" + s + \" \" + (xpos + s) + \",\" + s + \" \" + xpos + \",\" + -s * 1.3;\n        });\n        plotsvg.select(\"text#range2\").text(function () {\n            if (node.nature === \"nominal\") {\n                return \"x1: \" + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                return \"x1: \".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n}\n\n// draws barplots in subset tab\nfunction barsSubset(node) {\n    // if untouched, set node.subsetrange to an empty array, meaning all values selected by default\n    if (node.subsetrange[0] == \"\" & node.subsetrange[1] == \"\") {\n        node.subsetrange = [];\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Variable name\n    var myname = node.name.toString();\n    myname = myname.replace(/\\(|\\)/g, \"\");\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    var xi = 0;\n    for (var i = 0; i < keys.length; i++) {\n        if (node.plotvalues[keys[i]] == 0) continue;\n        yVals[xi] = node.plotvalues[keys[i]];\n        xVals[xi] = xi;\n        yValKey.push({\n            y: yVals[xi],\n            x: keys[i]\n        });\n        xi = xi + 1;\n    }\n    if (node.nature === \"nominal\") {\n        // if nominal, orders bars left to right, highest frequency to lowest\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    }\n\n    plotXaxis = false;\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n    var gname = [\"subsetyes\", \"subsetno\"];\n\n    var yVals2 = [];\n    var yVals1 = [];\n    for (i = 0; i < yVals.length; i++) {\n        yVals1.push({\n            y0: maxY - yVals[i],\n            y1: yVals[i],\n            col: d3Color\n        });\n        yVals2.push({\n            y0: 0,\n            y1: maxY - yVals[i],\n            col: \"transparent\"\n        });\n    }\n    var freqs = [yVals1, yVals2];\n\n    // y0 is the starting point\n    // y1 is the length of the bar\n\n    var mydiv = \"#tab2\";\n    var width = 200;\n    var height = 120;\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient(\"bottom\");\n\n    var yAxis = d3.svg.axis().scale(y).orient(\"left\");\n\n    //Create SVG element\n    var plotsvg = d3.select(mydiv).append(\"svg\").attr(\"id\", function () {\n        return myname.concat(\"_\", mydiv.substr(1), \"_\", node.id);\n    }).style(\"width\", width + margin.left + margin.right //setting height to the height of #main.left\n    ).style(\"height\", height + margin.top + margin.bottom).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    var freq = plotsvg.selectAll(\"g.freq\").data(freqs).enter().append(\"g\").attr(\"class\", \"freq\").attr(\"name\", function (d, i) {\n        return myname.concat(gname[i]);\n    });\n\n    var rect = freq.selectAll(\"rect\").data(Object).enter().append(\"rect\").attr(\"class\", \"bar\").attr(\"name\", function (d, i) {\n        return xVals[i];\n    }).attr(\"x\", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr(\"y\", function (d) {\n        return y(d.y0);\n    }).attr(\"width\", x(minX + 0.5 - 2 * barPadding) // the \"width\" is the coordinate of the end of the first bar\n    ).attr(\"height\", function (d) {\n        return y(d.y1);\n    }).style(\"fill\", function (d, i) {\n        if (node.subsetrange.length > 0 & d.col === d3Color & $.inArray(xVals[i].toString(), node.subsetrange) > -1) {\n            return selVarColor;\n        } else {\n            return d.col;\n        }\n    }).on(\"click\", function () {\n        var selectMe = this;\n        var selectName = this.getAttribute(\"name\");\n        if (this.parentNode.getAttribute(\"name\") == myname.concat(\"subsetno\")) {\n            selectMe = $('[name=\"' + myname.concat(\"subsetyes\") + '\"]').children('[name=\"' + selectName + '\"]')[0];\n        }\n        d3.select(selectMe).style(\"fill\", function (d, i) {\n            var myCol = \"\";\n            if (this.style.fill === selVarColor) {\n                var myindex = node.subsetrange.indexOf(this.getAttribute(\"name\"));\n                node.subsetrange.splice(myindex, 1);\n                myCol = d3Color;\n            } else {\n                node.subsetrange.push(this.getAttribute(\"name\"));\n                myCol = selVarColor;\n            }\n            return myCol;\n        });\n        plotsvg.select(\"text#selectrange\").text(function () {\n            if (node.subsetrange.length == 0) {\n                return \"Selected: all values\";\n            } else {\n                var a = node.subsetrange;\n                var selecteds = new Array();\n                a.forEach(function (val) {\n                    selecteds.push(yValKey[val].x);\n                });\n                return \"Selected: \" + selecteds;\n            }\n        });\n    }).on(\"mouseover\", function () {\n        var i = this.getAttribute(\"name\");\n        plotsvg.select(\"text#mymouseover\").text(function () {\n            return yValKey[i].x + \": \" + yValKey[i].y;\n        });\n    }).on(\"mouseout\", function () {\n        var i = this.getAttribute(\"name\");\n        plotsvg.select(\"text#mymouseover\").text(function () {\n            return \"Value: Frequency\";\n        });\n    });\n\n    if (plotXaxis) {\n        plotsvg.append(\"g\").attr(\"class\", \"x axis\").attr(\"transform\", \"translate(0,\" + height + \")\").call(xAxis);\n    } else {\n        plotsvg.append(\"text\").attr(\"id\", \"mymouseover\").attr(\"x\", 25).attr(\"y\", height + 20).text(function () {\n            return \"Value: Frequency\";\n        });\n    }\n\n    plotsvg.append(\"text\").attr(\"x\", width / 2).attr(\"y\", 0 - margin.top / 2).attr(\"text-anchor\", \"middle\").style(\"font-size\", \"12px\").text(myname);\n\n    plotsvg.append(\"text\").attr(\"id\", \"selectrange\").attr(\"x\", 25).attr(\"y\", height + 40).text(function () {\n        if (node.subsetrange.length == 0) return \"Selected: all values\";\n        var selecteds = new Array();\n        node.subsetrange.forEach(function (val) {\n            return selecteds.push(yValKey[val].x);\n        });\n        return \"Selected: \" + selecteds;\n    });\n}\n\nfunction densityNode(node, obj) {\n    var myname = node.name.toString().concat(\"nodeplot\");\n\n    if (typeof obj === \"undefined\") {\n        var obj = document.getElementById(node.name.toString() + \"biggroup\");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll(\"svg\")[0].length > 0) d3.select(obj).selectAll(\"svg\").remove();\n    }\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n\n    // an array of objects\n    var data2 = [];\n    for (var i = 0; i < node.plotx.length; i++) {\n        data2.push({\n            x: node.plotx[i],\n            y: node.ploty[i]\n        });\n    }\n\n    data2.forEach(function (d) {\n        d.x = +d.x;\n        d.y = +d.y;\n    });\n\n    var width = 60; // hardcoded, should be set automatically\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n\n    var area = d3.svg.area().interpolate(\"monotone\").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n\n    var plotsvg = d3.select(obj).insert(\"svg\", \":first-child\").attr(\"x\", -40 // NOTE: Not sure exactly why these numbers work, but these hardcoded values seem to position the plot inside g correctly.  this shouldn't be hardcoded in the future\n    ).attr(\"y\", -45).attr(\"id\", function () {\n        return myname;\n    }).style(\"width\", width).style(\"height\", height).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    plotsvg.append(\"path\").datum(data2).attr(\"class\", \"area\").attr(\"d\", area);\n}\n\nfunction barsNode(node, obj) {\n    var myname = node.name.toString().concat(\"nodeplot\");\n\n    if (typeof obj === \"undefined\") {\n        var obj = document.getElementById(node.name.toString() + \"biggroup\");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll(\"svg\")[0].length > 0) {\n            d3.select(obj).selectAll(\"svg\").remove();\n        }\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === \"nominal\") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            yValKey.push({ y: yVals[xi], x: keys[i] });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n        }\n    }\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var width = 60;\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    //Create SVG element\n    var plotsvg = d3.select(obj).insert(\"svg\", \":first-child\").attr(\"x\", -40).attr(\"y\", -45).attr(\"id\", function () {\n        return myname;\n    }).style(\"width\", width // set height to the height of #main.left\n    ).style(\"height\", height).append(\"g\").attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\n    plotsvg.selectAll(\"rect\").data(yVals).enter().append(\"rect\").attr(\"x\", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr(\"y\", function (d) {\n        return y(maxY - d);\n    }).attr(\"width\", x(minX + 0.5 - 2 * barPadding) // the \"width\" is the coordinate of the end of the first bar\n    ).attr(\"height\", y).attr(\"fill\", \"#1f77b4\");\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvcGxvdHMuanM/YTYzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZDNDb2xvciA9ICcjMWY3N2I0JzsgLy8gZDMncyBkZWZhdWx0IGJsdWVcblxuLy8gZnVuY3Rpb24gdG8gdXNlIGQzIHRvIGdyYXBoIGRlbnNpdHkgcGxvdHMgd2l0aCBwcmVwcm9jZXNzZWQgZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIGRlbnNpdHkobm9kZSwgZGl2LCBwcml2KSB7XG4gICAgdmFyIG15ZGl2O1xuICAgIGlmIChkaXYgPT0gXCJzdWJzZXRcIikge1xuICAgICAgICBteWRpdiA9IFwiI3RhYjJcIjtcbiAgICB9IGVsc2UgaWYgKGRpdiA9PSBcInNldHhcIikge1xuICAgICAgICBteWRpdiA9IFwiI3NldHhcIjtcbiAgICB9IGVsc2UgaWYgKGRpdiA9PSBcInZhclN1bW1hcnlcIikge1xuICAgICAgICBteWRpdiA9IFwiI3RhYjNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYWxlcnQoXCJFcnJvcjogaW5jb3JyZWN0IGRpdiBzZWxlY3RlZCBmb3IgcGxvdHNcIik7XG4gICAgfVxuXG4gICAgdmFyIHlWYWxzID0gbm9kZS5wbG90eTtcbiAgICB2YXIgeFZhbHMgPSBub2RlLnBsb3R4O1xuXG4gICAgLy8gYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgIHZhciBkYXRhMiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wbG90eC5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhMi5wdXNoKHtcbiAgICAgICAgICAgIHg6IG5vZGUucGxvdHhbaV0sXG4gICAgICAgICAgICB5OiBub2RlLnBsb3R5W2ldXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgYWRkID0gZCA9PiB7XG4gICAgICAgIGQueCA9ICtkLng7XG4gICAgICAgIGQueSA9ICtkLnk7XG4gICAgfTtcbiAgICBkYXRhMi5mb3JFYWNoKGFkZCk7XG4gICAgaWYgKHByaXYpIHtcbiAgICAgICAgaWYgKG5vZGUucGxvdENJKSB7XG4gICAgICAgICAgICAvLyBzdG9yZXMgdmFsdWVzIGZvciB1cHBlci9sb3dlciBib3VuZFxuXHQgICAgbGV0IHN0b3JlID0gYm91bmQgPT4geyBcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucGxvdHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBub2RlLnBsb3R4W2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogbm9kZS5wbG90Q0lbYm91bmRdW2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIHJldHVybiBlcnJvci5tYXAoYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB1cHBlckVycm9yID0gc3RvcmUoJ3VwcGVyQm91bmQnKTtcbiAgICAgICAgICAgIGxldCBsb3dlckVycm9yID0gc3RvcmUoJ2xvd2VyQm91bmQnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1cHBlckVycm9yJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh1cHBlckVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZW1wV2lkdGggPSBkMy5zZWxlY3QobXlkaXYpLnN0eWxlKFwid2lkdGhcIilcbiAgICB2YXIgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsICh0ZW1wV2lkdGgubGVuZ3RoIC0gMikpO1xuICAgIHZhciB0ZW1wSGVpZ2h0ID0gZDMuc2VsZWN0KG15ZGl2KS5zdHlsZShcImhlaWdodFwiKVxuICAgIHZhciBoZWlnaHQgPSB0ZW1wSGVpZ2h0LnN1YnN0cmluZygwLCAodGVtcEhlaWdodC5sZW5ndGggLSAyKSk7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDIwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAzMFxuICAgIH07XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB3aWR0aCA9IDAuNyAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSxcbiAgICAgICAgaGVpZ2h0ID0gMC4zICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKG15ZGl2ID09IFwiI3RhYjJcIiB8IG15ZGl2ID09IFwiI3NldHhcIikge1xuICAgICAgICB3aWR0aCA9IDIwMDtcbiAgICAgICAgaGVpZ2h0ID0gMTIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMC4zNSAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSxcbiAgICAgICAgaGVpZ2h0ID0gMC4yNSAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeVZhbHMpLCBkMy5tYXgoeVZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoNSlcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcbiAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAuZXh0ZW50KG5vZGUuc3Vic2V0cmFuZ2UpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQpO1xuICAgIHZhciBicnVzaDIgPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkMik7XG4gICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueTAoaGVpZ2h0KVxuICAgIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkoZCA9PiB5KGQueSkpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpO1xuXG4gICAgLy8gY3VtYmVyc29tZSB0byB0cmVhdCBcInRhYjNcIiBkaWZmZXJlbnRseSwgYnV0IHdvcmtzIGZvciBub3dcbiAgICAvLyB0YWIzLCBoYXMgYW4gaXNzdWUsIHRoYXQgdW5sZXNzIHdpZHRoIGhlaWdodCBoYXJkY29kZWQsIHRoZXkgZ3JvdyB3aXRoIGVhY2ggYWRkaXRpb25hbCBncmFwaC5cbiAgICBpZiAobXlkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KG15ZGl2LnN1YnN0cigxKSkpIFxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgMzAwKSAvLyBzZXQgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIDIwMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbXluYW1lID0gbXluYW1lLnJlcGxhY2UoL1xcKHxcXCkvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG15bmFtZS5jb25jYXQoXCJfXCIsIG15ZGl2LnN1YnN0cigxKSwgXCJfXCIsIG5vZGUuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcbiAgICB9O1xuICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuZGF0dW0oZGF0YTIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhXCIpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIGlmIChwcml2ICYmIG5vZGUucGxvdENJKSB7XG4gICAgICAgIC8vYWRkIHVwcGVyIGJvdW5kXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInVwcGVyRXJyb3JcIilcbiAgICAgICAgICAgIC5kYXR1bSh1cHBlckVycm9yKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuICAgIH1cblxuICAgIGlmIChwcml2ICYmIG5vZGUucGxvdENJKSB7XG4gICAgICAgIC8vYWRkIGxvd2VyIGJvdW5kXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxvd2VyRXJyb3JcIilcbiAgICAgICAgICAgIC5kYXR1bShsb3dlckVycm9yKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuICAgIH1cblxuICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSAobWFyZ2luLnRvcCAvIDIpKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgLnRleHQobm9kZS5uYW1lKTtcblxuICAgIC8vIGFkZCBicnVzaCBpZiBzdWJzZXRcbiAgICBpZiAobXlkaXYgPT0gXCIjdGFiMlwiKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlXCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgICAgICAudGV4dCgoKSA9PiBcIlJhbmdlOiBcIi5jb25jYXQoZDMubWluKHhWYWxzKS50b1ByZWNpc2lvbig0KSwgXCIgdG8gXCIsIGQzLm1heCh4VmFscykudG9QcmVjaXNpb24oNCkpKTtcblxuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGJydXNoXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaClcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIGFkZCB6IGxpbmVzIGFuZCBzbGlkZXJzIHNldHhcbiAgICBpZiAobXlkaXYgPT0gXCIjc2V0eFwiKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlXCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFwieDogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicmFuZ2UyXCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNTApXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aWNrIG1hcmtzIGF0IGFsbCB6c2NvcmVzIGluIHRoZSBib3VuZHMgb2YgdGhlIGRhdGFcbiAgICAgICAgdmFyIGxpbmVGdW5jdGlvbiA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4gZC54KVxuICAgICAgICAgICAgLnkoZCA9PiBkLnkpIFxuICAgICAgICAgICAgLmludGVycG9sYXRlKFwibGluZWFyXCIpO1xuXG4gICAgICAgIHZhciBjb2xTZXEgPSBbXCIjQTJDRDVBXCIsIFwib3JhbmdlXCIsIFwicmVkXCJdOyAvLyB3aWxsIGN5Y2xlIHRocm91Z2ggY29sb3Igc2VxdWVuY2UsIGFuZCB0aGVuIHJlcGVhdCBsYXN0IGNvbG9yXG4gICAgICAgIHZhciBsaW5lRGF0YSA9IG5ldyBBcnJheTtcblxuICAgICAgICB2YXIgekxvd2VyID0gLTEgKiAoZDMubWluKHhWYWxzKSAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIHpVcHBlciA9IChkMy5tYXgoeFZhbHMpIC0gbm9kZS5tZWFuKSAvIG5vZGUuc2Q7IC8vIHpzY29yZSBvZiB1cHBlciBib3VuZFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgelVwcGVyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gKyBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB6TG93ZXI7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiAtIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjlcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sU2VxW2QzLm1pbihbaSwgY29sU2VxLmxlbmd0aCAtIDFdKV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXplIHNsaWRlciBjb21wb25lbnRzXG4gICAgICAgIHZhciBzbGlkZUJveCA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC44ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgLnRpY2tzKDApXG4gICAgICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKSlcbiAgICAgICAgdmFyIHNsaWRlciA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gpO1xuICAgICAgICB2YXIgaGFuZGxlID0gc2xpZGVyLmFwcGVuZChcInBvbHlnb25cIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuNyArIFwiKVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJwb2ludHNcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSA2O1xuICAgICAgICAgICAgICAgIGxldCB4bm0gPSBub2RlLnNldHh2YWxzWzBdID09ICcnID8geChub2RlLm1lYW4pIDogeChub2RlLnNldHh2YWxzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhubSAtIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyAoeG5tICsgcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArIHhubSArIFwiLFwiICsgKHMgKiAxLjMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHZhciBzbGlkZXIyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaDIpO1xuICAgICAgICB2YXIgaGFuZGxlMiA9IHNsaWRlcjIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC45ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBkID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IDY7XG4gICAgICAgICAgICAgICAgbGV0IHhubSA9IG5vZGUuc2V0eHZhbHNbMV0gPT0gJycgPyB4KG5vZGUubWVhbikgOiB4KG5vZGUuc2V0eHZhbHNbMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoeG5tIC0gcykgKyBcIixcIiArIHMgKyBcIiBcIiArICh4bm0gKyBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgeG5tICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYnJ1c2hpbmcgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gYnJ1c2hlZCgpIHtcbiAgICAgICAgaWYgKG15ZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gYnJ1c2guZW1wdHkoKSA/XG4gICAgICAgICAgICAgICAgICAgIFwiUmFuZ2U6IFwiLmNvbmNhdChkMy5taW4oeFZhbHMpLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgZDMubWF4KHhWYWxzKS50b1ByZWNpc2lvbig0KSkgOlxuICAgICAgICAgICAgICAgICAgICBcIlJhbmdlOiBcIi5jb25jYXQoKGJydXNoLmV4dGVudCgpWzBdKS50b1ByZWNpc2lvbig0KSwgXCIgdG8gXCIsIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBicnVzaC5leHRlbnQoKVswXS50b1ByZWNpc2lvbig0KSAhPSBicnVzaC5leHRlbnQoKVsxXS50b1ByZWNpc2lvbig0KSA/XG4gICAgICAgICAgICAgICAgWyhicnVzaC5leHRlbnQoKVswXSkudG9QcmVjaXNpb24oNCksIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCldIDpcbiAgICAgICAgICAgICAgICBbXCJcIiwgXCJcIl07XG4gICAgICAgIH0gZWxzZSBpZiAobXlkaXYgPT0gXCIjc2V0eFwiKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBicnVzaC5leHRlbnQoKVswXTtcbiAgICAgICAgICAgIHZhciBzID0gNjtcbiAgICAgICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgICAgIGJydXNoLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXIgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBkMy5tYXgoeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtYXhcbiAgICAgICAgICAgICAgICB4cG9zID0geChkMy5tYXgoeFZhbHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBkMy5taW4oeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgICAgICB4cG9zID0geChkMy5taW4oeFZhbHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgICAgIHZhciBzZCA9ICtub2RlLnNkO1xuICAgICAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgICAgIHhwb3MgPSB4KG0gKyAoelJvdW5kICogc2QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgc3ltYm9sIGFuZCB0ZXh0XG4gICAgICAgICAgICBoYW5kbGUuYXR0cihcInBvaW50c1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4cG9zIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4cG9zICsgcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArIHhwb3MgKyBcIixcIiArIChzICogMS4zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJ4OiBcIi5jb25jYXQoKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpKSk7XG4gICAgICAgICAgICBub2RlLnNldHh2YWxzWzFdID0gKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkgeyBcbiAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2gyLmV4dGVudCgpWzBdO1xuICAgICAgICB2YXIgcyA9IDY7IC8vIHNjYWxpbmcgZm9yIHRyaWFuZ2xlIHNoYXBlXG5cbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgIGJydXNoMi5leHRlbnQoW3ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHggcG9zaXRpb24gb2Ygc2xpZGVyIGNlbnRlciBcbiAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gZDMubWF4KHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICB4cG9zID0geChkMy5tYXgoeFZhbHMpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IGQzLm1pbih4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgeHBvcyA9IHgoZDMubWluKHhWYWxzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgeyAvLyBzbmFwIHRvIGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KG0gKyAoelJvdW5kICogc2QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgc3ltYm9sIGFuZCB0ZXh0XG4gICAgICAgIGhhbmRsZTIuYXR0cihcInBvaW50c1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gKHhwb3MgLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKC1zICogMS4zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZTJcIilcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwieDE6IFwiLmNvbmNhdCgoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkpKTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9IChpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzKG5vZGUsIGRpdiwgcHJpdikge1xuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnMgXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG4gICAgdmFyIHBsb3RYYXhpcyA9IHRydWU7XG5cbiAgICAvLyBEYXRhXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnBsb3R2YWx1ZXMpO1xuICAgIHZhciB5VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgY2lVcHBlclZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIGNpTG93ZXJWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciBjaVNpemU7XG5cbiAgICB2YXIgeFZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHlWYWxLZXkgPSBuZXcgQXJyYXk7XG5cbiAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgICAgIGlmIChwcml2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc0NJKSB7XG4gICAgICAgICAgICAgICAgICAgIGNpTG93ZXJWYWxzW3hpXSA9IG5vZGUucGxvdFZhbHVlc0NJLmxvd2VyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW3hpXSA9IG5vZGUucGxvdFZhbHVlc0NJLnVwcGVyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNpU2l6ZSA9IGNpVXBwZXJWYWxzW3hpXSAtIGNpTG93ZXJWYWxzW3hpXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHlWYWxLZXkucHVzaCh7XG4gICAgICAgICAgICAgICAgeTogeVZhbHNbeGldLFxuICAgICAgICAgICAgICAgIHg6IGtleXNbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgeVZhbEtleS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnkgLSBhLnlcbiAgICAgICAgfSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiIC0gYVxuICAgICAgICB9KTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICAgICAgY2lVcHBlclZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi55IC0gYS55XG4gICAgICAgIH0pOyAvLyA/XG4gICAgICAgIGNpTG93ZXJWYWxzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIueSAtIGEueVxuICAgICAgICB9KTsgLy8gP1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwbG90dmFsdWVzIGluIGJhcnNcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhub2RlKTtcbiAgICAgICAgICAgIHlWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbaV0gPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgICAgICBpZiAocHJpdikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc0NJLmxvd2VyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbaV0gLSBjaUxvd2VyVmFsc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoeVZhbHMubGVuZ3RoID4gMTUgJiBub2RlLm51bWNoYXIgPT09IFwibnVtZXJpY1wiKSB8ICh5VmFscy5sZW5ndGggPiA1ICYgbm9kZS5udW1jaGFyID09PSBcImNoYXJhY3RlclwiKSkge1xuICAgICAgICBwbG90WGF4aXMgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1heFkgPSBkMy5tYXgoeVZhbHMpOyAvLyBpbiB0aGUgZnV0dXJlLCBzZXQgbWF4WSB0byB0aGUgdmFsdWUgb2YgdGhlIG1heGltdW0gY29uZmlkZW5jZSBsaW1pdFxuICAgIGlmIChwcml2KSB7XG4gICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgdmFyIG1heENJID0gZDMubWF4KGNpVXBwZXJWYWxzKTtcbiAgICAgICAgICAgIG1heFkgPSBtYXhDSTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG5cbiAgICB2YXIgbXlkaXY7XG4gICAgaWYgKGRpdiA9PSBcInNldHhcIikge1xuICAgICAgICBteWRpdiA9IFwiI3NldHhcIjtcbiAgICB9IGVsc2UgaWYgKGRpdiA9PSBcInZhclN1bW1hcnlcIikge1xuICAgICAgICBteWRpdiA9IFwiI3RhYjNcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYWxlcnQoXCJFcnJvcjogaW5jb3JyZWN0IGRpdiBzZWxlY3RlZCBmb3IgcGxvdHNcIik7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChteWRpdikuc3R5bGUoXCJ3aWR0aFwiKVxuICAgIHZhciB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgKHRlbXBXaWR0aC5sZW5ndGggLSAyKSk7XG5cbiAgICB2YXIgdGVtcEhlaWdodCA9IGQzLnNlbGVjdChteWRpdikuc3R5bGUoXCJoZWlnaHRcIilcbiAgICB2YXIgaGVpZ2h0ID0gdGVtcEhlaWdodC5zdWJzdHJpbmcoMCwgKHRlbXBIZWlnaHQubGVuZ3RoIC0gMikpO1xuXG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDIwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiA1MFxuICAgIH07XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB3aWR0aCA9IDAuNyAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4zICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKG15ZGl2ID09IFwiI3NldHhcIikge1xuICAgICAgICB3aWR0aCA9IDIwMDtcbiAgICAgICAgaGVpZ2h0ID0gMTIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMC4zNSAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4yNSAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfTtcblxuICAgIGlmIChwcml2ICYmIG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAxLjVdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIH1cblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAuZXh0ZW50KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnN1YnNldHJhbmdlLmxlbmd0aCA9PSAxID9cbiAgICAgICAgICAgICAgICBbbm9kZS5zdWJzZXRyYW5nZVswXSwgbm9kZS5zdWJzZXRyYW5nZVswXV1cbiAgICAgICAgICAgICAgICA6IG5vZGUuc3Vic2V0cmFuZ2U7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQpO1xuXG4gICAgdmFyIGJydXNoMiA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQyKTtcblxuICAgIC8vIENyZWF0ZSBTVkcgZWxlbWVudFxuICAgIC8vIGN1bWJlcnNvbWUgdG8gdHJlYXQgXCJ0YWIzXCIgZGlmZmVyZW50bHksIGJ1dCB3b3JrcyBmb3Igbm93XG4gICAgLy8gdGFiMywgaGFzIGFuIGlzc3VlLCB0aGF0IHVubGVzcyB3aWR0aCBoZWlnaHQgaGFyZGNvZGVkLCB0aGV5IGdyb3cgd2l0aCBlYWNoIGFkZGl0aW9uYWwgZ3JhcGguXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KG15ZGl2LnN1YnN0cigxKSkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCAzMDApIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgMjAwKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBteW5hbWUgPSBteW5hbWUucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChcIl9cIiwgbXlkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuICAgIH07XG5cbiAgICB2YXIgcmVjdFdpZHRoID0geChtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpOyAvL3RoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG5cbiAgICBwbG90c3ZnLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAoZCwgaSkgPT4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAuYXR0cihcInlcIiwgZCA9PiB5KG1heFkgLSBkKSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkpIFxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjMWY3N2I0XCIpO1xuXG4gICAgLy8gZHJhdyBlcnJvciBiYXJzLCB0aHJlc2hvbGQgbGluZSBhbmQgZXh0cmEgYmluXG4gICAgaWYgKHByaXYpIHtcbiAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA8PSAyMCkge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY2lVcHBlclZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLyAyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgXHQuYXR0cihcInkxXCIsIGQgPT4geShtYXhZIC0gZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLyAyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICB5MiA9IHkobWF4WSAtIGQgKyBjaVNpemUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geTIgPj0geShtYXhZKSA/IHkobWF4WSkgOiB5MjtcbiAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vZHJhdyB0b3AgdGlja3Mgb24gZXJyb3IgYmFyc1xuICAgICAgICAgICAgLy9uZWVkIHRvIGZpeCB0aGUgaGVpZ2h0IG9mIHRoZSBncmFwaHMgLSB0aGUgdG9wcyBvZiBlcnJvciBiYXJzIGFyZSBnZXR0aW5nIGN1dCBvZmZcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwiLnRvcFRpY2tcIilcbiAgICAgICAgICAgICAgICAuZGF0YShjaVVwcGVyVmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRvcFRpY2tcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgLy9tYWtlIHRpY2sgYmlnZ2VyIHRvIGluY3JlYXNlIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjQgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KG1heFkgLSBkKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLy9tYWtlIHRpY2sgYmlnZ2VyIHRvIGluY3JlYXNlIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjYgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBkID0+IHkobWF4WSAtIGQpKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBib3R0b20gdGlja3Mgb2YgZXJyb3IgYmFyc1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIuYm90dG9tVGlja1wiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpTG93ZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYm90dG9tVGlja1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNCAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGQgPT4geShtYXhZIC0gZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNiAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4geShtYXhZIC0gZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIuZGVuc2VFcnJvclwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZGVuc2VFcnJvclwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geShtYXhZIC0gZCkgLSAuMSAqIHkoZCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShtYXhZIC0gZCkgKyAuMSAqIHkoZCkpIC0gKHkobWF4WSAtIGQpIC0gLjEgKiB5KGQpKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcInNpbHZlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgc3RhdGVtZW50IGZvciBzdGFiaWxpdHkgaGlzdG9ncmFtc1xuICAgICAgICAvL2V4dHJhIHN0YWJpbGl0eSBiaW5cbiAgICAgICAgaWYgKG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeChtYXhYICsgMC41IC0gYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHkobWF4WSkgLSBub2RlLnN0YWJpbGl0eUJpbilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBub2RlLnN0YWJpbGl0eUJpbilcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJzaWx2ZXJcIilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhyZXNob2xkIGxpbmVcbiAgICAgICAgaWYgKG5vZGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeChtaW5YIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5KG1heFkpIC0gbm9kZS50aHJlc2hvbGQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdGFiaWxpdHlCaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUuc3RhYmlsaXR5QmluKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geChtYXhYICsgMC41IC0gYmFyUGFkZGluZykgKyByZWN0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geChtYXhYICsgMC41IC0gYmFyUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeShtYXhZKSAtIG5vZGUudGhyZXNob2xkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBsb3RYYXhpcykge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICB9XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aCAvIDIpKVxuICAgICAgICAuYXR0cihcInlcIiwgMCAtIChtYXJnaW4udG9wIC8gMikpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAudGV4dChub2RlLm5hbWUpO1xuXG4gICAgaWYgKG15ZGl2ID09IFwiI3NldHhcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIiArIHlWYWxLZXlbdF0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlMlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDUwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIgKyB5VmFsS2V5W3RdLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgYWxsIHpzY29yZXMgaW4gdGhlIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICB2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZCA9PiBkLngpXG4gICAgICAgICAgICAueShkID0+IGQueSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKTtcblxuICAgICAgICB2YXIgY29sU2VxID0gW1wiI0EyQ0Q1QVwiLCBcIm9yYW5nZVwiLCBcInJlZFwiXTsgLy8gd2lsbCBjeWNsZSB0aHJvdWdoIGNvbG9yIHNlcXVlbmNlLCBhbmQgdGhlbiByZXBlYXQgbGFzdCBjb2xvclxuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgdmFyIHpMb3dlciA9IC0xICogKG1pblggLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciB6VXBwZXIgPSAobWF4WCAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgdXBwZXIgYm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpVcHBlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekxvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGQzLm1pbih4VmFscyk7IGkgPD0gZDMubWF4KHhWYWxzKTsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoaSksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43NVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KGkpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuODVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgc2xpZGVyIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIHNsaWRlQm94ID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjggKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAudGlja3MoMClcbiAgICAgICAgICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpKVxuXG4gICAgICAgIHZhciBzbGlkZXIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoKTtcblxuICAgICAgICB2YXIgaGFuZGxlID0gc2xpZGVyLmFwcGVuZChcInBvbHlnb25cIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuNyArIFwiKVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJwb2ludHNcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gNjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zZXR4dmFsc1swXSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hdHVyZSA9PSBcIm5vbWluYWxcIikgeyAvLyBpZiBub21pbmFsLCB1c2UgdGhlIG1lZGlhbiBmcmVxdWVuY3kgYXMgdGhlIHBvc2l0aW9uIGZvciB0aGUgc2V0eCBzbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4bm0gPSB4KE1hdGgucm91bmQoeFZhbHMubGVuZ3RoIC8gMikgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4bm0gPSB4KG5vZGUubWVhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeG5tID0geChub2RlLnNldHh2YWxzWzBdKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4bm0gLSBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgKHhubSArIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyB4bm0gKyBcIixcIiArIChzICogMS4zKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzbGlkZXIyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaDIpO1xuXG4gICAgICAgIHZhciBoYW5kbGUyID0gc2xpZGVyMi5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjkgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IDY7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc2V0eHZhbHNbMV0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYXR1cmUgPT0gXCJub21pbmFsXCIpIHsgLy8gaWYgbm9taW5hbCwgdXNlIHRoZSBtZWRpYW4gZnJlcXVlbmN5IGFzIHRoZSBwb3NpdGlvbiBmb3IgdGhlIHNldHggc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeG5tID0geChNYXRoLnJvdW5kKHhWYWxzLmxlbmd0aCAvIDIpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeG5tID0geChub2RlLm1lYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhubSA9IHgobm9kZS5zZXR4dmFsc1sxXSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiAoeG5tIC0gcykgKyBcIixcIiArIHMgKyBcIiBcIiArICh4bm0gKyBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgeG5tICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHdvU0YoeCkge1xuICAgICAgICB2YXIgdHNmID0gZDMuZm9ybWF0KFwiLjJyXCIpOyAvLyBmb3JtYXQgdG8gdHdvIHNpZ25pZmljYW50IGZpZ3VyZXMgYWZ0ZXIgdGhlIGRlY2ltYWwgcGxhY2VcbiAgICAgICAgcmV0dXJuIHRzZih4KS5yZXBsYWNlKC8wKyQvLCBcIlwiKS5yZXBsYWNlKC9cXC4kLywgXCJcIikgLy8gdHJpbSB0cmFpbGluZyB6ZXJvcyBhZnRlciBhIHBlcmlvZCwgYW5kIGFueSBvcnBoYW5lZCBwZXJpb2RcbiAgICB9XG5cbiAgICAvLyBicnVzaGluZyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBicnVzaGVkKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaC5leHRlbnQoKVswXTtcbiAgICAgICAgdmFyIHMgPSA2O1xuXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICBicnVzaC5leHRlbnQoW3ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHggcG9zaXRpb24gb2Ygc2xpZGVyIGNlbnRlciAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgeHBvcyA9IHgodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXhYKSB7IC8vIGRyYWdnZWQgcGFzdCBtYXhcbiAgICAgICAgICAgIHhwb3MgPSB4KG1heFgpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgbWluWCkgeyAvLyBkcmFnZ2VkIHBhc3QgbWluXG4gICAgICAgICAgICB4cG9zID0geChtaW5YKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtID0gK25vZGUubWVhbjtcbiAgICAgICAgICAgIHZhciBzZCA9ICtub2RlLnNkO1xuICAgICAgICAgICAgdmFyIHpTY29yZSA9ICh2YWx1ZSAtIG0pIC8gc2Q7IC8vIHotc2NvcmVcbiAgICAgICAgICAgIHZhciB6Um91bmQgPSBNYXRoLnJvdW5kKHpTY29yZSk7IC8vIG5lYXJlc3QgaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICBpZiAoLjEgPiBNYXRoLmFicyhNYXRoLnJvdW5kKHZhbHVlKSAtIHZhbHVlKSkgeyAvLyBzbmFwIHRvIGludGVnZXJcbiAgICAgICAgICAgICAgICB4cG9zID0geChNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgeyAvLyBzbmFwIHRvIGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KG0gKyAoelJvdW5kICogc2QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgc3ltYm9sIGFuZCB0ZXh0XG4gICAgICAgIGhhbmRsZS5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoeHBvcyAtIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAocyAqIDEuMyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjcmFuZ2VcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiICsgeVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDogXCIuY29uY2F0KCsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBub2RlLnNldHh2YWxzWzFdID0gKyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KTtcbiAgICB9XG5cbiAgICAvLyBjZXJ0YWlubHkgYSBtb3JlIGNsZXZlciB3YXkgdG8gZG8gdGhpcywgYnV0IGZvciBub3cgaXQncyBiYXNpY2FsbHkgY29waWVkIHdpdGggYnJ1c2ggYW5kIGhhbmRsZSBjaGFuZ2VzIHRvIGJydXNoMiBhbmQgaGFuZGxlMiBhbmQgI3JhbmdlIHRvICNyYW5nZTIgYW5kIHNldHh2YWxzWzBdIHRvIHNldHh2YWxzWzFdXG4gICAgZnVuY3Rpb24gYnJ1c2hlZDIoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGJydXNoMi5leHRlbnQoKVswXTtcbiAgICAgICAgdmFyIHMgPSA2OyAvLyBzY2FsaW5nIGZvciB0cmlhbmdsZSBzaGFwZVxuXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICBicnVzaDIuZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXIgXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiICsgeVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxufVxuXG4vLyBkcmF3cyBiYXJwbG90cyBpbiBzdWJzZXQgdGFiXG5leHBvcnQgZnVuY3Rpb24gYmFyc1N1YnNldChub2RlKSB7XG4gICAgLy8gaWYgdW50b3VjaGVkLCBzZXQgbm9kZS5zdWJzZXRyYW5nZSB0byBhbiBlbXB0eSBhcnJheSwgbWVhbmluZyBhbGwgdmFsdWVzIHNlbGVjdGVkIGJ5IGRlZmF1bHRcbiAgICBpZiAobm9kZS5zdWJzZXRyYW5nZVswXSA9PSBcIlwiICYgbm9kZS5zdWJzZXRyYW5nZVsxXSA9PSBcIlwiKSB7XG4gICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBIaXN0b2dyYW0gc3BhY2luZ1xuICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG4gICAgdmFyIHBsb3RYYXhpcyA9IHRydWU7XG5cbiAgICAvLyBWYXJpYWJsZSBuYW1lXG4gICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpO1xuICAgIG15bmFtZSA9IG15bmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpO1xuXG4gICAgLy8gRGF0YVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5wbG90dmFsdWVzKTtcbiAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgdmFyIHhpID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHlWYWxzW3hpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgIHlWYWxLZXkucHVzaCh7XG4gICAgICAgICAgICB5OiB5VmFsc1t4aV0sXG4gICAgICAgICAgICB4OiBrZXlzW2ldXG4gICAgICAgIH0pO1xuICAgICAgICB4aSA9IHhpICsgMTtcbiAgICB9XG4gICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikgeyAvLyBpZiBub21pbmFsLCBvcmRlcnMgYmFycyBsZWZ0IHRvIHJpZ2h0LCBoaWdoZXN0IGZyZXF1ZW5jeSB0byBsb3dlc3RcbiAgICAgICAgeVZhbEtleS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnkgLSBhLnlcbiAgICAgICAgfSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiIC0gYVxuICAgICAgICB9KTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICB9XG5cbiAgICBwbG90WGF4aXMgPSBmYWxzZTtcblxuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuICAgIHZhciBnbmFtZSA9IFtcInN1YnNldHllc1wiLCBcInN1YnNldG5vXCJdO1xuXG4gICAgdmFyIHlWYWxzMiA9IFtdO1xuICAgIHZhciB5VmFsczEgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgeVZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeVZhbHMxLnB1c2goe1xuICAgICAgICAgICAgeTA6IG1heFkgLSB5VmFsc1tpXSxcbiAgICAgICAgICAgIHkxOiB5VmFsc1tpXSxcbiAgICAgICAgICAgIGNvbDogZDNDb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgeVZhbHMyLnB1c2goe1xuICAgICAgICAgICAgeTA6IDAsXG4gICAgICAgICAgICB5MTogbWF4WSAtIHlWYWxzW2ldLFxuICAgICAgICAgICAgY29sOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBmcmVxcyA9IFt5VmFsczEsIHlWYWxzMl07XG5cbiAgICAvLyB5MCBpcyB0aGUgc3RhcnRpbmcgcG9pbnRcbiAgICAvLyB5MSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXJcblxuICAgIHZhciBteWRpdiA9IFwiI3RhYjJcIjtcbiAgICB2YXIgd2lkdGggPSAyMDA7XG4gICAgdmFyIGhlaWdodCA9IDEyMDtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMjAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDUwXG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICAvL0NyZWF0ZSBTVkcgZWxlbWVudFxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChcIl9cIiwgbXlkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHZhciBmcmVxID0gcGxvdHN2Zy5zZWxlY3RBbGwoXCJnLmZyZXFcIilcbiAgICAgICAgLmRhdGEoZnJlcXMpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImZyZXFcIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KGduYW1lW2ldKTtcbiAgICAgICAgfSk7XG5cbiAgICB2YXIgcmVjdCA9IGZyZXEuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YShPYmplY3QpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhclwiKVxuICAgICAgICAuYXR0cihcIm5hbWVcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhWYWxzW2ldO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQueTApO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKSkgLy8gdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC55MSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID4gMCAmIGQuY29sID09PSBkM0NvbG9yICYgJC5pbkFycmF5KHhWYWxzW2ldLnRvU3RyaW5nKCksIG5vZGUuc3Vic2V0cmFuZ2UpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsVmFyQ29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT0gbXluYW1lLmNvbmNhdChcInN1YnNldG5vXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0TWUgPSAkKCdbbmFtZT1cIicgKyBteW5hbWUuY29uY2F0KFwic3Vic2V0eWVzXCIpICsgJ1wiXScpLmNoaWxkcmVuKCdbbmFtZT1cIicgKyBzZWxlY3ROYW1lICsgJ1wiXScpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlDb2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZS5maWxsID09PSBzZWxWYXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG15aW5kZXggPSBub2RlLnN1YnNldHJhbmdlLmluZGV4T2YodGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2Uuc3BsaWNlKG15aW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlDb2wgPSBkM0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZS5wdXNoKHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBteUNvbCA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBteUNvbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNzZWxlY3RyYW5nZVwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBhbGwgdmFsdWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBub2RlLnN1YnNldHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZHMucHVzaCh5VmFsS2V5W3ZhbF0ueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBcIiArIHNlbGVjdGVkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCgpID0+IHlWYWxLZXlbaV0ueCArIFwiOiBcIiArIHlWYWxLZXlbaV0ueSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjbXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiBcIlZhbHVlOiBGcmVxdWVuY3lcIik7IFxuICAgICAgICB9KTtcblxuICAgIGlmIChwbG90WGF4aXMpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyAyMClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwiVmFsdWU6IEZyZXF1ZW5jeVwiKTsgXG4gICAgfVxuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSAobWFyZ2luLnRvcCAvIDIpKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgLnRleHQobXluYW1lKTtcblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwic2VsZWN0cmFuZ2VcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgIC50ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLnN1YnNldHJhbmdlLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlNlbGVjdGVkOiBhbGwgdmFsdWVzXCI7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRzID0gbmV3IEFycmF5O1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZS5mb3JFYWNoKHZhbCA9PiAgc2VsZWN0ZWRzLnB1c2goeVZhbEtleVt2YWxdLngpKTtcbiAgICAgICAgICAgIHJldHVybiBcIlNlbGVjdGVkOiBcIiArIHNlbGVjdGVkcztcbiAgICAgICAgfSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbnNpdHlOb2RlKG5vZGUsIG9iaikge1xuICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQoXCJub2RlcGxvdFwiKTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBvYmogPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlLm5hbWUudG9TdHJpbmcoKSArIFwiYmlnZ3JvdXBcIik7XG4gICAgICAgIC8vIGlmIG9iaiBjb250YWlucyBhbiBzdmcgZWxlbWVudCwgcmVtb3ZlIGl0LiB0aGlzIHJlbW92ZXMgYW55IHBsb3QgaW5zaWRlIHRoZSBub2RlXG4gICAgICAgIGlmIChkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIilbMF0ubGVuZ3RoID4gMClcbiAgICAgICAgICAgIGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeVZhbHMgPSBub2RlLnBsb3R5O1xuICAgIHZhciB4VmFscyA9IG5vZGUucGxvdHg7XG5cbiAgICAvLyBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgdmFyIGRhdGEyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnBsb3R4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGEyLnB1c2goe1xuICAgICAgICAgICAgeDogbm9kZS5wbG90eFtpXSxcbiAgICAgICAgICAgIHk6IG5vZGUucGxvdHlbaV1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGF0YTIuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgIGQueCA9ICtkLng7XG4gICAgICAgIGQueSA9ICtkLnk7XG4gICAgfSk7XG5cbiAgICB2YXIgd2lkdGggPSA2MDsgLy8gaGFyZGNvZGVkLCBzaG91bGQgYmUgc2V0IGF1dG9tYXRpY2FsbHlcbiAgICB2YXIgaGVpZ2h0ID0gMzA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih5VmFscyksIGQzLm1heCh5VmFscyldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuXG4gICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueTAoaGVpZ2h0KVxuICAgICAgICAueTEoZCA9PiB5KGQueSkpO1xuXG4gICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3Qob2JqKVxuICAgICAgICAuaW5zZXJ0KFwic3ZnXCIsIFwiOmZpcnN0LWNoaWxkXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAtNDApIC8vIE5PVEU6IE5vdCBzdXJlIGV4YWN0bHkgd2h5IHRoZXNlIG51bWJlcnMgd29yaywgYnV0IHRoZXNlIGhhcmRjb2RlZCB2YWx1ZXMgc2VlbSB0byBwb3NpdGlvbiB0aGUgcGxvdCBpbnNpZGUgZyBjb3JyZWN0bHkuICB0aGlzIHNob3VsZG4ndCBiZSBoYXJkY29kZWQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAuYXR0cihcInlcIiwgLTQ1KVxuICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG15bmFtZSlcbiAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmRhdHVtKGRhdGEyKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzTm9kZShub2RlLCBvYmopIHtcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KFwibm9kZXBsb3RcIik7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5uYW1lLnRvU3RyaW5nKCkgKyBcImJpZ2dyb3VwXCIpO1xuICAgICAgICAvLyBpZiBvYmogY29udGFpbnMgYW4gc3ZnIGVsZW1lbnQsIHJlbW92ZSBpdC4gdGhpcyByZW1vdmVzIGFueSBwbG90IGluc2lkZSB0aGUgbm9kZVxuICAgICAgICBpZiAoZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICB2YXIgdG9wU2NhbGUgPSAxLjI7IC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzW2tleXNbaV1dID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgICAgIHlWYWxLZXkucHVzaCh7eTogeVZhbHNbeGldLCB4OiBrZXlzW2ldfSk7XG4gICAgICAgICAgICB4aSA9IHhpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB5VmFsS2V5LnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB5VmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW2ldID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1heFkgPSBkMy5tYXgoeVZhbHMpO1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG5cbiAgICB2YXIgd2lkdGggPSA2MDtcbiAgICB2YXIgaGVpZ2h0ID0gMzA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG4gICAgLy9DcmVhdGUgU1ZHIGVsZW1lbnRcbiAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChvYmopXG4gICAgICAgIC5pbnNlcnQoXCJzdmdcIiwgXCI6Zmlyc3QtY2hpbGRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIC00MClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC00NSlcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBteW5hbWUpIFxuICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCkgLy8gc2V0IGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiAgeCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAuYXR0cihcInlcIiwgZCA9PiAgeShtYXhZIC0gZCkpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeChtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpKSAvLyB0aGUgXCJ3aWR0aFwiIGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGJhclxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5KSBcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzFmNzdiNFwiKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvcGxvdHMuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBR0E7QUE4VkE7QUE0aUJBO0FBNk5BO0FBa0VBO0FBNXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQUlBO0FBR0E7QUFJQTtBQUdBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUFBO0FBRkE7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQUE7QUFGQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUZBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFGQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFKQTtBQUNBO0FBU0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBS0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUtBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFBQTtBQUpBO0FBQ0E7QUFTQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBTEE7QUFTQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/* no static exports found */
/* all exports used */
/*!******************************!*\
  !*** ./~/process/browser.js ***!
  \******************************/
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzPzgyZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./~/setimmediate/setImmediate.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/global.js */ 0), __webpack_require__(/*! ./../process/browser.js */ 8)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz80YTgwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 10 */
/* no static exports found */
/* all exports used */
/*!*************************************!*\
  !*** ./~/timers-browserify/main.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ 9);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);